<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coreMQTT: Timeouts in coreMQTT library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="foobar.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coreMQTT<span id="projectnumber">&#160;v1.1.0</span>
   </div>
   <div id="projectbrief">MQTT 3.1.1 Client Library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('mqtt_timeouts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Timeouts in coreMQTT library </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Information about timeouts that coreMQTT library relies on.</p>
<p >The coreMQTT library relies on timeouts to handle MQTT keep-alive mechanism and Transport Send and Receive operations. Timeouts must be configured correctly for ensuring the expected behavior of the application using the coreMQTT library. The timeouts and the recommended configurations are listed below.</p><ol type="1">
<li><a class="el" href="mqtt_timeouts.html#mqtt_timeouts_transport_send_receive">Transport Send and Receive timeouts</a></li>
<li><a class="el" href="mqtt_timeouts.html#mqtt_timeouts_keep_alive">MQTT Keep Alive interval</a></li>
<li><a class="el" href="mqtt_timeouts.html#mqtt_timeouts_ping_response">MQTT Ping Response timeout</a></li>
<li><a class="el" href="mqtt_timeouts.html#mqtt_timeouts_receive_polling">MQTT Receive Polling timeout</a></li>
<li><a class="el" href="mqtt_timeouts.html#mqtt_timeouts_send_retry">MQTT Send Retry timeout</a></li>
<li><a class="el" href="mqtt_timeouts.html#mqtt_timeouts_process_receive_loop">Timeouts for MQTT_ProcessLoop and MQTT_ReceiveLoop APIs</a></li>
<li><a class="el" href="mqtt_timeouts.html#mqtt_timeouts_connect">Timeout for MQTT_Connect</a></li>
</ol>
<h1><a class="anchor" id="mqtt_timeouts_transport_send_receive"></a>
Transport Send and Receive timeouts</h1>
<p >These are the network send and read operation blocking timeouts used by the implementation of Transport Send and Transport Receive functions, respectively, that are supplied to the coreMQTT library. Transport Send and Receive timeouts must be configured by the application for the Transport interface implementation provided to the coreMQTT library. If it is essential to send more data than the size of the TCP buffer, then the Transport Send timeout can be set to a bigger value than that of cases in which size of the data to be sent is smaller than the TCP buffer, so as to efficiently wait for the TCP buffer to be available to copy the data from MQTT buffers.</p>
<p >We recommend using a relatively smaller value for these timeouts as compared to the MQTT Keep Alive interval, so as to make sure that an MQTT Control packet including an MQTT ping request packet can be sent to the Server even within the Keep Alive interval, even if the Transport functions block for the maximum time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="mqtt_transport_interface.html">Transport Interface</a></dd></dl>
<h1><a class="anchor" id="mqtt_timeouts_keep_alive"></a>
MQTT Keep Alive interval</h1>
<p >MQTT Keep Alive interval is the maximum time interval that is permitted to elapse between the point at which the MQTT Client finishes transmitting one Control Packet and the point it starts sending the next. If the Server does not receive a Control Packet from the Client within one and a half times the Keep Alive time period, it will disconnect the MQTT connection to the Client.</p>
<p >If <a class="el" href="mqtt_processloop_function.html">MQTT_ProcessLoop</a> function is used to manage keep alive in the application, the MQTT Keep Alive interval must be configured to be a value larger than that of the Transport Send and Receive timeouts. This is to make sure that a Control packet including an MQTT ping request packet can be sent to the Server even if the Transport functions block for the maximum time. MQTT Keep Alive interval can be configured by setting the <code>keepAliveIntervalSec</code> member of the <a class="el" href="group__mqtt__struct__types.html">MQTTContext_t</a> structure.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="mqtt_design.html#mqtt_keepalive">Keep-Alive</a></dd></dl>
<h1><a class="anchor" id="mqtt_timeouts_ping_response"></a>
MQTT Ping Response timeout</h1>
<p >MQTT Ping Response timeout is the time to wait for a ping response to an MQTT ping request as part of the keep-alive mechanism in the MQTT Client. This timeout can be configured independent of the Transport timeouts unlike the MQTT Keep Alive interval, since this timeout only depends on the MQTT broker, the platform and the network latencies.</p>
<p >We recommend to choose a ping response timeout by experimenting with an MQTT application on a sample of devices and collecting the data of latency for each ping response from the broker after a ping request is sent. A timeout value can then be chosen based on the statistical measure suitable for the end application, such as 99th percentile or average.</p>
<p >MQTT Ping Response timeout can be set by defining the configuration <a class="el" href="core_mqtt_config.html#MQTT_PINGRESP_TIMEOUT_MS">MQTT_PINGRESP_TIMEOUT_MS</a>.</p>
<h1><a class="anchor" id="mqtt_timeouts_receive_polling"></a>
MQTT Receive Polling timeout</h1>
<p >MQTT Receive Polling timeout is the maximum duration between non-empty network reads while receiving an MQTT packet via the <a class="el" href="mqtt_processloop_function.html">MQTT_ProcessLoop</a> or <a class="el" href="mqtt_receiveloop_function.html">MQTT_ReceiveLoop</a> API functions. This timeout represents the maximum polling duration that is allowed without any data reception from the network for the incoming packet.</p>
<p >It is important to note that having this timeout too short will result in MQTT being disconnected due to the possibility of partial data being received. If you have small TCP buffers and a high latency network, the optimum value for the timeout can be surprisingly long. In such cases, optimum value for the timeout can be better determined based on experimenting the MQTT applications with payloads bigger than the TCP buffer. If a retry is required for a Transport Receive even after hitting a timeout of Transport Receive without any data received, we recommend using a value larger than the Transport Receive timeout. If a dummy implementation of the <a class="el" href="group__mqtt__callback__types.html#gae3bea55b0e49e5208b8c5709a5ea23aa">MQTTGetCurrentTimeFunc_t</a> timer function, that always returns 0, is used, then this timeout must be set to 0.</p>
<p >The MQTT Receive Polling timeout can be set by defining the configuration <a class="el" href="core_mqtt_config.html#MQTT_RECV_POLLING_TIMEOUT_MS">MQTT_RECV_POLLING_TIMEOUT_MS</a>.</p>
<h1><a class="anchor" id="mqtt_timeouts_send_retry"></a>
MQTT Send Retry timeout</h1>
<p >MQTT Send Retry timeout is the maximum duration between non-empty network transmissions while sending an MQTT packet via the <a class="el" href="mqtt_processloop_function.html">MQTT_ProcessLoop</a> or <a class="el" href="mqtt_receiveloop_function.html">MQTT_ReceiveLoop</a> API functions. This timeout represents the maximum duration that is allowed for no data transmission over the network through the Transport Send function.</p>
<p >It is important to note that having this timeout too short will result in MQTT being disconnected due to the possibility of partial data being sent. If you have small TCP buffers and a high latency network, the optimum value for the timeout can be surprisingly long. In such cases, optimum value for the timeout can be better determined based on experimenting the MQTT applications with payloads bigger than the TCP buffer. If a retry is required for a Transport Send even after hitting a timeout of Transport Send before any data could be sent to transport layer, we recommend using a value larger than the Transport Send timeout. If a dummy implementation of the <a class="el" href="group__mqtt__callback__types.html#gae3bea55b0e49e5208b8c5709a5ea23aa">MQTTGetCurrentTimeFunc_t</a> timer function, that always returns 0, is used, then this timeout must be set to 0.</p>
<p >The MQTT Send Retry timeout can be set by defining the configuration <a class="el" href="core_mqtt_config.html#MQTT_SEND_RETRY_TIMEOUT_MS">MQTT_SEND_RETRY_TIMEOUT_MS</a>.</p>
<h1><a class="anchor" id="mqtt_timeouts_process_receive_loop"></a>
Timeouts for MQTT_ProcessLoop and MQTT_ReceiveLoop APIs</h1>
<p >This timeout is passed as an argument to <a class="el" href="mqtt_processloop_function.html">MQTT_ProcessLoop</a> or <a class="el" href="mqtt_receiveloop_function.html">MQTT_ReceiveLoop</a> API functions. It is the minimum time that the receive loop in these API functions will run, unless an error occurs. These APIs may be blocked for more time than this timeout, since the APIs will attempt to send and receive MQTT packets to the network using the Transport implementation. The maximum time spent on Transport functions for send and receive depends on the Transport Send and Receive timeouts and the MQTT Receive Polling timeouts as explained in the descriptions of these timeouts above.</p>
<p >Passing a timeout value of 0 will run these APIs for a single iteration. The other timeouts mentioned thus far ensure you don't disconnect the MQTT just because the network is slow or buffers get full. They are necessary because coreMQTT has no 'memory' of being half way through a packet and will just error and disconnect if you don't give enough time for incoming or outgoing packet delivery. That means, especially in multi-threaded application, the process loop timeout can be zero.</p>
<p ><a class="el" href="mqtt_processloop_function.html">MQTT_ProcessLoop</a> API can be used to manage the MQTT keep-alive mechanism and if used, application must invoke this API faster than the MQTT Keep Alive interval. If a dummy <a class="el" href="group__mqtt__callback__types.html#gae3bea55b0e49e5208b8c5709a5ea23aa">MQTTGetCurrentTimeFunc_t</a> was passed to <a class="el" href="mqtt_init_function.html">MQTT_Init</a>, then the keep-alive mechanism is not supported by the <a class="el" href="mqtt_processloop_function.html">MQTT_ProcessLoop</a> API; instead the <a class="el" href="mqtt_receiveloop_function.html">MQTT_ReceiveLoop</a> should be used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="mqtt_design.html#mqtt_receivetimeout">Timeouts</a></dd></dl>
<h1><a class="anchor" id="mqtt_timeouts_connect"></a>
Timeout for MQTT_Connect</h1>
<p >This timeout is passed as an argument to <a class="el" href="mqtt_connect_function.html">MQTT_Connect</a>. It is the maximum time to wait for an MQTT CONNACK packet. If this value is set to 0, then instead of a time-based loop, it will attempt to call the Transport Receive function up to a maximum number of retries, which is defined by <a class="el" href="core_mqtt_config.html#MQTT_MAX_CONNACK_RECEIVE_RETRY_COUNT">MQTT_MAX_CONNACK_RECEIVE_RETRY_COUNT</a>.</p>
<p >We recommend to choose a timeout for <a class="el" href="mqtt_connect_function.html">MQTT_Connect</a> by experimenting with an MQTT application on a sample of devices and collecting the data of latency for each CONNACK packet received from the broker after an MQTT CONNECT packet is sent. A timeout value can then be chosen based on the statistical measure suitable for the end application, such as 99th percentile or average.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="mqtt_design.html#mqtt_receivetimeout">Timeouts</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
