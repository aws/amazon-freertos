<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_IP.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="foobar.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V2.3.2</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___i_p_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_IP.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements the basic functionality for the FreeRTOS+TCP network stack.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;queue.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Sockets.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ARP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_UDP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DHCP.h&quot;</code><br />
<code>#include &quot;NetworkInterface.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionx_union32.html">xUnion32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionx_union_ptr.html">xUnionPtr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8ef9c6533cd9f34111f6ff1e5843507d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a8ef9c6533cd9f34111f6ff1e5843507d">ipEXPECTED_EthernetHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 14 )</td></tr>
<tr class="memdesc:a8ef9c6533cd9f34111f6ff1e5843507d"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a8ef9c6533cd9f34111f6ff1e5843507d">More...</a><br /></td></tr>
<tr class="separator:a8ef9c6533cd9f34111f6ff1e5843507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13c9f74e9fe374fa459f8df1864dc72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ac13c9f74e9fe374fa459f8df1864dc72">ipEXPECTED_ARPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 28 )</td></tr>
<tr class="memdesc:ac13c9f74e9fe374fa459f8df1864dc72"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#ac13c9f74e9fe374fa459f8df1864dc72">More...</a><br /></td></tr>
<tr class="separator:ac13c9f74e9fe374fa459f8df1864dc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43457a3ba4fd6f16a4d33394af459536"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a43457a3ba4fd6f16a4d33394af459536">ipEXPECTED_IPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 20 )</td></tr>
<tr class="memdesc:a43457a3ba4fd6f16a4d33394af459536"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a43457a3ba4fd6f16a4d33394af459536">More...</a><br /></td></tr>
<tr class="separator:a43457a3ba4fd6f16a4d33394af459536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527470135bea5ef3d75f3c1206431584"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a527470135bea5ef3d75f3c1206431584">ipEXPECTED_IGMPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 8 )</td></tr>
<tr class="memdesc:a527470135bea5ef3d75f3c1206431584"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a527470135bea5ef3d75f3c1206431584">More...</a><br /></td></tr>
<tr class="separator:a527470135bea5ef3d75f3c1206431584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc89907d7a25a7f795f2abcd9eb6aa6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a0dc89907d7a25a7f795f2abcd9eb6aa6">ipEXPECTED_ICMPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 8 )</td></tr>
<tr class="memdesc:a0dc89907d7a25a7f795f2abcd9eb6aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a0dc89907d7a25a7f795f2abcd9eb6aa6">More...</a><br /></td></tr>
<tr class="separator:a0dc89907d7a25a7f795f2abcd9eb6aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc551f421556711f0924201c04c9f82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a2cc551f421556711f0924201c04c9f82">ipEXPECTED_UDPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 8 )</td></tr>
<tr class="memdesc:a2cc551f421556711f0924201c04c9f82"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a2cc551f421556711f0924201c04c9f82">More...</a><br /></td></tr>
<tr class="separator:a2cc551f421556711f0924201c04c9f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada34cd2dcc842a6c43cd9c85acd0ebc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ada34cd2dcc842a6c43cd9c85acd0ebc2">ipEXPECTED_TCPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 20 )</td></tr>
<tr class="memdesc:ada34cd2dcc842a6c43cd9c85acd0ebc2"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#ada34cd2dcc842a6c43cd9c85acd0ebc2">More...</a><br /></td></tr>
<tr class="separator:ada34cd2dcc842a6c43cd9c85acd0ebc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576713b2b5c693d521be50e120d1d106"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a576713b2b5c693d521be50e120d1d106">ipICMP_ECHO_REQUEST</a>&#160;&#160;&#160;( ( uint8_t ) 8 )</td></tr>
<tr class="memdesc:a576713b2b5c693d521be50e120d1d106"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a576713b2b5c693d521be50e120d1d106">More...</a><br /></td></tr>
<tr class="separator:a576713b2b5c693d521be50e120d1d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f4a6a59729b84b4f858c9e2532fa9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a20f4a6a59729b84b4f858c9e2532fa9f">ipICMP_ECHO_REPLY</a>&#160;&#160;&#160;( ( uint8_t ) 0 )</td></tr>
<tr class="memdesc:a20f4a6a59729b84b4f858c9e2532fa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a20f4a6a59729b84b4f858c9e2532fa9f">More...</a><br /></td></tr>
<tr class="separator:a20f4a6a59729b84b4f858c9e2532fa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d61855955d5d08f6933f84bc668d80f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a8d61855955d5d08f6933f84bc668d80f">ipFIRST_MULTI_CAST_IPv4</a>&#160;&#160;&#160;0xE0000000UL</td></tr>
<tr class="memdesc:a8d61855955d5d08f6933f84bc668d80f"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a8d61855955d5d08f6933f84bc668d80f">More...</a><br /></td></tr>
<tr class="separator:a8d61855955d5d08f6933f84bc668d80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31c27794ca5338cda64cc9282dadfed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ac31c27794ca5338cda64cc9282dadfed">ipLAST_MULTI_CAST_IPv4</a>&#160;&#160;&#160;0xF0000000UL</td></tr>
<tr class="memdesc:ac31c27794ca5338cda64cc9282dadfed"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#ac31c27794ca5338cda64cc9282dadfed">More...</a><br /></td></tr>
<tr class="separator:ac31c27794ca5338cda64cc9282dadfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599ef40bb9c6a811c74e16ae1a00fdf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a599ef40bb9c6a811c74e16ae1a00fdf2">ipIPV4_VERSION_HEADER_LENGTH_MIN</a>&#160;&#160;&#160;0x45U</td></tr>
<tr class="memdesc:a599ef40bb9c6a811c74e16ae1a00fdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a599ef40bb9c6a811c74e16ae1a00fdf2">More...</a><br /></td></tr>
<tr class="separator:a599ef40bb9c6a811c74e16ae1a00fdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e37d63f99e31d8af56e446b8ddd837"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#af3e37d63f99e31d8af56e446b8ddd837">ipIPV4_VERSION_HEADER_LENGTH_MAX</a>&#160;&#160;&#160;0x4FU</td></tr>
<tr class="memdesc:af3e37d63f99e31d8af56e446b8ddd837"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#af3e37d63f99e31d8af56e446b8ddd837">More...</a><br /></td></tr>
<tr class="separator:af3e37d63f99e31d8af56e446b8ddd837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982816b81c2c41e4e50643993a23085"><td class="memItemLeft" align="right" valign="top"><a id="af982816b81c2c41e4e50643993a23085" name="af982816b81c2c41e4e50643993a23085"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipINITIALISATION_RETRY_DELAY</b>&#160;&#160;&#160;( pdMS_TO_TICKS( 3000U ) )</td></tr>
<tr class="memdesc:af982816b81c2c41e4e50643993a23085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time delay between repeated attempts to initialise the network hardware. <br /></td></tr>
<tr class="separator:af982816b81c2c41e4e50643993a23085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4e7fc3c3cb2528f45fbff05a95c278"><td class="memItemLeft" align="right" valign="top"><a id="a7e4e7fc3c3cb2528f45fbff05a95c278" name="a7e4e7fc3c3cb2528f45fbff05a95c278"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipARP_TIMER_PERIOD_MS</b>&#160;&#160;&#160;( 10000U )</td></tr>
<tr class="memdesc:a7e4e7fc3c3cb2528f45fbff05a95c278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines how often the ARP timer callback function is executed. The time is shorter in the Windows simulator as simulated time is not real time. <br /></td></tr>
<tr class="separator:a7e4e7fc3c3cb2528f45fbff05a95c278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51b5f3c553cd23a5fd940017637737f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ac51b5f3c553cd23a5fd940017637737f">iptraceIP_TASK_STARTING</a>()&#160;&#160;&#160;do {} while( ipFALSE_BOOL )</td></tr>
<tr class="memdesc:ac51b5f3c553cd23a5fd940017637737f"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#ac51b5f3c553cd23a5fd940017637737f">More...</a><br /></td></tr>
<tr class="separator:ac51b5f3c553cd23a5fd940017637737f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1630538f6d0701a36f878b67bbff8f"><td class="memItemLeft" align="right" valign="top"><a id="aef1630538f6d0701a36f878b67bbff8f" name="aef1630538f6d0701a36f878b67bbff8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipTCP_TIMER_PERIOD_MS</b>&#160;&#160;&#160;( 1000U )</td></tr>
<tr class="memdesc:aef1630538f6d0701a36f878b67bbff8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When initialising the TCP timer, give it an initial time-out of 1 second. <br /></td></tr>
<tr class="separator:aef1630538f6d0701a36f878b67bbff8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615aa656020ebf93f31e4ccbd47a880d"><td class="memItemLeft" align="right" valign="top"><a id="a615aa656020ebf93f31e4ccbd47a880d" name="a615aa656020ebf93f31e4ccbd47a880d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipCONSIDER_FRAME_FOR_PROCESSING</b>(pucEthernetBuffer)&#160;&#160;&#160;<a class="el" href="_free_r_t_o_s___i_p_8c.html#ab15bee3df12f185ea7a1ba671121d19f">eConsiderFrameForProcessing</a>( ( pucEthernetBuffer ) )</td></tr>
<tr class="memdesc:a615aa656020ebf93f31e4ccbd47a880d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If ipconfigETHERNET_DRIVER_FILTERS_FRAME_TYPES is set to 1, then the Ethernet driver will filter incoming packets and only pass the stack those packets it considers need processing. In this case <a class="el" href="_free_r_t_o_s___i_p_8c.html#a615aa656020ebf93f31e4ccbd47a880d" title="If ipconfigETHERNET_DRIVER_FILTERS_FRAME_TYPES is set to 1, then the Ethernet driver will filter inco...">ipCONSIDER_FRAME_FOR_PROCESSING()</a> can be #-defined away. If ipconfigETHERNET_DRIVER_FILTERS_FRAME_TYPES is set to 0 then the Ethernet driver will pass all received packets to the stack, and the stack must do the filtering itself. In this case ipCONSIDER_FRAME_FOR_PROCESSING needs to call eConsiderFrameForProcessing. <br /></td></tr>
<tr class="separator:a615aa656020ebf93f31e4ccbd47a880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47f6670e30fff23d3f497bf36987eca"><td class="memItemLeft" align="right" valign="top"><a id="ac47f6670e30fff23d3f497bf36987eca" name="ac47f6670e30fff23d3f497bf36987eca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipFRAGMENT_OFFSET_BIT_MASK</b>&#160;&#160;&#160;( ( uint16_t ) 0xff0f )</td></tr>
<tr class="memdesc:ac47f6670e30fff23d3f497bf36987eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bits in the two byte IP header field that make up the fragment offset value. <br /></td></tr>
<tr class="separator:ac47f6670e30fff23d3f497bf36987eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7b582c7eacfa1a6448433f019cad23"><td class="memItemLeft" align="right" valign="top"><a id="aba7b582c7eacfa1a6448433f019cad23" name="aba7b582c7eacfa1a6448433f019cad23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipconfigMAX_IP_TASK_SLEEP_TIME</b>&#160;&#160;&#160;( pdMS_TO_TICKS( 10000UL ) )</td></tr>
<tr class="memdesc:aba7b582c7eacfa1a6448433f019cad23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum time the IP task is allowed to remain in the Blocked state if no events are posted to the network event queue. <br /></td></tr>
<tr class="separator:aba7b582c7eacfa1a6448433f019cad23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61c957eee4cfdb4853c29cfef224e33"><td class="memItemLeft" align="right" valign="top"><a id="aa61c957eee4cfdb4853c29cfef224e33" name="aa61c957eee4cfdb4853c29cfef224e33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipUNHANDLED_PROTOCOL</b>&#160;&#160;&#160;0x4321U</td></tr>
<tr class="memdesc:aa61c957eee4cfdb4853c29cfef224e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned as the (invalid) checksum when the protocol being checked is not handled. The value is chosen simply to be easy to spot when debugging. <br /></td></tr>
<tr class="separator:aa61c957eee4cfdb4853c29cfef224e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde58aa20087aac4f57fbe82401f39b8"><td class="memItemLeft" align="right" valign="top"><a id="afde58aa20087aac4f57fbe82401f39b8" name="afde58aa20087aac4f57fbe82401f39b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipCORRECT_CRC</b>&#160;&#160;&#160;0xffffU</td></tr>
<tr class="memdesc:afde58aa20087aac4f57fbe82401f39b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned to indicate a valid checksum. <br /></td></tr>
<tr class="separator:afde58aa20087aac4f57fbe82401f39b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2652c0fbddea6f0fe507d8d28e8816f"><td class="memItemLeft" align="right" valign="top"><a id="ad2652c0fbddea6f0fe507d8d28e8816f" name="ad2652c0fbddea6f0fe507d8d28e8816f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipWRONG_CRC</b>&#160;&#160;&#160;0x0000U</td></tr>
<tr class="memdesc:ad2652c0fbddea6f0fe507d8d28e8816f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned to indicate incorrect checksum. <br /></td></tr>
<tr class="separator:ad2652c0fbddea6f0fe507d8d28e8816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e1d2184955efc68fe033a6ffdc44f4"><td class="memItemLeft" align="right" valign="top"><a id="a21e1d2184955efc68fe033a6ffdc44f4" name="a21e1d2184955efc68fe033a6ffdc44f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipINVALID_LENGTH</b>&#160;&#160;&#160;0x1234U</td></tr>
<tr class="memdesc:a21e1d2184955efc68fe033a6ffdc44f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned as the (invalid) checksum when the length of the data being checked had an invalid length. <br /></td></tr>
<tr class="separator:a21e1d2184955efc68fe033a6ffdc44f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167d6d53f49e298310e581dbdf4128de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a167d6d53f49e298310e581dbdf4128de">DEBUG_DECLARE_TRACE_VARIABLE</a>(type,  var,  init)</td></tr>
<tr class="memdesc:a167d6d53f49e298310e581dbdf4128de"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a167d6d53f49e298310e581dbdf4128de">More...</a><br /></td></tr>
<tr class="separator:a167d6d53f49e298310e581dbdf4128de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e73738efbee764aa5e89b9d6445410e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a9e73738efbee764aa5e89b9d6445410e">DEBUG_SET_TRACE_VARIABLE</a>(var,  value)</td></tr>
<tr class="memdesc:a9e73738efbee764aa5e89b9d6445410e"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___i_p_8c.html#a9e73738efbee764aa5e89b9d6445410e">More...</a><br /></td></tr>
<tr class="separator:a9e73738efbee764aa5e89b9d6445410e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a52fc9e0117c61a8d8e0895e01552250e"><td class="memItemLeft" align="right" valign="top">static portINLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a52fc9e0117c61a8d8e0895e01552250e">ipDECL_CAST_PTR_FUNC_FOR_TYPE</a> (<a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a>)</td></tr>
<tr class="memdesc:a52fc9e0117c61a8d8e0895e01552250e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to cast pointer of a type to pointer of type <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a>.  <a href="_free_r_t_o_s___i_p_8c.html#a52fc9e0117c61a8d8e0895e01552250e">More...</a><br /></td></tr>
<tr class="separator:a52fc9e0117c61a8d8e0895e01552250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a02bc45b29f74e5f48bd71bca5c1b61"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a4a02bc45b29f74e5f48bd71bca5c1b61">prvIPTask</a> (void *pvParameters)</td></tr>
<tr class="memdesc:a4a02bc45b29f74e5f48bd71bca5c1b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IP task handles all requests from the user application and the network interface. It receives messages through a FreeRTOS queue called 'xNetworkEventQueue'. <a class="el" href="_free_r_t_o_s___i_p_8c.html#a4a02bc45b29f74e5f48bd71bca5c1b61" title="The IP task handles all requests from the user application and the network interface....">prvIPTask()</a> is the only task which has access to the data of the IP-stack, and so it has no need of using mutexes.  <a href="_free_r_t_o_s___i_p_8c.html#a4a02bc45b29f74e5f48bd71bca5c1b61">More...</a><br /></td></tr>
<tr class="separator:a4a02bc45b29f74e5f48bd71bca5c1b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd5bae218c03d5d539d8f2fa8148a87"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#abbd5bae218c03d5d539d8f2fa8148a87">prvProcessEthernetPacket</a> (<a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *const pxNetworkBuffer)</td></tr>
<tr class="memdesc:abbd5bae218c03d5d539d8f2fa8148a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the Ethernet packet.  <a href="_free_r_t_o_s___i_p_8c.html#abbd5bae218c03d5d539d8f2fa8148a87">More...</a><br /></td></tr>
<tr class="separator:abbd5bae218c03d5d539d8f2fa8148a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff2a58fc92561f47bdd9c45f20cf4f9"><td class="memItemLeft" align="right" valign="top">static eFrameProcessingResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a0ff2a58fc92561f47bdd9c45f20cf4f9">prvProcessIPPacket</a> (IPPacket_t *pxIPPacket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *const pxNetworkBuffer)</td></tr>
<tr class="memdesc:a0ff2a58fc92561f47bdd9c45f20cf4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an IP-packet.  <a href="_free_r_t_o_s___i_p_8c.html#a0ff2a58fc92561f47bdd9c45f20cf4f9">More...</a><br /></td></tr>
<tr class="separator:a0ff2a58fc92561f47bdd9c45f20cf4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20b2833c8912039201c1baf2f25a8f6"><td class="memItemLeft" align="right" valign="top"><a id="ac20b2833c8912039201c1baf2f25a8f6" name="ac20b2833c8912039201c1baf2f25a8f6"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>prvProcessNetworkDownEvent</b> (void)</td></tr>
<tr class="memdesc:ac20b2833c8912039201c1baf2f25a8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a 'Network down' event and complete required processing. <br /></td></tr>
<tr class="separator:ac20b2833c8912039201c1baf2f25a8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ce8d5c2384dfac1c01fd0a63d87581"><td class="memItemLeft" align="right" valign="top"><a id="af5ce8d5c2384dfac1c01fd0a63d87581" name="af5ce8d5c2384dfac1c01fd0a63d87581"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>prvCheckNetworkTimers</b> (void)</td></tr>
<tr class="memdesc:af5ce8d5c2384dfac1c01fd0a63d87581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the network timers (ARP/DHCP/DNS/TCP) and if they are expired, send an event to the IP-Task. <br /></td></tr>
<tr class="separator:af5ce8d5c2384dfac1c01fd0a63d87581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2c5b32a896922e43d1183953922815"><td class="memItemLeft" align="right" valign="top">static TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#aeb2c5b32a896922e43d1183953922815">prvCalculateSleepTime</a> (void)</td></tr>
<tr class="memdesc:aeb2c5b32a896922e43d1183953922815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the maximum sleep time remaining. It will go through all timers to see which timer will expire first. That will be the amount of time to block in the next call to xQueueReceive().  <a href="_free_r_t_o_s___i_p_8c.html#aeb2c5b32a896922e43d1183953922815">More...</a><br /></td></tr>
<tr class="separator:aeb2c5b32a896922e43d1183953922815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5b9dd29ac8f3830bc4b1531b10228a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a9d5b9dd29ac8f3830bc4b1531b10228a">prvHandleEthernetPacket</a> (<a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxBuffer)</td></tr>
<tr class="memdesc:a9d5b9dd29ac8f3830bc4b1531b10228a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the incoming Ethernet packets.  <a href="_free_r_t_o_s___i_p_8c.html#a9d5b9dd29ac8f3830bc4b1531b10228a">More...</a><br /></td></tr>
<tr class="separator:a9d5b9dd29ac8f3830bc4b1531b10228a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbcca14e07b67e72962278309dd8d07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a6bbcca14e07b67e72962278309dd8d07">prvIPTimerStart</a> (<a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a> *pxTimer, TickType_t xTime)</td></tr>
<tr class="memdesc:a6bbcca14e07b67e72962278309dd8d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an IP timer. The IP-task has its own implementation of a timer called '<a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a>', which is based on the FreeRTOS 'TimeOut_t'.  <a href="_free_r_t_o_s___i_p_8c.html#a6bbcca14e07b67e72962278309dd8d07">More...</a><br /></td></tr>
<tr class="separator:a6bbcca14e07b67e72962278309dd8d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a2e3f4cbb0aee222276cfbae2b1590"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ad2a2e3f4cbb0aee222276cfbae2b1590">prvIPTimerCheck</a> (<a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a> *pxTimer)</td></tr>
<tr class="memdesc:ad2a2e3f4cbb0aee222276cfbae2b1590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the IP timer to see whether an IP event should be processed or not.  <a href="_free_r_t_o_s___i_p_8c.html#ad2a2e3f4cbb0aee222276cfbae2b1590">More...</a><br /></td></tr>
<tr class="separator:ad2a2e3f4cbb0aee222276cfbae2b1590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25d502fab7e4af29bc9b30dffc75ccf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ae25d502fab7e4af29bc9b30dffc75ccf">prvIPTimerReload</a> (<a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a> *pxTimer, TickType_t xTime)</td></tr>
<tr class="memdesc:ae25d502fab7e4af29bc9b30dffc75ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reload time of an IP timer and restarts it.  <a href="_free_r_t_o_s___i_p_8c.html#ae25d502fab7e4af29bc9b30dffc75ccf">More...</a><br /></td></tr>
<tr class="separator:ae25d502fab7e4af29bc9b30dffc75ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84cb5865863076c9fd79c75c442bcb"><td class="memItemLeft" align="right" valign="top">static eFrameProcessingResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a0a84cb5865863076c9fd79c75c442bcb">prvAllowIPPacket</a> (const IPPacket_t *const pxIPPacket, const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *const pxNetworkBuffer, UBaseType_t uxHeaderLength)</td></tr>
<tr class="memdesc:a0a84cb5865863076c9fd79c75c442bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this IP packet is to be allowed or to be dropped.  <a href="_free_r_t_o_s___i_p_8c.html#a0a84cb5865863076c9fd79c75c442bcb">More...</a><br /></td></tr>
<tr class="separator:a0a84cb5865863076c9fd79c75c442bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb009e3856db87301868748c1732f74d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#afb009e3856db87301868748c1732f74d">prvPacketBuffer_to_NetworkBuffer</a> (const void *pvBuffer, size_t uxOffset)</td></tr>
<tr class="memdesc:afb009e3856db87301868748c1732f74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the network buffer descriptor from the packet buffer.  <a href="_free_r_t_o_s___i_p_8c.html#afb009e3856db87301868748c1732f74d">More...</a><br /></td></tr>
<tr class="separator:afb009e3856db87301868748c1732f74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9844166e6474d5f406df1c57aa4da98f"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a9844166e6474d5f406df1c57aa4da98f">xIsCallingFromIPTask</a> (void)</td></tr>
<tr class="memdesc:a9844166e6474d5f406df1c57aa4da98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check whether the current context belongs to the IP-task.  <a href="_free_r_t_o_s___i_p_8c.html#a9844166e6474d5f406df1c57aa4da98f">More...</a><br /></td></tr>
<tr class="separator:a9844166e6474d5f406df1c57aa4da98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c7afd343400f1ec8b01cde2f1a8f2e"><td class="memItemLeft" align="right" valign="top"><a id="aa2c7afd343400f1ec8b01cde2f1a8f2e" name="aa2c7afd343400f1ec8b01cde2f1a8f2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FreeRTOS_NetworkDown</b> (void)</td></tr>
<tr class="memdesc:aa2c7afd343400f1ec8b01cde2f1a8f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a network down event to the IP-task. If it fails to post a message, the failure will be noted in the variable 'xNetworkDownEventPending' and later on a 'network-down' event, it will be executed. <br /></td></tr>
<tr class="separator:aa2c7afd343400f1ec8b01cde2f1a8f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb922d3358a892833f3a4383f7c9c552"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#adb922d3358a892833f3a4383f7c9c552">FreeRTOS_NetworkDownFromISR</a> (void)</td></tr>
<tr class="memdesc:adb922d3358a892833f3a4383f7c9c552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function. Process Network Down event from ISR. This function is supposed to be called form an ISR. It is recommended.  <a href="_free_r_t_o_s___i_p_8c.html#adb922d3358a892833f3a4383f7c9c552">More...</a><br /></td></tr>
<tr class="separator:adb922d3358a892833f3a4383f7c9c552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca554a4fa9d8738e5423e3a2912bf340"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#aca554a4fa9d8738e5423e3a2912bf340">FreeRTOS_GetUDPPayloadBuffer</a> (size_t uxRequestedSizeBytes, TickType_t uxBlockTimeTicks)</td></tr>
<tr class="memdesc:aca554a4fa9d8738e5423e3a2912bf340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a buffer big enough for a UDP payload of given size.  <a href="_free_r_t_o_s___i_p_8c.html#aca554a4fa9d8738e5423e3a2912bf340">More...</a><br /></td></tr>
<tr class="separator:aca554a4fa9d8738e5423e3a2912bf340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad104b025d007fc96fbc8d7192c019c2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ad104b025d007fc96fbc8d7192c019c2b">pxDuplicateNetworkBufferWithDescriptor</a> (const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *const pxNetworkBuffer, size_t uxNewLength)</td></tr>
<tr class="memdesc:ad104b025d007fc96fbc8d7192c019c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the given network buffer descriptor with a modified length.  <a href="_free_r_t_o_s___i_p_8c.html#ad104b025d007fc96fbc8d7192c019c2b">More...</a><br /></td></tr>
<tr class="separator:ad104b025d007fc96fbc8d7192c019c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b905aeed098b75f34aa8bf80ea22d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a75b905aeed098b75f34aa8bf80ea22d5">pxUDPPayloadBuffer_to_NetworkBuffer</a> (const void *pvBuffer)</td></tr>
<tr class="memdesc:a75b905aeed098b75f34aa8bf80ea22d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the network buffer from the UDP Payload buffer.  <a href="_free_r_t_o_s___i_p_8c.html#a75b905aeed098b75f34aa8bf80ea22d5">More...</a><br /></td></tr>
<tr class="separator:a75b905aeed098b75f34aa8bf80ea22d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9acf473a4cda3f58dde4180091464ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ab9acf473a4cda3f58dde4180091464ed">FreeRTOS_ReleaseUDPPayloadBuffer</a> (void const *pvBuffer)</td></tr>
<tr class="memdesc:ab9acf473a4cda3f58dde4180091464ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the UDP payload buffer.  <a href="_free_r_t_o_s___i_p_8c.html#ab9acf473a4cda3f58dde4180091464ed">More...</a><br /></td></tr>
<tr class="separator:ab9acf473a4cda3f58dde4180091464ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a03616eca530b4ac3ab7d05ff4cc51"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ae5a03616eca530b4ac3ab7d05ff4cc51">FreeRTOS_IPInit</a> (const uint8_t ucIPAddress[ipIP_ADDRESS_LENGTH_BYTES], const uint8_t ucNetMask[ipIP_ADDRESS_LENGTH_BYTES], const uint8_t ucGatewayAddress[ipIP_ADDRESS_LENGTH_BYTES], const uint8_t ucDNSServerAddress[ipIP_ADDRESS_LENGTH_BYTES], const uint8_t ucMACAddress[ipMAC_ADDRESS_LENGTH_BYTES])</td></tr>
<tr class="memdesc:ae5a03616eca530b4ac3ab7d05ff4cc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the FreeRTOS-Plus-TCP network stack and initialise the IP-task.  <a href="_free_r_t_o_s___i_p_8c.html#ae5a03616eca530b4ac3ab7d05ff4cc51">More...</a><br /></td></tr>
<tr class="separator:ae5a03616eca530b4ac3ab7d05ff4cc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad802acf10146e09bb75437c6fef04632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ad802acf10146e09bb75437c6fef04632">FreeRTOS_GetAddressConfiguration</a> (uint32_t *pulIPAddress, uint32_t *pulNetMask, uint32_t *pulGatewayAddress, uint32_t *pulDNSServerAddress)</td></tr>
<tr class="memdesc:ad802acf10146e09bb75437c6fef04632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current address configuration. Only non-NULL pointers will be filled in.  <a href="_free_r_t_o_s___i_p_8c.html#ad802acf10146e09bb75437c6fef04632">More...</a><br /></td></tr>
<tr class="separator:ad802acf10146e09bb75437c6fef04632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cb4b8b79208cca6a95244620ec45c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a17cb4b8b79208cca6a95244620ec45c5">FreeRTOS_SetAddressConfiguration</a> (const uint32_t *pulIPAddress, const uint32_t *pulNetMask, const uint32_t *pulGatewayAddress, const uint32_t *pulDNSServerAddress)</td></tr>
<tr class="memdesc:a17cb4b8b79208cca6a95244620ec45c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current network address configuration. Only non-NULL pointers will be used.  <a href="_free_r_t_o_s___i_p_8c.html#a17cb4b8b79208cca6a95244620ec45c5">More...</a><br /></td></tr>
<tr class="separator:a17cb4b8b79208cca6a95244620ec45c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64324b01a1fc85efdb7129316e8f7737"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a64324b01a1fc85efdb7129316e8f7737">xSendEventToIPTask</a> (eIPEvent_t eEvent)</td></tr>
<tr class="memdesc:a64324b01a1fc85efdb7129316e8f7737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event to the IP task. It calls 'xSendEventStructToIPTask' internally.  <a href="_free_r_t_o_s___i_p_8c.html#a64324b01a1fc85efdb7129316e8f7737">More...</a><br /></td></tr>
<tr class="separator:a64324b01a1fc85efdb7129316e8f7737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7190bc18fa344fe1fd79021a6db05f84"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a7190bc18fa344fe1fd79021a6db05f84">xSendEventStructToIPTask</a> (const <a class="el" href="struct_i_p_stack_event__t.html">IPStackEvent_t</a> *pxEvent, TickType_t uxTimeout)</td></tr>
<tr class="memdesc:a7190bc18fa344fe1fd79021a6db05f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event (in form of struct) to the IP task to be processed.  <a href="_free_r_t_o_s___i_p_8c.html#a7190bc18fa344fe1fd79021a6db05f84">More...</a><br /></td></tr>
<tr class="separator:a7190bc18fa344fe1fd79021a6db05f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edea1d81a89bc1838f51f6699982740"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a9edea1d81a89bc1838f51f6699982740">xSendDHCPEvent</a> (void)</td></tr>
<tr class="memdesc:a9edea1d81a89bc1838f51f6699982740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DHCP event.  <a href="_free_r_t_o_s___i_p_8c.html#a9edea1d81a89bc1838f51f6699982740">More...</a><br /></td></tr>
<tr class="separator:a9edea1d81a89bc1838f51f6699982740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15bee3df12f185ea7a1ba671121d19f"><td class="memItemLeft" align="right" valign="top">eFrameProcessingResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ab15bee3df12f185ea7a1ba671121d19f">eConsiderFrameForProcessing</a> (const uint8_t *const pucEthernetBuffer)</td></tr>
<tr class="memdesc:ab15bee3df12f185ea7a1ba671121d19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether this packet should be processed or not based on the IP address in the packet.  <a href="_free_r_t_o_s___i_p_8c.html#ab15bee3df12f185ea7a1ba671121d19f">More...</a><br /></td></tr>
<tr class="separator:ab15bee3df12f185ea7a1ba671121d19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd469315acbf173d5cc16168721a17fb"><td class="memItemLeft" align="right" valign="top"><a id="abd469315acbf173d5cc16168721a17fb" name="abd469315acbf173d5cc16168721a17fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vIPNetworkUpCalls</b> (void)</td></tr>
<tr class="memdesc:abd469315acbf173d5cc16168721a17fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform all the required tasks when the network gets connected. <br /></td></tr>
<tr class="separator:abd469315acbf173d5cc16168721a17fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c787bfa6502ecfd173ee8f6974e8628"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a3c787bfa6502ecfd173ee8f6974e8628">xIsIPv4Multicast</a> (uint32_t ulIPAddress)</td></tr>
<tr class="memdesc:a3c787bfa6502ecfd173ee8f6974e8628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the IP address an IPv4 multicast address.  <a href="_free_r_t_o_s___i_p_8c.html#a3c787bfa6502ecfd173ee8f6974e8628">More...</a><br /></td></tr>
<tr class="separator:a3c787bfa6502ecfd173ee8f6974e8628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af110bcf8c7910fc9149a4a09895efcf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#af110bcf8c7910fc9149a4a09895efcf4">vSetMultiCastIPv4MacAddress</a> (uint32_t ulIPAddress, MACAddress_t *pxMACAddress)</td></tr>
<tr class="memdesc:af110bcf8c7910fc9149a4a09895efcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multicast MAC address.  <a href="_free_r_t_o_s___i_p_8c.html#af110bcf8c7910fc9149a4a09895efcf4">More...</a><br /></td></tr>
<tr class="separator:af110bcf8c7910fc9149a4a09895efcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4d89d0e834cef68e0746e0404f319d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#aad4d89d0e834cef68e0746e0404f319d">usGenerateProtocolChecksum</a> (const uint8_t *const pucEthernetBuffer, size_t uxBufferLength, BaseType_t xOutgoingPacket)</td></tr>
<tr class="memdesc:aad4d89d0e834cef68e0746e0404f319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate or check the protocol checksum of the data sent in the first parameter. At the same time, the length of the packet and the length of the different layers will be checked.  <a href="_free_r_t_o_s___i_p_8c.html#aad4d89d0e834cef68e0746e0404f319d">More...</a><br /></td></tr>
<tr class="separator:aad4d89d0e834cef68e0746e0404f319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97162cfd5b071ccee8fec503879a3e43"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a97162cfd5b071ccee8fec503879a3e43">usGenerateChecksum</a> (uint16_t usSum, const uint8_t *pucNextData, size_t uxByteCount)</td></tr>
<tr class="memdesc:a97162cfd5b071ccee8fec503879a3e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the 16-bit checksum of an array of bytes.  <a href="_free_r_t_o_s___i_p_8c.html#a97162cfd5b071ccee8fec503879a3e43">More...</a><br /></td></tr>
<tr class="separator:a97162cfd5b071ccee8fec503879a3e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb218e96c829c263a677428fe4d5d24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a5fb218e96c829c263a677428fe4d5d24">vReturnEthernetFrame</a> (<a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer, BaseType_t xReleaseAfterSend)</td></tr>
<tr class="memdesc:a5fb218e96c829c263a677428fe4d5d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the Ethernet frame after checking for some conditions.  <a href="_free_r_t_o_s___i_p_8c.html#a5fb218e96c829c263a677428fe4d5d24">More...</a><br /></td></tr>
<tr class="separator:a5fb218e96c829c263a677428fe4d5d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf07062b415dab09f3e333134b97103"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#aeaf07062b415dab09f3e333134b97103">FreeRTOS_GetIPAddress</a> (void)</td></tr>
<tr class="memdesc:aeaf07062b415dab09f3e333134b97103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IP address of the NIC.  <a href="_free_r_t_o_s___i_p_8c.html#aeaf07062b415dab09f3e333134b97103">More...</a><br /></td></tr>
<tr class="separator:aeaf07062b415dab09f3e333134b97103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f06ef42d1ac00f4ede5a68962a1502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a99f06ef42d1ac00f4ede5a68962a1502">FreeRTOS_SetIPAddress</a> (uint32_t ulIPAddress)</td></tr>
<tr class="memdesc:a99f06ef42d1ac00f4ede5a68962a1502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IP address of the NIC.  <a href="_free_r_t_o_s___i_p_8c.html#a99f06ef42d1ac00f4ede5a68962a1502">More...</a><br /></td></tr>
<tr class="separator:a99f06ef42d1ac00f4ede5a68962a1502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9033775f90dafde04eaa8236ca36c7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a6a9033775f90dafde04eaa8236ca36c7">FreeRTOS_GetGatewayAddress</a> (void)</td></tr>
<tr class="memdesc:a6a9033775f90dafde04eaa8236ca36c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gateway address of the subnet.  <a href="_free_r_t_o_s___i_p_8c.html#a6a9033775f90dafde04eaa8236ca36c7">More...</a><br /></td></tr>
<tr class="separator:a6a9033775f90dafde04eaa8236ca36c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0445e00d7886a94e4b39ec47a7e96964"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a0445e00d7886a94e4b39ec47a7e96964">FreeRTOS_GetDNSServerAddress</a> (void)</td></tr>
<tr class="memdesc:a0445e00d7886a94e4b39ec47a7e96964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the DNS server address.  <a href="_free_r_t_o_s___i_p_8c.html#a0445e00d7886a94e4b39ec47a7e96964">More...</a><br /></td></tr>
<tr class="separator:a0445e00d7886a94e4b39ec47a7e96964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94f1e03ad9facdc02d68063f7ba3101"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ac94f1e03ad9facdc02d68063f7ba3101">FreeRTOS_GetNetmask</a> (void)</td></tr>
<tr class="memdesc:ac94f1e03ad9facdc02d68063f7ba3101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the netmask for the subnet.  <a href="_free_r_t_o_s___i_p_8c.html#ac94f1e03ad9facdc02d68063f7ba3101">More...</a><br /></td></tr>
<tr class="separator:ac94f1e03ad9facdc02d68063f7ba3101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d5550342028837be656fbf35cae815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#af4d5550342028837be656fbf35cae815">FreeRTOS_UpdateMACAddress</a> (const uint8_t ucMACAddress[ipMAC_ADDRESS_LENGTH_BYTES])</td></tr>
<tr class="memdesc:af4d5550342028837be656fbf35cae815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the MAC address.  <a href="_free_r_t_o_s___i_p_8c.html#af4d5550342028837be656fbf35cae815">More...</a><br /></td></tr>
<tr class="separator:af4d5550342028837be656fbf35cae815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5245023fe8eda88775545c90d39c7763"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a5245023fe8eda88775545c90d39c7763">FreeRTOS_GetMACAddress</a> (void)</td></tr>
<tr class="memdesc:a5245023fe8eda88775545c90d39c7763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MAC address.  <a href="_free_r_t_o_s___i_p_8c.html#a5245023fe8eda88775545c90d39c7763">More...</a><br /></td></tr>
<tr class="separator:a5245023fe8eda88775545c90d39c7763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b7f10a7f753fc50ea2bf7712dbcd5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a69b7f10a7f753fc50ea2bf7712dbcd5b">FreeRTOS_SetNetmask</a> (uint32_t ulNetmask)</td></tr>
<tr class="memdesc:a69b7f10a7f753fc50ea2bf7712dbcd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the netmask for the subnet.  <a href="_free_r_t_o_s___i_p_8c.html#a69b7f10a7f753fc50ea2bf7712dbcd5b">More...</a><br /></td></tr>
<tr class="separator:a69b7f10a7f753fc50ea2bf7712dbcd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3329850735ce894baeef8fbac70be579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a3329850735ce894baeef8fbac70be579">FreeRTOS_SetGatewayAddress</a> (uint32_t ulGatewayAddress)</td></tr>
<tr class="memdesc:a3329850735ce894baeef8fbac70be579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the gateway address.  <a href="_free_r_t_o_s___i_p_8c.html#a3329850735ce894baeef8fbac70be579">More...</a><br /></td></tr>
<tr class="separator:a3329850735ce894baeef8fbac70be579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f26bbec48d40bb077621b734adddc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ab4f26bbec48d40bb077621b734adddc8">vIPSetDHCPTimerEnableState</a> (BaseType_t xEnableState)</td></tr>
<tr class="memdesc:ab4f26bbec48d40bb077621b734adddc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable the DHCP timer.  <a href="_free_r_t_o_s___i_p_8c.html#ab4f26bbec48d40bb077621b734adddc8">More...</a><br /></td></tr>
<tr class="separator:ab4f26bbec48d40bb077621b734adddc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880467f5ff22e0154bf8124fa437ea8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a880467f5ff22e0154bf8124fa437ea8e">vIPReloadDHCPTimer</a> (uint32_t ulLeaseTime)</td></tr>
<tr class="memdesc:a880467f5ff22e0154bf8124fa437ea8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload the DHCP timer.  <a href="_free_r_t_o_s___i_p_8c.html#a880467f5ff22e0154bf8124fa437ea8e">More...</a><br /></td></tr>
<tr class="separator:a880467f5ff22e0154bf8124fa437ea8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575576b2fe366f64e201c7cef093f454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a575576b2fe366f64e201c7cef093f454">vIPSetDnsTimerEnableState</a> (BaseType_t xEnableState)</td></tr>
<tr class="memdesc:a575576b2fe366f64e201c7cef093f454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable the DNS timer.  <a href="_free_r_t_o_s___i_p_8c.html#a575576b2fe366f64e201c7cef093f454">More...</a><br /></td></tr>
<tr class="separator:a575576b2fe366f64e201c7cef093f454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d1e820182a6f16577d5f36cd2e0819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ab6d1e820182a6f16577d5f36cd2e0819">vIPReloadDNSTimer</a> (uint32_t ulCheckTime)</td></tr>
<tr class="memdesc:ab6d1e820182a6f16577d5f36cd2e0819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload the DNS timer.  <a href="_free_r_t_o_s___i_p_8c.html#ab6d1e820182a6f16577d5f36cd2e0819">More...</a><br /></td></tr>
<tr class="separator:ab6d1e820182a6f16577d5f36cd2e0819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b2222c2b48904fb90674927a2c489d"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a52b2222c2b48904fb90674927a2c489d">xIPIsNetworkTaskReady</a> (void)</td></tr>
<tr class="memdesc:a52b2222c2b48904fb90674927a2c489d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the IP task is ready.  <a href="_free_r_t_o_s___i_p_8c.html#a52b2222c2b48904fb90674927a2c489d">More...</a><br /></td></tr>
<tr class="separator:a52b2222c2b48904fb90674927a2c489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f02ee6cc4e8f633ed3ddbc3d01e943"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#ac1f02ee6cc4e8f633ed3ddbc3d01e943">FreeRTOS_IsNetworkUp</a> (void)</td></tr>
<tr class="memdesc:ac1f02ee6cc4e8f633ed3ddbc3d01e943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this node is connected to network or not.  <a href="_free_r_t_o_s___i_p_8c.html#ac1f02ee6cc4e8f633ed3ddbc3d01e943">More...</a><br /></td></tr>
<tr class="separator:ac1f02ee6cc4e8f633ed3ddbc3d01e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738b12572023fadb0e5ed3c3204a2ccb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p_8c.html#a738b12572023fadb0e5ed3c3204a2ccb">FreeRTOS_strerror_r</a> (BaseType_t xErrnum, char *pcBuffer, size_t uxLength)</td></tr>
<tr class="memdesc:a738b12572023fadb0e5ed3c3204a2ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function: Convert error number to a human readable string. Declaration in <a class="el" href="_free_r_t_o_s__errno___t_c_p_8h_source.html">FreeRTOS_errno_TCP.h</a>.  <a href="_free_r_t_o_s___i_p_8c.html#a738b12572023fadb0e5ed3c3204a2ccb">More...</a><br /></td></tr>
<tr class="separator:a738b12572023fadb0e5ed3c3204a2ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7447ea310c26bfce949913de72f3d6f2"><td class="memItemLeft" align="right" valign="top"><a id="a7447ea310c26bfce949913de72f3d6f2" name="a7447ea310c26bfce949913de72f3d6f2"></a>
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>xNetworkEventQueue</b> = NULL</td></tr>
<tr class="memdesc:a7447ea310c26bfce949913de72f3d6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The queue used to pass events into the IP-task for processing. <br /></td></tr>
<tr class="separator:a7447ea310c26bfce949913de72f3d6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292a9f76f680f80f60d785e0c7bb20f0"><td class="memItemLeft" align="right" valign="top"><a id="a292a9f76f680f80f60d785e0c7bb20f0" name="a292a9f76f680f80f60d785e0c7bb20f0"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>usPacketIdentifier</b> = 0U</td></tr>
<tr class="memdesc:a292a9f76f680f80f60d785e0c7bb20f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IP packet ID. <br /></td></tr>
<tr class="separator:a292a9f76f680f80f60d785e0c7bb20f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eda95e8d4e0340cd07f7fd0e9637ec4"><td class="memItemLeft" align="right" valign="top"><a id="a4eda95e8d4e0340cd07f7fd0e9637ec4" name="a4eda95e8d4e0340cd07f7fd0e9637ec4"></a>
const MACAddress_t&#160;</td><td class="memItemRight" valign="bottom"><b>xBroadcastMACAddress</b> = { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } }</td></tr>
<tr class="memdesc:a4eda95e8d4e0340cd07f7fd0e9637ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For convenience, a MAC address of all 0xffs is defined const for quick reference. <br /></td></tr>
<tr class="separator:a4eda95e8d4e0340cd07f7fd0e9637ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af505b2f99bf8fc1c3b4d61cd5ecd21e0"><td class="memItemLeft" align="right" valign="top"><a id="af505b2f99bf8fc1c3b4d61cd5ecd21e0" name="af505b2f99bf8fc1c3b4d61cd5ecd21e0"></a>
<a class="el" href="struct_network_addressing_parameters__t.html">NetworkAddressingParameters_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>xNetworkAddressing</b> = { 0, 0, 0, 0, 0 }</td></tr>
<tr class="memdesc:af505b2f99bf8fc1c3b4d61cd5ecd21e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that stores the netmask, gateway address and DNS server addresses. <br /></td></tr>
<tr class="separator:af505b2f99bf8fc1c3b4d61cd5ecd21e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27de5a3f6e8a7b47b696604cb837c18"><td class="memItemLeft" align="right" valign="top"><a id="ab27de5a3f6e8a7b47b696604cb837c18" name="ab27de5a3f6e8a7b47b696604cb837c18"></a>
<a class="el" href="struct_network_addressing_parameters__t.html">NetworkAddressingParameters_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>xDefaultAddressing</b> = { 0, 0, 0, 0, 0 }</td></tr>
<tr class="memdesc:ab27de5a3f6e8a7b47b696604cb837c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default values for the above struct in case DHCP does not lead to a confirmed request. <br /></td></tr>
<tr class="separator:ab27de5a3f6e8a7b47b696604cb837c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0113c3af0709b245d34e7dec5df16119"><td class="memItemLeft" align="right" valign="top"><a id="a0113c3af0709b245d34e7dec5df16119" name="a0113c3af0709b245d34e7dec5df16119"></a>
static volatile BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><b>xNetworkDownEventPending</b> = pdFALSE</td></tr>
<tr class="memdesc:a0113c3af0709b245d34e7dec5df16119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to ensure network down events cannot be missed when they cannot be posted to the network event queue because the network event queue is already full. <br /></td></tr>
<tr class="separator:a0113c3af0709b245d34e7dec5df16119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45764b03f1eb0385c0cd08bc62394d4"><td class="memItemLeft" align="right" valign="top"><a id="ac45764b03f1eb0385c0cd08bc62394d4" name="ac45764b03f1eb0385c0cd08bc62394d4"></a>
static TaskHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>xIPTaskHandle</b> = NULL</td></tr>
<tr class="memdesc:ac45764b03f1eb0385c0cd08bc62394d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the handle of the task that handles the stack. The handle is used (indirectly) by some utility function to determine if the utility function is being called by a task (in which case it is ok to block) or by the IP task itself (in which case it is not ok to block). <br /></td></tr>
<tr class="separator:ac45764b03f1eb0385c0cd08bc62394d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ee87b297b5e8d2b71edb828b44c834"><td class="memItemLeft" align="right" valign="top"><a id="af2ee87b297b5e8d2b71edb828b44c834" name="af2ee87b297b5e8d2b71edb828b44c834"></a>
static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><b>xProcessedTCPMessage</b></td></tr>
<tr class="memdesc:af2ee87b297b5e8d2b71edb828b44c834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to a non-zero value if one or more TCP message have been processed within the last round. <br /></td></tr>
<tr class="separator:af2ee87b297b5e8d2b71edb828b44c834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6831050baaf1f467735e027fb77ba98e"><td class="memItemLeft" align="right" valign="top"><a id="a6831050baaf1f467735e027fb77ba98e" name="a6831050baaf1f467735e027fb77ba98e"></a>
static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><b>xNetworkUp</b> = pdFALSE</td></tr>
<tr class="memdesc:a6831050baaf1f467735e027fb77ba98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple set to pdTRUE or pdFALSE depending on whether the network is up or down (connected, not connected) respectively. <br /></td></tr>
<tr class="separator:a6831050baaf1f467735e027fb77ba98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847894eed20607f2865876d8d034d445"><td class="memItemLeft" align="right" valign="top"><a id="a847894eed20607f2865876d8d034d445" name="a847894eed20607f2865876d8d034d445"></a>
static <a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>xARPTimer</b></td></tr>
<tr class="memdesc:a847894eed20607f2865876d8d034d445"><td class="mdescLeft">&#160;</td><td class="mdescRight">ARP timer, to check its table entries. <br /></td></tr>
<tr class="separator:a847894eed20607f2865876d8d034d445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1400bc732b7f47d9e33033fcb35f907"><td class="memItemLeft" align="right" valign="top"><a id="af1400bc732b7f47d9e33033fcb35f907" name="af1400bc732b7f47d9e33033fcb35f907"></a>
static <a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>xDHCPTimer</b></td></tr>
<tr class="memdesc:af1400bc732b7f47d9e33033fcb35f907"><td class="mdescLeft">&#160;</td><td class="mdescRight">DHCP timer, to send requests and to renew a reservation. <br  />
 <br /></td></tr>
<tr class="separator:af1400bc732b7f47d9e33033fcb35f907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173c03d7a816518ad4d362a7c61088f6"><td class="memItemLeft" align="right" valign="top"><a id="a173c03d7a816518ad4d362a7c61088f6" name="a173c03d7a816518ad4d362a7c61088f6"></a>
static <a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>xTCPTimer</b></td></tr>
<tr class="memdesc:a173c03d7a816518ad4d362a7c61088f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP timer, to check for timeouts, resends. <br /></td></tr>
<tr class="separator:a173c03d7a816518ad4d362a7c61088f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457d35af454ec380c8e37f2c00ea8c49"><td class="memItemLeft" align="right" valign="top"><a id="a457d35af454ec380c8e37f2c00ea8c49" name="a457d35af454ec380c8e37f2c00ea8c49"></a>
static <a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>xDNSTimer</b></td></tr>
<tr class="memdesc:a457d35af454ec380c8e37f2c00ea8c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS timer, to check for timeouts when looking-up a domain. <br /></td></tr>
<tr class="separator:a457d35af454ec380c8e37f2c00ea8c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdfb0a695267908cfd8d1b792efaf13"><td class="memItemLeft" align="right" valign="top"><a id="a9fdfb0a695267908cfd8d1b792efaf13" name="a9fdfb0a695267908cfd8d1b792efaf13"></a>
static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><b>xIPTaskInitialised</b> = pdFALSE</td></tr>
<tr class="memdesc:a9fdfb0a695267908cfd8d1b792efaf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to pdTRUE when the IP task is ready to start processing packets. <br /></td></tr>
<tr class="separator:a9fdfb0a695267908cfd8d1b792efaf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implements the basic functionality for the FreeRTOS+TCP network stack. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8ef9c6533cd9f34111f6ff1e5843507d" name="a8ef9c6533cd9f34111f6ff1e5843507d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef9c6533cd9f34111f6ff1e5843507d">&#9670;&nbsp;</a></span>ipEXPECTED_EthernetHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_EthernetHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 14 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Ethernet Header size in bytes. </p>

</div>
</div>
<a id="ac13c9f74e9fe374fa459f8df1864dc72" name="ac13c9f74e9fe374fa459f8df1864dc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13c9f74e9fe374fa459f8df1864dc72">&#9670;&nbsp;</a></span>ipEXPECTED_ARPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_ARPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 28 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ARP header size in bytes. </p>

</div>
</div>
<a id="a43457a3ba4fd6f16a4d33394af459536" name="a43457a3ba4fd6f16a4d33394af459536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43457a3ba4fd6f16a4d33394af459536">&#9670;&nbsp;</a></span>ipEXPECTED_IPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_IPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 20 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >IP header size in bytes. </p>

</div>
</div>
<a id="a527470135bea5ef3d75f3c1206431584" name="a527470135bea5ef3d75f3c1206431584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527470135bea5ef3d75f3c1206431584">&#9670;&nbsp;</a></span>ipEXPECTED_IGMPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_IGMPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >IGMP header size in bytes. </p>

</div>
</div>
<a id="a0dc89907d7a25a7f795f2abcd9eb6aa6" name="a0dc89907d7a25a7f795f2abcd9eb6aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc89907d7a25a7f795f2abcd9eb6aa6">&#9670;&nbsp;</a></span>ipEXPECTED_ICMPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_ICMPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ICMP header size in bytes. </p>

</div>
</div>
<a id="a2cc551f421556711f0924201c04c9f82" name="a2cc551f421556711f0924201c04c9f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc551f421556711f0924201c04c9f82">&#9670;&nbsp;</a></span>ipEXPECTED_UDPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_UDPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >UDP header size in bytes. </p>

</div>
</div>
<a id="ada34cd2dcc842a6c43cd9c85acd0ebc2" name="ada34cd2dcc842a6c43cd9c85acd0ebc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada34cd2dcc842a6c43cd9c85acd0ebc2">&#9670;&nbsp;</a></span>ipEXPECTED_TCPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_TCPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 20 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >TCP header size in bytes. </p>

</div>
</div>
<a id="a576713b2b5c693d521be50e120d1d106" name="a576713b2b5c693d521be50e120d1d106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576713b2b5c693d521be50e120d1d106">&#9670;&nbsp;</a></span>ipICMP_ECHO_REQUEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipICMP_ECHO_REQUEST&#160;&#160;&#160;( ( uint8_t ) 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ICMP echo request. </p>

</div>
</div>
<a id="a20f4a6a59729b84b4f858c9e2532fa9f" name="a20f4a6a59729b84b4f858c9e2532fa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f4a6a59729b84b4f858c9e2532fa9f">&#9670;&nbsp;</a></span>ipICMP_ECHO_REPLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipICMP_ECHO_REPLY&#160;&#160;&#160;( ( uint8_t ) 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ICMP echo reply. </p>

</div>
</div>
<a id="a8d61855955d5d08f6933f84bc668d80f" name="a8d61855955d5d08f6933f84bc668d80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d61855955d5d08f6933f84bc668d80f">&#9670;&nbsp;</a></span>ipFIRST_MULTI_CAST_IPv4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipFIRST_MULTI_CAST_IPv4&#160;&#160;&#160;0xE0000000UL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Lower bound of the IPv4 multicast address. </p>

</div>
</div>
<a id="ac31c27794ca5338cda64cc9282dadfed" name="ac31c27794ca5338cda64cc9282dadfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31c27794ca5338cda64cc9282dadfed">&#9670;&nbsp;</a></span>ipLAST_MULTI_CAST_IPv4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipLAST_MULTI_CAST_IPv4&#160;&#160;&#160;0xF0000000UL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Higher bound of the IPv4 multicast address. </p>

</div>
</div>
<a id="a599ef40bb9c6a811c74e16ae1a00fdf2" name="a599ef40bb9c6a811c74e16ae1a00fdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599ef40bb9c6a811c74e16ae1a00fdf2">&#9670;&nbsp;</a></span>ipIPV4_VERSION_HEADER_LENGTH_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipIPV4_VERSION_HEADER_LENGTH_MIN&#160;&#160;&#160;0x45U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Minimum IPv4 header length. </p>

</div>
</div>
<a id="af3e37d63f99e31d8af56e446b8ddd837" name="af3e37d63f99e31d8af56e446b8ddd837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e37d63f99e31d8af56e446b8ddd837">&#9670;&nbsp;</a></span>ipIPV4_VERSION_HEADER_LENGTH_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipIPV4_VERSION_HEADER_LENGTH_MAX&#160;&#160;&#160;0x4FU</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Maximum IPv4 header length. </p>

</div>
</div>
<a id="ac51b5f3c553cd23a5fd940017637737f" name="ac51b5f3c553cd23a5fd940017637737f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51b5f3c553cd23a5fd940017637737f">&#9670;&nbsp;</a></span>iptraceIP_TASK_STARTING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define iptraceIP_TASK_STARTING</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;do {} while( ipFALSE_BOOL )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Empty definition in case iptraceIP_TASK_STARTING is not defined. </p>

</div>
</div>
<a id="a167d6d53f49e298310e581dbdf4128de" name="a167d6d53f49e298310e581dbdf4128de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167d6d53f49e298310e581dbdf4128de">&#9670;&nbsp;</a></span>DEBUG_DECLARE_TRACE_VARIABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_DECLARE_TRACE_VARIABLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">init&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Empty definition since ipconfigHAS_PRINTF != 1. </p>

</div>
</div>
<a id="a9e73738efbee764aa5e89b9d6445410e" name="a9e73738efbee764aa5e89b9d6445410e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e73738efbee764aa5e89b9d6445410e">&#9670;&nbsp;</a></span>DEBUG_SET_TRACE_VARIABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_SET_TRACE_VARIABLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Empty definition since ipconfigHAS_PRINTF != 1. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a52fc9e0117c61a8d8e0895e01552250e" name="a52fc9e0117c61a8d8e0895e01552250e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fc9e0117c61a8d8e0895e01552250e">&#9670;&nbsp;</a></span>ipDECL_CAST_PTR_FUNC_FOR_TYPE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static portINLINE ipDECL_CAST_PTR_FUNC_FOR_TYPE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to cast pointer of a type to pointer of type <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The casted pointer. </dd></dl>

</div>
</div>
<a id="a4a02bc45b29f74e5f48bd71bca5c1b61" name="a4a02bc45b29f74e5f48bd71bca5c1b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a02bc45b29f74e5f48bd71bca5c1b61">&#9670;&nbsp;</a></span>prvIPTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvIPTask </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvParameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The IP task handles all requests from the user application and the network interface. It receives messages through a FreeRTOS queue called 'xNetworkEventQueue'. <a class="el" href="_free_r_t_o_s___i_p_8c.html#a4a02bc45b29f74e5f48bd71bca5c1b61" title="The IP task handles all requests from the user application and the network interface....">prvIPTask()</a> is the only task which has access to the data of the IP-stack, and so it has no need of using mutexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvParameters</td><td>Not used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbd5bae218c03d5d539d8f2fa8148a87" name="abbd5bae218c03d5d539d8f2fa8148a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd5bae218c03d5d539d8f2fa8148a87">&#9670;&nbsp;</a></span>prvProcessEthernetPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvProcessEthernetPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *const&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the Ethernet packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pxNetworkBuffer</td><td>the network buffer containing the ethernet packet. If the buffer is large enough, it may be reused to send a reply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ff2a58fc92561f47bdd9c45f20cf4f9" name="a0ff2a58fc92561f47bdd9c45f20cf4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff2a58fc92561f47bdd9c45f20cf4f9">&#9670;&nbsp;</a></span>prvProcessIPPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static eFrameProcessingResult_t prvProcessIPPacket </td>
          <td>(</td>
          <td class="paramtype">IPPacket_t *&#160;</td>
          <td class="paramname"><em>pxIPPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *const&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process an IP-packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxIPPacket</td><td>The IP packet to be processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The networkbuffer descriptor having the IP packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum to show whether the packet should be released/kept/processed etc. </dd></dl>

</div>
</div>
<a id="aeb2c5b32a896922e43d1183953922815" name="aeb2c5b32a896922e43d1183953922815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2c5b32a896922e43d1183953922815">&#9670;&nbsp;</a></span>prvCalculateSleepTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TickType_t prvCalculateSleepTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the maximum sleep time remaining. It will go through all timers to see which timer will expire first. That will be the amount of time to block in the next call to xQueueReceive(). </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum sleep time or ipconfigMAX_IP_TASK_SLEEP_TIME, whichever is smaller. </dd></dl>

</div>
</div>
<a id="a9d5b9dd29ac8f3830bc4b1531b10228a" name="a9d5b9dd29ac8f3830bc4b1531b10228a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5b9dd29ac8f3830bc4b1531b10228a">&#9670;&nbsp;</a></span>prvHandleEthernetPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvHandleEthernetPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle the incoming Ethernet packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxBuffer</td><td>Linked/un-linked network buffer descriptor(s) to be processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bbcca14e07b67e72962278309dd8d07" name="a6bbcca14e07b67e72962278309dd8d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbcca14e07b67e72962278309dd8d07">&#9670;&nbsp;</a></span>prvIPTimerStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvIPTimerStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a> *&#160;</td>
          <td class="paramname"><em>pxTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>xTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start an IP timer. The IP-task has its own implementation of a timer called '<a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a>', which is based on the FreeRTOS 'TimeOut_t'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxTimer</td><td>Pointer to the IP timer. When zero, the timer is marked as expired. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xTime</td><td>Time to be loaded into the IP timer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2a2e3f4cbb0aee222276cfbae2b1590" name="ad2a2e3f4cbb0aee222276cfbae2b1590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a2e3f4cbb0aee222276cfbae2b1590">&#9670;&nbsp;</a></span>prvIPTimerCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvIPTimerCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a> *&#160;</td>
          <td class="paramname"><em>pxTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the IP timer to see whether an IP event should be processed or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxTimer</td><td>Pointer to the IP timer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the timer is expired then pdTRUE is returned. Else pdFALSE. </dd></dl>

</div>
</div>
<a id="ae25d502fab7e4af29bc9b30dffc75ccf" name="ae25d502fab7e4af29bc9b30dffc75ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25d502fab7e4af29bc9b30dffc75ccf">&#9670;&nbsp;</a></span>prvIPTimerReload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvIPTimerReload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_timer__t.html">IPTimer_t</a> *&#160;</td>
          <td class="paramname"><em>pxTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>xTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the reload time of an IP timer and restarts it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxTimer</td><td>Pointer to the IP timer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xTime</td><td>Time to be reloaded into the IP timer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a84cb5865863076c9fd79c75c442bcb" name="a0a84cb5865863076c9fd79c75c442bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84cb5865863076c9fd79c75c442bcb">&#9670;&nbsp;</a></span>prvAllowIPPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static eFrameProcessingResult_t prvAllowIPPacket </td>
          <td>(</td>
          <td class="paramtype">const IPPacket_t *const&#160;</td>
          <td class="paramname"><em>pxIPPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *const&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxHeaderLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this IP packet is to be allowed or to be dropped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxIPPacket</td><td>The IP packet under consideration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The whole network buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxHeaderLength</td><td>The length of the header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the packet should be processed or dropped. </dd></dl>

</div>
</div>
<a id="afb009e3856db87301868748c1732f74d" name="afb009e3856db87301868748c1732f74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb009e3856db87301868748c1732f74d">&#9670;&nbsp;</a></span>prvPacketBuffer_to_NetworkBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> * prvPacketBuffer_to_NetworkBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the network buffer descriptor from the packet buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>The pointer to packet buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOffset</td><td>Additional offset (such as the packet length of UDP packet etc.).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The network buffer descriptor if the alignment is correct. Else a NULL is returned. </dd></dl>

</div>
</div>
<a id="a9844166e6474d5f406df1c57aa4da98f" name="a9844166e6474d5f406df1c57aa4da98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9844166e6474d5f406df1c57aa4da98f">&#9670;&nbsp;</a></span>xIsCallingFromIPTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xIsCallingFromIPTask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check whether the current context belongs to the IP-task. </p>
<dl class="section return"><dt>Returns</dt><dd>If the current context belongs to the IP-task, then pdTRUE is returned. Else pdFALSE is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Very important: the IP-task is not allowed to call its own API's, because it would easily get into a dead-lock. </dd></dl>

</div>
</div>
<a id="adb922d3358a892833f3a4383f7c9c552" name="adb922d3358a892833f3a4383f7c9c552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb922d3358a892833f3a4383f7c9c552">&#9670;&nbsp;</a></span>FreeRTOS_NetworkDownFromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_NetworkDownFromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function. Process Network Down event from ISR. This function is supposed to be called form an ISR. It is recommended. </p>
<ul>
<li>* use '<a class="el" href="_free_r_t_o_s___i_p_8c.html#aa2c7afd343400f1ec8b01cde2f1a8f2e" title="Send a network down event to the IP-task. If it fails to post a message, the failure will be noted in...">FreeRTOS_NetworkDown()</a>', when calling from a normal task.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>If the event was processed successfully, then return pdTRUE. Else pdFALSE. </dd></dl>

</div>
</div>
<a id="aca554a4fa9d8738e5423e3a2912bf340" name="aca554a4fa9d8738e5423e3a2912bf340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca554a4fa9d8738e5423e3a2912bf340">&#9670;&nbsp;</a></span>FreeRTOS_GetUDPPayloadBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* FreeRTOS_GetUDPPayloadBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxRequestedSizeBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxBlockTimeTicks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a buffer big enough for a UDP payload of given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uxRequestedSizeBytes</td><td>The size of the UDP payload. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxBlockTimeTicks</td><td>Maximum amount of time for which this call can block. This value is capped internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a buffer was created then the pointer to that buffer is returned, else a NULL pointer is returned. </dd></dl>

</div>
</div>
<a id="ad104b025d007fc96fbc8d7192c019c2b" name="ad104b025d007fc96fbc8d7192c019c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad104b025d007fc96fbc8d7192c019c2b">&#9670;&nbsp;</a></span>pxDuplicateNetworkBufferWithDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a>* pxDuplicateNetworkBufferWithDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *const&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxNewLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate the given network buffer descriptor with a modified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer to be duplicated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxNewLength</td><td>The length for the new buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If properly duplicated, then the duplicate network buffer or else, NULL. </dd></dl>

</div>
</div>
<a id="a75b905aeed098b75f34aa8bf80ea22d5" name="a75b905aeed098b75f34aa8bf80ea22d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b905aeed098b75f34aa8bf80ea22d5">&#9670;&nbsp;</a></span>pxUDPPayloadBuffer_to_NetworkBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a>* pxUDPPayloadBuffer_to_NetworkBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the network buffer from the UDP Payload buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>Pointer to the UDP payload buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The network buffer if the alignment is correct. Else a NULL is returned. </dd></dl>

</div>
</div>
<a id="ab9acf473a4cda3f58dde4180091464ed" name="ab9acf473a4cda3f58dde4180091464ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9acf473a4cda3f58dde4180091464ed">&#9670;&nbsp;</a></span>FreeRTOS_ReleaseUDPPayloadBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_ReleaseUDPPayloadBuffer </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>pvBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the UDP payload buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>Pointer to the UDP buffer that is to be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5a03616eca530b4ac3ab7d05ff4cc51" name="ae5a03616eca530b4ac3ab7d05ff4cc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a03616eca530b4ac3ab7d05ff4cc51">&#9670;&nbsp;</a></span>FreeRTOS_IPInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_IPInit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ucIPAddress</em>[ipIP_ADDRESS_LENGTH_BYTES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ucNetMask</em>[ipIP_ADDRESS_LENGTH_BYTES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ucGatewayAddress</em>[ipIP_ADDRESS_LENGTH_BYTES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ucDNSServerAddress</em>[ipIP_ADDRESS_LENGTH_BYTES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ucMACAddress</em>[ipMAC_ADDRESS_LENGTH_BYTES]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the FreeRTOS-Plus-TCP network stack and initialise the IP-task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucIPAddress</td><td>Local IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucNetMask</td><td>Local netmask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucGatewayAddress</td><td>Local gateway address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucDNSServerAddress</td><td>Local DNS server address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMACAddress</td><td>MAC address of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h </dd></dl>

</div>
</div>
<a id="ad802acf10146e09bb75437c6fef04632" name="ad802acf10146e09bb75437c6fef04632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad802acf10146e09bb75437c6fef04632">&#9670;&nbsp;</a></span>FreeRTOS_GetAddressConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_GetAddressConfiguration </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pulNetMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pulGatewayAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pulDNSServerAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current address configuration. Only non-NULL pointers will be filled in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pulIPAddress</td><td>The current IP-address assigned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pulNetMask</td><td>The netmask used for current subnet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pulGatewayAddress</td><td>The gateway address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pulDNSServerAddress</td><td>The DNS server address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17cb4b8b79208cca6a95244620ec45c5" name="a17cb4b8b79208cca6a95244620ec45c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cb4b8b79208cca6a95244620ec45c5">&#9670;&nbsp;</a></span>FreeRTOS_SetAddressConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_SetAddressConfiguration </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pulNetMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pulGatewayAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>pulDNSServerAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current network address configuration. Only non-NULL pointers will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pulIPAddress</td><td>The current IP-address assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pulNetMask</td><td>The netmask used for current subnet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pulGatewayAddress</td><td>The gateway address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pulDNSServerAddress</td><td>The DNS server address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64324b01a1fc85efdb7129316e8f7737" name="a64324b01a1fc85efdb7129316e8f7737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64324b01a1fc85efdb7129316e8f7737">&#9670;&nbsp;</a></span>xSendEventToIPTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xSendEventToIPTask </td>
          <td>(</td>
          <td class="paramtype">eIPEvent_t&#160;</td>
          <td class="paramname"><em>eEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an event to the IP task. It calls 'xSendEventStructToIPTask' internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eEvent</td><td>The event to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS if the event was sent (or the desired effect was achieved). Else, pdFAIL. </dd></dl>

</div>
</div>
<a id="a7190bc18fa344fe1fd79021a6db05f84" name="a7190bc18fa344fe1fd79021a6db05f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7190bc18fa344fe1fd79021a6db05f84">&#9670;&nbsp;</a></span>xSendEventStructToIPTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xSendEventStructToIPTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_i_p_stack_event__t.html">IPStackEvent_t</a> *&#160;</td>
          <td class="paramname"><em>pxEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an event (in form of struct) to the IP task to be processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEvent</td><td>The event to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxTimeout</td><td>Timeout for waiting in case the queue is full. 0 for non-blocking calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS if the event was sent (or the desired effect was achieved). Else, pdFAIL. </dd></dl>

</div>
</div>
<a id="a9edea1d81a89bc1838f51f6699982740" name="a9edea1d81a89bc1838f51f6699982740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edea1d81a89bc1838f51f6699982740">&#9670;&nbsp;</a></span>xSendDHCPEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xSendDHCPEvent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DHCP event. </p>
<dl class="section return"><dt>Returns</dt><dd>pdPASS or pdFAIL, depending on whether <a class="el" href="_free_r_t_o_s___i_p_8c.html#a7190bc18fa344fe1fd79021a6db05f84" title="Send an event (in form of struct) to the IP task to be processed.">xSendEventStructToIPTask()</a> succeeded. </dd></dl>

</div>
</div>
<a id="ab15bee3df12f185ea7a1ba671121d19f" name="ab15bee3df12f185ea7a1ba671121d19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15bee3df12f185ea7a1ba671121d19f">&#9670;&nbsp;</a></span>eConsiderFrameForProcessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eFrameProcessingResult_t eConsiderFrameForProcessing </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>pucEthernetBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether this packet should be processed or not based on the IP address in the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucEthernetBuffer</td><td>The ethernet packet under consideration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enum saying whether to release or to process the packet. </dd></dl>

</div>
</div>
<a id="a3c787bfa6502ecfd173ee8f6974e8628" name="a3c787bfa6502ecfd173ee8f6974e8628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c787bfa6502ecfd173ee8f6974e8628">&#9670;&nbsp;</a></span>xIsIPv4Multicast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xIsIPv4Multicast </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the IP address an IPv4 multicast address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>The IP address being checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the IP address is a multicast address or else, pdFALSE. </dd></dl>

</div>
</div>
<a id="af110bcf8c7910fc9149a4a09895efcf4" name="af110bcf8c7910fc9149a4a09895efcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af110bcf8c7910fc9149a4a09895efcf4">&#9670;&nbsp;</a></span>vSetMultiCastIPv4MacAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vSetMultiCastIPv4MacAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MACAddress_t *&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multicast MAC address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>IP address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxMACAddress</td><td>Pointer to MAC address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad4d89d0e834cef68e0746e0404f319d" name="aad4d89d0e834cef68e0746e0404f319d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4d89d0e834cef68e0746e0404f319d">&#9670;&nbsp;</a></span>usGenerateProtocolChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t usGenerateProtocolChecksum </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>pucEthernetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xOutgoingPacket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate or check the protocol checksum of the data sent in the first parameter. At the same time, the length of the packet and the length of the different layers will be checked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucEthernetBuffer</td><td>The Ethernet buffer for which the checksum is to be calculated or checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxBufferLength</td><td>the total number of bytes received, or the number of bytes written in the packet buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xOutgoingPacket</td><td>Whether this is an outgoing packet or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When xOutgoingPacket is false: the error code can be either: ipINVALID_LENGTH, ipUNHANDLED_PROTOCOL, ipWRONG_CRC, or ipCORRECT_CRC. When xOutgoingPacket is true: either ipINVALID_LENGTH or ipCORRECT_CRC. </dd></dl>

</div>
</div>
<a id="a97162cfd5b071ccee8fec503879a3e43" name="a97162cfd5b071ccee8fec503879a3e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97162cfd5b071ccee8fec503879a3e43">&#9670;&nbsp;</a></span>usGenerateChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t usGenerateChecksum </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucNextData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the 16-bit checksum of an array of bytes. </p>
<p >This method generates a checksum for a given IPv4 header, per RFC791 (page 14). The checksum algorithm is described as: "[T]he 16 bit one's complement of the one's complement sum of all 16 bit words in the
  header.  For purposes of computing the checksum, the value of the checksum field is zero."</p>
<p >In a nutshell, that means that each 16-bit 'word' must be summed, after which the number of 'carries' (overflows) is added to the result. If that addition produces an overflow, that 'carry' must also be added to the final result. The final checksum should be the bitwise 'not' (ones-complement) of the result if the packet is meant to be transmitted, but this method simply returns the raw value, probably because when a packet is received, the checksum is verified by checking that ((received &amp; calculated) == 0) without applying a bitwise 'not' to the 'calculated' checksum.</p>
<p >This logic is optimized for microcontrollers which have limited resources, so the logic looks odd. It iterates over the full range of 16-bit words, but it does so by processing several 32-bit words at once whenever possible. Its first step is to align the memory pointer to a 32-bit boundary, after which it runs a fast loop to process multiple 32-bit words at once and adding their 'carries'. Finally, it finishes up by processing any remaining 16-bit words, and adding up all of the 'carries'. With 32-bit arithmetic, the number of 16-bit 'carries' produced by sequential additions can be found by looking at the 16 most-significant bits of the 32-bit integer, since a 32-bit int will continue counting up instead of overflowing after 16 bits. That is why the actual checksum calculations look like: union.u32 = ( uint32_t ) union.u16[ 0 ] + union.u16[ 1 ];</p>
<p >Arguments: ulSum: This argument provides a value to initialise the progressive summation of the header's values to. It is often 0, but protocols like TCP or UDP can have pseudo-header fields which need to be included in the checksum. pucNextData: This argument contains the address of the first byte which this method should process. The method's memory iterator is initialised to this value. uxDataLengthBytes: This argument contains the number of bytes that this method should process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">usSum</td><td>The initial sum, obtained from earlier data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pucNextData</td><td>The actual data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxByteCount</td><td>The number of bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit one's complement of the one's complement sum of all 16-bit words in the header </dd></dl>

</div>
</div>
<a id="a5fb218e96c829c263a677428fe4d5d24" name="a5fb218e96c829c263a677428fe4d5d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb218e96c829c263a677428fe4d5d24">&#9670;&nbsp;</a></span>vReturnEthernetFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vReturnEthernetFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xReleaseAfterSend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the Ethernet frame after checking for some conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer which is to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xReleaseAfterSend</td><td>Whether this network buffer is to be released or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaf07062b415dab09f3e333134b97103" name="aeaf07062b415dab09f3e333134b97103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf07062b415dab09f3e333134b97103">&#9670;&nbsp;</a></span>FreeRTOS_GetIPAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_GetIPAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the IP address of the NIC. </p>
<dl class="section return"><dt>Returns</dt><dd>The IP address of the NIC. </dd></dl>

</div>
</div>
<a id="a99f06ef42d1ac00f4ede5a68962a1502" name="a99f06ef42d1ac00f4ede5a68962a1502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f06ef42d1ac00f4ede5a68962a1502">&#9670;&nbsp;</a></span>FreeRTOS_SetIPAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_SetIPAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the IP address of the NIC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>IP address of the NIC to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a9033775f90dafde04eaa8236ca36c7" name="a6a9033775f90dafde04eaa8236ca36c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9033775f90dafde04eaa8236ca36c7">&#9670;&nbsp;</a></span>FreeRTOS_GetGatewayAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_GetGatewayAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the gateway address of the subnet. </p>
<dl class="section return"><dt>Returns</dt><dd>The IP-address of the gateway, zero if a gateway is not used/defined. </dd></dl>

</div>
</div>
<a id="a0445e00d7886a94e4b39ec47a7e96964" name="a0445e00d7886a94e4b39ec47a7e96964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0445e00d7886a94e4b39ec47a7e96964">&#9670;&nbsp;</a></span>FreeRTOS_GetDNSServerAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_GetDNSServerAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the DNS server address. </p>
<dl class="section return"><dt>Returns</dt><dd>The IP address of the DNS server. </dd></dl>

</div>
</div>
<a id="ac94f1e03ad9facdc02d68063f7ba3101" name="ac94f1e03ad9facdc02d68063f7ba3101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94f1e03ad9facdc02d68063f7ba3101">&#9670;&nbsp;</a></span>FreeRTOS_GetNetmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_GetNetmask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the netmask for the subnet. </p>
<dl class="section return"><dt>Returns</dt><dd>The 32 bit netmask for the subnet. </dd></dl>

</div>
</div>
<a id="af4d5550342028837be656fbf35cae815" name="af4d5550342028837be656fbf35cae815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d5550342028837be656fbf35cae815">&#9670;&nbsp;</a></span>FreeRTOS_UpdateMACAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_UpdateMACAddress </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ucMACAddress</em>[ipMAC_ADDRESS_LENGTH_BYTES]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the MAC address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMACAddress</td><td>the MAC address to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5245023fe8eda88775545c90d39c7763" name="a5245023fe8eda88775545c90d39c7763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5245023fe8eda88775545c90d39c7763">&#9670;&nbsp;</a></span>FreeRTOS_GetMACAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* FreeRTOS_GetMACAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MAC address. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to MAC address. </dd></dl>

</div>
</div>
<a id="a69b7f10a7f753fc50ea2bf7712dbcd5b" name="a69b7f10a7f753fc50ea2bf7712dbcd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b7f10a7f753fc50ea2bf7712dbcd5b">&#9670;&nbsp;</a></span>FreeRTOS_SetNetmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_SetNetmask </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulNetmask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the netmask for the subnet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulNetmask</td><td>The 32 bit netmask of the subnet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3329850735ce894baeef8fbac70be579" name="a3329850735ce894baeef8fbac70be579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3329850735ce894baeef8fbac70be579">&#9670;&nbsp;</a></span>FreeRTOS_SetGatewayAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_SetGatewayAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulGatewayAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the gateway address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulGatewayAddress</td><td>The gateway address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4f26bbec48d40bb077621b734adddc8" name="ab4f26bbec48d40bb077621b734adddc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f26bbec48d40bb077621b734adddc8">&#9670;&nbsp;</a></span>vIPSetDHCPTimerEnableState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vIPSetDHCPTimerEnableState </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xEnableState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable the DHCP timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xEnableState</td><td>pdTRUE - enable timer; pdFALSE - disable timer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a880467f5ff22e0154bf8124fa437ea8e" name="a880467f5ff22e0154bf8124fa437ea8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880467f5ff22e0154bf8124fa437ea8e">&#9670;&nbsp;</a></span>vIPReloadDHCPTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vIPReloadDHCPTimer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulLeaseTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reload the DHCP timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulLeaseTime</td><td>The reload value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a575576b2fe366f64e201c7cef093f454" name="a575576b2fe366f64e201c7cef093f454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575576b2fe366f64e201c7cef093f454">&#9670;&nbsp;</a></span>vIPSetDnsTimerEnableState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vIPSetDnsTimerEnableState </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xEnableState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable the DNS timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xEnableState</td><td>pdTRUE - enable timer; pdFALSE - disable timer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d1e820182a6f16577d5f36cd2e0819" name="ab6d1e820182a6f16577d5f36cd2e0819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d1e820182a6f16577d5f36cd2e0819">&#9670;&nbsp;</a></span>vIPReloadDNSTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vIPReloadDNSTimer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulCheckTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reload the DNS timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulCheckTime</td><td>The reload value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b2222c2b48904fb90674927a2c489d" name="a52b2222c2b48904fb90674927a2c489d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b2222c2b48904fb90674927a2c489d">&#9670;&nbsp;</a></span>xIPIsNetworkTaskReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xIPIsNetworkTaskReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the IP task is ready. </p>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if IP task is ready, else pdFALSE. </dd></dl>

</div>
</div>
<a id="ac1f02ee6cc4e8f633ed3ddbc3d01e943" name="ac1f02ee6cc4e8f633ed3ddbc3d01e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f02ee6cc4e8f633ed3ddbc3d01e943">&#9670;&nbsp;</a></span>FreeRTOS_IsNetworkUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_IsNetworkUp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this node is connected to network or not. </p>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if network is connected, else pdFALSE. </dd></dl>

</div>
</div>
<a id="a738b12572023fadb0e5ed3c3204a2ccb" name="a738b12572023fadb0e5ed3c3204a2ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738b12572023fadb0e5ed3c3204a2ccb">&#9670;&nbsp;</a></span>FreeRTOS_strerror_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* FreeRTOS_strerror_r </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xErrnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function: Convert error number to a human readable string. Declaration in <a class="el" href="_free_r_t_o_s__errno___t_c_p_8h_source.html">FreeRTOS_errno_TCP.h</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xErrnum</td><td>The error number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcBuffer</td><td>Buffer big enough to be filled with the human readable message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxLength</td><td>Maximum length of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer filled with human readable error string. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="_free_r_t_o_s___i_p_8c.html">FreeRTOS_IP.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
