<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_TCP_IP.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="foobar.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V2.3.2</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___t_c_p___i_p_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_TCP_IP.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Module which handles the TCP connections for FreeRTOS+TCP. It depends on <a class="el" href="_free_r_t_o_s___t_c_p___w_i_n_8c.html" title="Module which handles the TCP windowing schemes for FreeRTOS+TCP. Many functions have two versions - o...">FreeRTOS_TCP_WIN.c</a>, which handles the TCP windowing schemes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;queue.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Sockets.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;FreeRTOS_UDP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DHCP.h&quot;</code><br />
<code>#include &quot;NetworkInterface.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ARP.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa23ea9f1090719d5fe63b05b916f8475"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aa23ea9f1090719d5fe63b05b916f8475">tcpTCP_FLAG_FIN</a>&#160;&#160;&#160;( ( uint8_t ) 0x01U )</td></tr>
<tr class="memdesc:aa23ea9f1090719d5fe63b05b916f8475"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#aa23ea9f1090719d5fe63b05b916f8475">More...</a><br /></td></tr>
<tr class="separator:aa23ea9f1090719d5fe63b05b916f8475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab413c82652ca09af97361cf9477a47c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aab413c82652ca09af97361cf9477a47c">tcpTCP_FLAG_SYN</a>&#160;&#160;&#160;( ( uint8_t ) 0x02U )</td></tr>
<tr class="memdesc:aab413c82652ca09af97361cf9477a47c"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#aab413c82652ca09af97361cf9477a47c">More...</a><br /></td></tr>
<tr class="separator:aab413c82652ca09af97361cf9477a47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaca8c0103423aaab32d151387adee18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aeaca8c0103423aaab32d151387adee18">tcpTCP_FLAG_RST</a>&#160;&#160;&#160;( ( uint8_t ) 0x04U )</td></tr>
<tr class="memdesc:aeaca8c0103423aaab32d151387adee18"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#aeaca8c0103423aaab32d151387adee18">More...</a><br /></td></tr>
<tr class="separator:aeaca8c0103423aaab32d151387adee18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71daac922d12e3e3ff760fbfc7db8875"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a71daac922d12e3e3ff760fbfc7db8875">tcpTCP_FLAG_PSH</a>&#160;&#160;&#160;( ( uint8_t ) 0x08U )</td></tr>
<tr class="memdesc:a71daac922d12e3e3ff760fbfc7db8875"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a71daac922d12e3e3ff760fbfc7db8875">More...</a><br /></td></tr>
<tr class="separator:a71daac922d12e3e3ff760fbfc7db8875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dee2ad910b9b2121318ab0a22291dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a96dee2ad910b9b2121318ab0a22291dd">tcpTCP_FLAG_ACK</a>&#160;&#160;&#160;( ( uint8_t ) 0x10U )</td></tr>
<tr class="memdesc:a96dee2ad910b9b2121318ab0a22291dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a96dee2ad910b9b2121318ab0a22291dd">More...</a><br /></td></tr>
<tr class="separator:a96dee2ad910b9b2121318ab0a22291dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cecc71bb9663461bbcdd14e1cca10b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0cecc71bb9663461bbcdd14e1cca10b0">tcpTCP_FLAG_URG</a>&#160;&#160;&#160;( ( uint8_t ) 0x20U )</td></tr>
<tr class="memdesc:a0cecc71bb9663461bbcdd14e1cca10b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0cecc71bb9663461bbcdd14e1cca10b0">More...</a><br /></td></tr>
<tr class="separator:a0cecc71bb9663461bbcdd14e1cca10b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4fe51b7e508a123941990ff10ffee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a9bd4fe51b7e508a123941990ff10ffee">tcpTCP_FLAG_ECN</a>&#160;&#160;&#160;( ( uint8_t ) 0x40U )</td></tr>
<tr class="memdesc:a9bd4fe51b7e508a123941990ff10ffee"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a9bd4fe51b7e508a123941990ff10ffee">More...</a><br /></td></tr>
<tr class="separator:a9bd4fe51b7e508a123941990ff10ffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88c66473fde8218a9e885b645e41a13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aa88c66473fde8218a9e885b645e41a13">tcpTCP_FLAG_CWR</a>&#160;&#160;&#160;( ( uint8_t ) 0x80U )</td></tr>
<tr class="memdesc:aa88c66473fde8218a9e885b645e41a13"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#aa88c66473fde8218a9e885b645e41a13">More...</a><br /></td></tr>
<tr class="separator:aa88c66473fde8218a9e885b645e41a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11f82b0e649e5d88a6a1196b08b401d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ac11f82b0e649e5d88a6a1196b08b401d">tcpTCP_FLAG_CTRL</a>&#160;&#160;&#160;( ( uint8_t ) 0x1FU )</td></tr>
<tr class="memdesc:ac11f82b0e649e5d88a6a1196b08b401d"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ac11f82b0e649e5d88a6a1196b08b401d">More...</a><br /></td></tr>
<tr class="separator:ac11f82b0e649e5d88a6a1196b08b401d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bba2554431f5b7fda5d97d222ef9786"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0bba2554431f5b7fda5d97d222ef9786">tcpTCP_OPT_END</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:a0bba2554431f5b7fda5d97d222ef9786"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0bba2554431f5b7fda5d97d222ef9786">More...</a><br /></td></tr>
<tr class="separator:a0bba2554431f5b7fda5d97d222ef9786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdf7f0c704090fc5e0439f993a40f8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0fdf7f0c704090fc5e0439f993a40f8f">tcpTCP_OPT_NOOP</a>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:a0fdf7f0c704090fc5e0439f993a40f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0fdf7f0c704090fc5e0439f993a40f8f">More...</a><br /></td></tr>
<tr class="separator:a0fdf7f0c704090fc5e0439f993a40f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca14d2b8c5971642e2d2645c492cc2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a1ca14d2b8c5971642e2d2645c492cc2a">tcpTCP_OPT_MSS</a>&#160;&#160;&#160;2U</td></tr>
<tr class="memdesc:a1ca14d2b8c5971642e2d2645c492cc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a1ca14d2b8c5971642e2d2645c492cc2a">More...</a><br /></td></tr>
<tr class="separator:a1ca14d2b8c5971642e2d2645c492cc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd42af6084ca092b20953b996f39719"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a7fd42af6084ca092b20953b996f39719">tcpTCP_OPT_WSOPT</a>&#160;&#160;&#160;3U</td></tr>
<tr class="memdesc:a7fd42af6084ca092b20953b996f39719"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a7fd42af6084ca092b20953b996f39719">More...</a><br /></td></tr>
<tr class="separator:a7fd42af6084ca092b20953b996f39719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cecfff8a8e16e2059268c16af8f5615"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a7cecfff8a8e16e2059268c16af8f5615">tcpTCP_OPT_SACK_P</a>&#160;&#160;&#160;4U</td></tr>
<tr class="memdesc:a7cecfff8a8e16e2059268c16af8f5615"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a7cecfff8a8e16e2059268c16af8f5615">More...</a><br /></td></tr>
<tr class="separator:a7cecfff8a8e16e2059268c16af8f5615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc66468782cc29eb6ce182a07b2d11d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#adc66468782cc29eb6ce182a07b2d11d6">tcpTCP_OPT_SACK_A</a>&#160;&#160;&#160;5U</td></tr>
<tr class="memdesc:adc66468782cc29eb6ce182a07b2d11d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#adc66468782cc29eb6ce182a07b2d11d6">More...</a><br /></td></tr>
<tr class="separator:adc66468782cc29eb6ce182a07b2d11d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fedb3a976274f11461a300b2d9568e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a7fedb3a976274f11461a300b2d9568e6">tcpTCP_OPT_TIMESTAMP</a>&#160;&#160;&#160;8U</td></tr>
<tr class="memdesc:a7fedb3a976274f11461a300b2d9568e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a7fedb3a976274f11461a300b2d9568e6">More...</a><br /></td></tr>
<tr class="separator:a7fedb3a976274f11461a300b2d9568e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7cfb33a05d29167808c7c7a093d5bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0d7cfb33a05d29167808c7c7a093d5bf">tcpTCP_OPT_MSS_LEN</a>&#160;&#160;&#160;4U</td></tr>
<tr class="memdesc:a0d7cfb33a05d29167808c7c7a093d5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0d7cfb33a05d29167808c7c7a093d5bf">More...</a><br /></td></tr>
<tr class="separator:a0d7cfb33a05d29167808c7c7a093d5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe51ca2c0ca39f68c207456152fad2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a3fe51ca2c0ca39f68c207456152fad2e">tcpTCP_OPT_WSOPT_LEN</a>&#160;&#160;&#160;3U</td></tr>
<tr class="memdesc:a3fe51ca2c0ca39f68c207456152fad2e"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a3fe51ca2c0ca39f68c207456152fad2e">More...</a><br /></td></tr>
<tr class="separator:a3fe51ca2c0ca39f68c207456152fad2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad565b934d8982b674a926eefa85481fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ad565b934d8982b674a926eefa85481fb">tcpTCP_OPT_TIMESTAMP_LEN</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ad565b934d8982b674a926eefa85481fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ad565b934d8982b674a926eefa85481fb">More...</a><br /></td></tr>
<tr class="separator:ad565b934d8982b674a926eefa85481fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2443d4b4e820eba87abb0cc920cccff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ab2443d4b4e820eba87abb0cc920cccff">ipconfigTCP_ACK_EARLIER_PACKET</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ab2443d4b4e820eba87abb0cc920cccff"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ab2443d4b4e820eba87abb0cc920cccff">More...</a><br /></td></tr>
<tr class="separator:ab2443d4b4e820eba87abb0cc920cccff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa179a7d374ac0a969dba186a61621db1"><td class="memItemLeft" align="right" valign="top"><a id="aa179a7d374ac0a969dba186a61621db1" name="aa179a7d374ac0a969dba186a61621db1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcpNOW_CONNECTED</b>(status)&#160;&#160;&#160;    ( ( ( ( status ) &gt;= ( BaseType_t ) eESTABLISHED ) &amp;&amp; ( ( status ) != ( BaseType_t ) eCLOSE_WAIT ) ) ? 1 : 0 )</td></tr>
<tr class="memdesc:aa179a7d374ac0a969dba186a61621db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The macro <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aa179a7d374ac0a969dba186a61621db1" title="The macro tcpNOW_CONNECTED() is use to determine if the connection makes a transition from connected ...">tcpNOW_CONNECTED()</a> is use to determine if the connection makes a transition from connected to non-connected and vice versa. <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aa179a7d374ac0a969dba186a61621db1" title="The macro tcpNOW_CONNECTED() is use to determine if the connection makes a transition from connected ...">tcpNOW_CONNECTED()</a> returns true when the status has one of these values: eESTABLISHED, eFIN_WAIT_1, eFIN_WAIT_2, eCLOSING, eLAST_ACK, eTIME_WAIT Technically the connection status is closed earlier, but the library wants to prevent that the socket will be deleted before the last ACK has been and thus causing a 'RST' packet on either side. <br /></td></tr>
<tr class="separator:aa179a7d374ac0a969dba186a61621db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d3b988aa560daa7b2675ff9986c01b"><td class="memItemLeft" align="right" valign="top"><a id="a70d3b988aa560daa7b2675ff9986c01b" name="a70d3b988aa560daa7b2675ff9986c01b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcpVALID_BITS_IN_TCP_OFFSET_BYTE</b>&#160;&#160;&#160;( 0xF0U )</td></tr>
<tr class="memdesc:a70d3b988aa560daa7b2675ff9986c01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The highest 4 bits in the TCP offset byte indicate the total length of the TCP header, divided by 4. <br /></td></tr>
<tr class="separator:a70d3b988aa560daa7b2675ff9986c01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3395a76923220eca4221c12dff07d3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae3395a76923220eca4221c12dff07d3e">tcpDELAYED_ACK_SHORT_DELAY_MS</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="memdesc:ae3395a76923220eca4221c12dff07d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae3395a76923220eca4221c12dff07d3e">More...</a><br /></td></tr>
<tr class="separator:ae3395a76923220eca4221c12dff07d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2813bcb2476a861459453422d1960008"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a2813bcb2476a861459453422d1960008">tcpDELAYED_ACK_LONGER_DELAY_MS</a>&#160;&#160;&#160;( 20 )</td></tr>
<tr class="memdesc:a2813bcb2476a861459453422d1960008"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a2813bcb2476a861459453422d1960008">More...</a><br /></td></tr>
<tr class="separator:a2813bcb2476a861459453422d1960008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc72505b99e0b00f63279c6c4b6ab24c"><td class="memItemLeft" align="right" valign="top"><a id="abc72505b99e0b00f63279c6c4b6ab24c" name="abc72505b99e0b00f63279c6c4b6ab24c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcpREDUCED_MSS_THROUGH_INTERNET</b>&#160;&#160;&#160;( 1400 )</td></tr>
<tr class="memdesc:abc72505b99e0b00f63279c6c4b6ab24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MSS (Maximum Segment Size) will be taken as large as possible. However, packets with an MSS of 1460 bytes won't be transported through the internet. The MSS will be reduced to 1400 bytes. <br /></td></tr>
<tr class="separator:abc72505b99e0b00f63279c6c4b6ab24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dd1d433f631a2c079b0ef7703cf764"><td class="memItemLeft" align="right" valign="top"><a id="a61dd1d433f631a2c079b0ef7703cf764" name="a61dd1d433f631a2c079b0ef7703cf764"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcpTCP_OFFSET_LENGTH_BITS</b>&#160;&#160;&#160;( 0xf0U )</td></tr>
<tr class="memdesc:a61dd1d433f631a2c079b0ef7703cf764"><td class="mdescLeft">&#160;</td><td class="mdescRight">When there are no TCP options, the TCP offset equals 20 bytes, which is stored as the number 5 (words) in the higher nibble of the TCP-offset byte. <br /></td></tr>
<tr class="separator:a61dd1d433f631a2c079b0ef7703cf764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e28e136632b3bc7881c2ef87e966c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae9e28e136632b3bc7881c2ef87e966c2">tcpTCP_OFFSET_STANDARD_LENGTH</a>&#160;&#160;&#160;( 0x50U )</td></tr>
<tr class="memdesc:ae9e28e136632b3bc7881c2ef87e966c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae9e28e136632b3bc7881c2ef87e966c2">More...</a><br /></td></tr>
<tr class="separator:ae9e28e136632b3bc7881c2ef87e966c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c75cc05cf4bbf1d8160191dff0c303"><td class="memItemLeft" align="right" valign="top"><a id="a45c75cc05cf4bbf1d8160191dff0c303" name="a45c75cc05cf4bbf1d8160191dff0c303"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEND_REPEATED_COUNT</b>&#160;&#160;&#160;( 8 )</td></tr>
<tr class="memdesc:a45c75cc05cf4bbf1d8160191dff0c303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each TCP socket is checked regularly to see if it can send data packets. By default, the maximum number of packets sent during one check is limited to 8. This amount may be further limited by setting the socket's TX window size. <br /></td></tr>
<tr class="separator:a45c75cc05cf4bbf1d8160191dff0c303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70b9afd422a764386be33ca7847d5bc"><td class="memItemLeft" align="right" valign="top"><a id="aa70b9afd422a764386be33ca7847d5bc" name="aa70b9afd422a764386be33ca7847d5bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcpMAXIMUM_TCP_WAKEUP_TIME_MS</b>&#160;&#160;&#160;20000U</td></tr>
<tr class="memdesc:aa70b9afd422a764386be33ca7847d5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a maximum period of time (ms) to leave a TCP-socket unattended. When a TCP timer expires, retries and keep-alive messages will be checked. <br /></td></tr>
<tr class="separator:aa70b9afd422a764386be33ca7847d5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688a156ac82e335f6acb73564af691e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a688a156ac82e335f6acb73564af691e7">xIPHeaderSize</a>(pxNetworkBuffer)&#160;&#160;&#160;( ipSIZE_OF_IPv4_HEADER )</td></tr>
<tr class="memdesc:a688a156ac82e335f6acb73564af691e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a688a156ac82e335f6acb73564af691e7">More...</a><br /></td></tr>
<tr class="separator:a688a156ac82e335f6acb73564af691e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8136ac000e6a04d5f098cd691ac1a14b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a8136ac000e6a04d5f098cd691ac1a14b">uxIPHeaderSizeSocket</a>(pxSocket)&#160;&#160;&#160;( ipSIZE_OF_IPv4_HEADER )</td></tr>
<tr class="memdesc:a8136ac000e6a04d5f098cd691ac1a14b"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a8136ac000e6a04d5f098cd691ac1a14b">More...</a><br /></td></tr>
<tr class="separator:a8136ac000e6a04d5f098cd691ac1a14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a074e94106db91d94f21c0580affde782"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a074e94106db91d94f21c0580affde782">prvTCPSocketIsActive</a> (eIPTCPState_t xStatus)</td></tr>
<tr class="memdesc:a074e94106db91d94f21c0580affde782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the socket is active or not.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a074e94106db91d94f21c0580affde782">More...</a><br /></td></tr>
<tr class="separator:a074e94106db91d94f21c0580affde782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb9df3f6539966ec17c4752cd99e035"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#abfb9df3f6539966ec17c4752cd99e035">prvTCPSendPacket</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:abfb9df3f6539966ec17c4752cd99e035"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#abfb9df3f6539966ec17c4752cd99e035" title="prvTCPSendPacket() will be called when the socket time-out has been reached.">prvTCPSendPacket()</a> will be called when the socket time-out has been reached.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#abfb9df3f6539966ec17c4752cd99e035">More...</a><br /></td></tr>
<tr class="separator:abfb9df3f6539966ec17c4752cd99e035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55092c8fe479837a69c29167b5e16ae"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae55092c8fe479837a69c29167b5e16ae">prvTCPSendRepeated</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **ppxNetworkBuffer)</td></tr>
<tr class="memdesc:ae55092c8fe479837a69c29167b5e16ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">prvTCPSendRepeated will try to send a series of messages, as long as there is data to be sent and as long as the transmit window isn't full.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae55092c8fe479837a69c29167b5e16ae">More...</a><br /></td></tr>
<tr class="separator:ae55092c8fe479837a69c29167b5e16ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c3299ce1b59128557449658e170da3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a90c3299ce1b59128557449658e170da3">prvTCPReturnPacket</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxDescriptor, uint32_t ulLen, BaseType_t xReleaseAfterSend)</td></tr>
<tr class="memdesc:a90c3299ce1b59128557449658e170da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a real network buffer or to a TCP socket field called 'xTCP.xPacket'. A temporary xNetworkBuffer will be used to pass the data to the NIC.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a90c3299ce1b59128557449658e170da3">More...</a><br /></td></tr>
<tr class="separator:a90c3299ce1b59128557449658e170da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486e0a50c3dc44834ee585ed9c62766b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a486e0a50c3dc44834ee585ed9c62766b">prvTCPCreateWindow</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:a486e0a50c3dc44834ee585ed9c62766b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the TCP window for the given socket.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a486e0a50c3dc44834ee585ed9c62766b">More...</a><br /></td></tr>
<tr class="separator:a486e0a50c3dc44834ee585ed9c62766b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259d393932637c52fd7e1eb22c10b3c6"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a259d393932637c52fd7e1eb22c10b3c6">prvTCPPrepareConnect</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:a259d393932637c52fd7e1eb22c10b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let ARP look-up the MAC-address of the peer and initialise the first SYN packet.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a259d393932637c52fd7e1eb22c10b3c6">More...</a><br /></td></tr>
<tr class="separator:a259d393932637c52fd7e1eb22c10b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4372b4f0f440715d288b7fd5681be3"><td class="memItemLeft" align="right" valign="top">_static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aaa4372b4f0f440715d288b7fd5681be3">prvCheckOptions</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer)</td></tr>
<tr class="memdesc:aaa4372b4f0f440715d288b7fd5681be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the TCP option(s) received, if present.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#aaa4372b4f0f440715d288b7fd5681be3">More...</a><br /></td></tr>
<tr class="separator:aaa4372b4f0f440715d288b7fd5681be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5ccd90ad6e056252cbde7d34c9bda0"><td class="memItemLeft" align="right" valign="top">_static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a8f5ccd90ad6e056252cbde7d34c9bda0">prvSingleStepTCPHeaderOptions</a> (const uint8_t *const pucPtr, size_t uxTotalLength, <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *const pxSocket, BaseType_t xHasSYNFlag)</td></tr>
<tr class="memdesc:a8f5ccd90ad6e056252cbde7d34c9bda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify and deal with a single TCP header option, advancing the pointer to the header.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a8f5ccd90ad6e056252cbde7d34c9bda0">More...</a><br /></td></tr>
<tr class="separator:a8f5ccd90ad6e056252cbde7d34c9bda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3ea49e8ee6f2c7a12bb2708575d88"><td class="memItemLeft" align="right" valign="top">_static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a5bd3ea49e8ee6f2c7a12bb2708575d88">prvReadSackOption</a> (const uint8_t *const pucPtr, size_t uxIndex, <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *const pxSocket)</td></tr>
<tr class="memdesc:a5bd3ea49e8ee6f2c7a12bb2708575d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip past TCP header options when doing Selective ACK, until there are no more options left.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a5bd3ea49e8ee6f2c7a12bb2708575d88">More...</a><br /></td></tr>
<tr class="separator:a5bd3ea49e8ee6f2c7a12bb2708575d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffa471bf4c769535d3f7b9d5a968cdb"><td class="memItemLeft" align="right" valign="top">static UBaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0ffa471bf4c769535d3f7b9d5a968cdb">prvSetSynAckOptions</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, TCPHeader_t *pxTCPHeader)</td></tr>
<tr class="memdesc:a0ffa471bf4c769535d3f7b9d5a968cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When opening a TCP connection, while SYN's are being sent, the parties may communicate what MSS (Maximum Segment Size) they intend to use, whether Selective ACK's ( SACK ) are supported, and the size of the reception window ( WSOPT ).  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0ffa471bf4c769535d3f7b9d5a968cdb">More...</a><br /></td></tr>
<tr class="separator:a0ffa471bf4c769535d3f7b9d5a968cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e47864a5591d814aa9baf281c20cd5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#af1e47864a5591d814aa9baf281c20cd5">prvTCPTouchSocket</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:af1e47864a5591d814aa9baf281c20cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Touch' the socket to keep it alive/updated.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#af1e47864a5591d814aa9baf281c20cd5">More...</a><br /></td></tr>
<tr class="separator:af1e47864a5591d814aa9baf281c20cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f032b5eef69f4f6a2ba16a2c516954"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a03f032b5eef69f4f6a2ba16a2c516954">prvTCPPrepareSend</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **ppxNetworkBuffer, UBaseType_t uxOptionsLength)</td></tr>
<tr class="memdesc:a03f032b5eef69f4f6a2ba16a2c516954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare an outgoing message, in case anything has to be sent.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a03f032b5eef69f4f6a2ba16a2c516954">More...</a><br /></td></tr>
<tr class="separator:a03f032b5eef69f4f6a2ba16a2c516954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80be66ff5dea32208cc3303072fbfa3"><td class="memItemLeft" align="right" valign="top">static TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae80be66ff5dea32208cc3303072fbfa3">prvTCPNextTimeout</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:ae80be66ff5dea32208cc3303072fbfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate after how much time this socket needs to be checked again.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae80be66ff5dea32208cc3303072fbfa3">More...</a><br /></td></tr>
<tr class="separator:ae80be66ff5dea32208cc3303072fbfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b5073967e63a162c6fd13dc9b2a45"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a5c3b5073967e63a162c6fd13dc9b2a45">prvTCPAddTxData</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:a5c3b5073967e63a162c6fd13dc9b2a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API <a class="el" href="_free_r_t_o_s___sockets_8c.html#abfb04a35d27c55380be674ebd8204351" title="Send data using a TCP socket. It is not necessary to have the socket connected already....">FreeRTOS_send()</a> adds data to the TX stream. Add this data to the windowing system to it can be transmitted.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a5c3b5073967e63a162c6fd13dc9b2a45">More...</a><br /></td></tr>
<tr class="separator:a5c3b5073967e63a162c6fd13dc9b2a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed19306eb74e28863615dd7be8e2e1a7"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aed19306eb74e28863615dd7be8e2e1a7">prvTCPHandleFin</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer)</td></tr>
<tr class="memdesc:aed19306eb74e28863615dd7be8e2e1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aed19306eb74e28863615dd7be8e2e1a7" title="prvTCPHandleFin() will be called to handle connection closure. The closure starts when either a FIN h...">prvTCPHandleFin()</a> will be called to handle connection closure. The closure starts when either a FIN has been received and accepted, or when the socket has sent a FIN flag to the peer. Before being called, it has been checked that both reception and transmission are complete.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#aed19306eb74e28863615dd7be8e2e1a7">More...</a><br /></td></tr>
<tr class="separator:aed19306eb74e28863615dd7be8e2e1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5273259449f802266c3c5a8d0ef03389"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a5273259449f802266c3c5a8d0ef03389">prvCheckRxData</a> (const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer, uint8_t **ppucRecvData)</td></tr>
<tr class="memdesc:a5273259449f802266c3c5a8d0ef03389"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a5273259449f802266c3c5a8d0ef03389" title="prvCheckRxData(): called from prvTCPHandleState(). The first thing that will be done is find the TCP ...">prvCheckRxData()</a>: called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. The first thing that will be done is find the TCP payload data and check the length of this data.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a5273259449f802266c3c5a8d0ef03389">More...</a><br /></td></tr>
<tr class="separator:a5273259449f802266c3c5a8d0ef03389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918dc39521690f49ba16c2ed9deacf4e"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a918dc39521690f49ba16c2ed9deacf4e">prvStoreRxData</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, const uint8_t *pucRecvData, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer, uint32_t ulReceiveLength)</td></tr>
<tr class="memdesc:a918dc39521690f49ba16c2ed9deacf4e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a918dc39521690f49ba16c2ed9deacf4e" title="prvStoreRxData(): called from prvTCPHandleState(). The second thing is to do is check if the payload ...">prvStoreRxData()</a>: called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. The second thing is to do is check if the payload data may be accepted. If so, they will be added to the reception queue.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a918dc39521690f49ba16c2ed9deacf4e">More...</a><br /></td></tr>
<tr class="separator:a918dc39521690f49ba16c2ed9deacf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f106d9f19f8c57b3b851fb77eab9445"><td class="memItemLeft" align="right" valign="top">static UBaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a2f106d9f19f8c57b3b851fb77eab9445">prvSetOptions</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer)</td></tr>
<tr class="memdesc:a2f106d9f19f8c57b3b851fb77eab9445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TCP options (if any) for the outgoing packet.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a2f106d9f19f8c57b3b851fb77eab9445">More...</a><br /></td></tr>
<tr class="separator:a2f106d9f19f8c57b3b851fb77eab9445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bfd1b31c5ec1532040b5c728b52222"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a38bfd1b31c5ec1532040b5c728b52222">prvHandleSynReceived</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer, uint32_t ulReceiveLength, UBaseType_t uxOptionsLength)</td></tr>
<tr class="memdesc:a38bfd1b31c5ec1532040b5c728b52222"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a38bfd1b31c5ec1532040b5c728b52222" title="prvHandleSynReceived(): called from prvTCPHandleState(). Called from the states: eSYN_RECEIVED and eC...">prvHandleSynReceived()</a>: called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. Called from the states: eSYN_RECEIVED and eCONNECT_SYN. If the flags received are correct, the socket will move to eESTABLISHED.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a38bfd1b31c5ec1532040b5c728b52222">More...</a><br /></td></tr>
<tr class="separator:a38bfd1b31c5ec1532040b5c728b52222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321329a25c8f6de7856bec44678d6326"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a321329a25c8f6de7856bec44678d6326">prvHandleEstablished</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **ppxNetworkBuffer, uint32_t ulReceiveLength, UBaseType_t uxOptionsLength)</td></tr>
<tr class="memdesc:a321329a25c8f6de7856bec44678d6326"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a321329a25c8f6de7856bec44678d6326" title="prvHandleEstablished(): called from prvTCPHandleState() Called if the status is eESTABLISHED....">prvHandleEstablished()</a>: called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a> Called if the status is eESTABLISHED. Data reception has been handled earlier. Here the ACK's from peer will be checked, and if a FIN is received, the code will check if it may be accepted, i.e. if all expected data has been completely received.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a321329a25c8f6de7856bec44678d6326">More...</a><br /></td></tr>
<tr class="separator:a321329a25c8f6de7856bec44678d6326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48f7b6332e810a14c8269f17775ea10"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ad48f7b6332e810a14c8269f17775ea10">prvSendData</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **ppxNetworkBuffer, uint32_t ulReceiveLength, BaseType_t xByteCount)</td></tr>
<tr class="memdesc:ad48f7b6332e810a14c8269f17775ea10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. There is data to be sent. If ipconfigUSE_TCP_WIN is defined, and if only an ACK must be sent, it will be checked if it would better be postponed for efficiency.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ad48f7b6332e810a14c8269f17775ea10">More...</a><br /></td></tr>
<tr class="separator:ad48f7b6332e810a14c8269f17775ea10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f3542839fd1e377e333918afd81a4"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4">prvTCPHandleState</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **ppxNetworkBuffer)</td></tr>
<tr class="memdesc:a396f3542839fd1e377e333918afd81a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check incoming packets for valid data and handle the state of the TCP connection and respond according to the situation.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4">More...</a><br /></td></tr>
<tr class="separator:a396f3542839fd1e377e333918afd81a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f06e746cb1cfac5d3e8c5a9465ba950"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a1f06e746cb1cfac5d3e8c5a9465ba950">prvTCPSendSpecialPacketHelper</a> (<a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer, uint8_t ucTCPFlags)</td></tr>
<tr class="memdesc:a1f06e746cb1cfac5d3e8c5a9465ba950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common code for sending a TCP protocol control packet (i.e. no options, no payload, just flags).  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a1f06e746cb1cfac5d3e8c5a9465ba950">More...</a><br /></td></tr>
<tr class="separator:a1f06e746cb1cfac5d3e8c5a9465ba950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd027c2104ce7522015fe84d02681516"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#abd027c2104ce7522015fe84d02681516">prvTCPSendChallengeAck</a> (<a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer)</td></tr>
<tr class="memdesc:abd027c2104ce7522015fe84d02681516"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "challenge ACK" is as per <a href="https://tools.ietf.org/html/rfc5961#section-3.2">https://tools.ietf.org/html/rfc5961#section-3.2</a>, case #3. In summary, an RST was received with a sequence number that is unexpected but still within the window.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#abd027c2104ce7522015fe84d02681516">More...</a><br /></td></tr>
<tr class="separator:abd027c2104ce7522015fe84d02681516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a1dc6f7c485315189b8b0f3094d839"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ac7a1dc6f7c485315189b8b0f3094d839">prvTCPSendReset</a> (<a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer)</td></tr>
<tr class="memdesc:ac7a1dc6f7c485315189b8b0f3094d839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a RST (Reset) to peer in case the packet cannot be handled.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ac7a1dc6f7c485315189b8b0f3094d839">More...</a><br /></td></tr>
<tr class="separator:ac7a1dc6f7c485315189b8b0f3094d839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc845a88dfffbbcd658bb30f10508ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#adfc845a88dfffbbcd658bb30f10508ad">prvSocketSetMSS</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:adfc845a88dfffbbcd658bb30f10508ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MSS (Maximum segment size) associated with the given socket.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#adfc845a88dfffbbcd658bb30f10508ad">More...</a><br /></td></tr>
<tr class="separator:adfc845a88dfffbbcd658bb30f10508ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2785c9db86dfb1f5f6b01155ddd54e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ac2785c9db86dfb1f5f6b01155ddd54e0">prvHandleListen</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer)</td></tr>
<tr class="memdesc:ac2785c9db86dfb1f5f6b01155ddd54e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle 'listen' event on the given socket.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ac2785c9db86dfb1f5f6b01155ddd54e0">More...</a><br /></td></tr>
<tr class="separator:ac2785c9db86dfb1f5f6b01155ddd54e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01e793e6003047552ed3f542f0a66ff"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#af01e793e6003047552ed3f542f0a66ff">prvTCPSocketCopy</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxNewSocket, <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:af01e793e6003047552ed3f542f0a66ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a socket after a listening socket receives a connection and bind the new socket to the same port as the listening socket. Also, let the new socket inherit all properties from the listening socket.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#af01e793e6003047552ed3f542f0a66ff">More...</a><br /></td></tr>
<tr class="separator:af01e793e6003047552ed3f542f0a66ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42a8368c193b45516ebc2082c8c6ea3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ad42a8368c193b45516ebc2082c8c6ea3">prvTCPBufferResize</a> (const <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxNetworkBuffer, int32_t lDataLen, UBaseType_t uxOptionsLength)</td></tr>
<tr class="memdesc:ad42a8368c193b45516ebc2082c8c6ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the size of a network buffer is big enough to hold the outgoing message. Allocate a new bigger network buffer when necessary.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#ad42a8368c193b45516ebc2082c8c6ea3">More...</a><br /></td></tr>
<tr class="separator:ad42a8368c193b45516ebc2082c8c6ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3d321465a45d65a96c7762cd5a8612"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aed3d321465a45d65a96c7762cd5a8612">prvWinScaleFactor</a> (const <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:aed3d321465a45d65a96c7762cd5a8612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the window scaling factor for the TCP connection.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#aed3d321465a45d65a96c7762cd5a8612">More...</a><br /></td></tr>
<tr class="separator:aed3d321465a45d65a96c7762cd5a8612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0ad2de00346e1017a692e4da7c3f0c"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a6f0ad2de00346e1017a692e4da7c3f0c">xTCPSocketCheck</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:a6f0ad2de00346e1017a692e4da7c3f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">As soon as a TCP socket timer expires, this function will be called (from xTCPTimerCheck). It can send a delayed ACK or new data.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a6f0ad2de00346e1017a692e4da7c3f0c">More...</a><br /></td></tr>
<tr class="separator:a6f0ad2de00346e1017a692e4da7c3f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d34454b4f1d4b0a4f5e5b998fdf578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a97d34454b4f1d4b0a4f5e5b998fdf578">vTCPStateChange</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket, enum eTCP_STATE eTCPState)</td></tr>
<tr class="memdesc:a97d34454b4f1d4b0a4f5e5b998fdf578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing to a new state. Centralised here to do specific actions such as resetting the alive timer, calling the user's OnConnect handler to notify that a socket has got (dis)connected, and setting bit to unblock a call to <a class="el" href="_free_r_t_o_s___sockets_8c.html#a659a570c1f1b5a11c17d816cb5541291" title="The select() statement: wait for an event to occur on any of the sockets included in a socket set.">FreeRTOS_select()</a>.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a97d34454b4f1d4b0a4f5e5b998fdf578">More...</a><br /></td></tr>
<tr class="separator:a97d34454b4f1d4b0a4f5e5b998fdf578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afd3312f86e44f4b4d95ab1e7bd34be"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a3afd3312f86e44f4b4d95ab1e7bd34be">xProcessReceivedTCPPacket</a> (<a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *pxDescriptor)</td></tr>
<tr class="memdesc:a3afd3312f86e44f4b4d95ab1e7bd34be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the received TCP packet.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#a3afd3312f86e44f4b4d95ab1e7bd34be">More...</a><br /></td></tr>
<tr class="separator:a3afd3312f86e44f4b4d95ab1e7bd34be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9d9857511e8c986d7eb52849cfe73d"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#abd9d9857511e8c986d7eb52849cfe73d">xTCPCheckNewClient</a> (<a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *pxSocket)</td></tr>
<tr class="memdesc:abd9d9857511e8c986d7eb52849cfe73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the API accept(), the user asks is there is a new client? As API's can not walk through the xBoundTCPSocketsList the IP-task will do this.  <a href="_free_r_t_o_s___t_c_p___i_p_8c.html#abd9d9857511e8c986d7eb52849cfe73d">More...</a><br /></td></tr>
<tr class="separator:abd9d9857511e8c986d7eb52849cfe73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Module which handles the TCP connections for FreeRTOS+TCP. It depends on <a class="el" href="_free_r_t_o_s___t_c_p___w_i_n_8c.html" title="Module which handles the TCP windowing schemes for FreeRTOS+TCP. Many functions have two versions - o...">FreeRTOS_TCP_WIN.c</a>, which handles the TCP windowing schemes. </p>
<p >Endianness: in this module all ports and IP addresses are stored in host byte-order, except fields in the IP-packets </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa23ea9f1090719d5fe63b05b916f8475" name="aa23ea9f1090719d5fe63b05b916f8475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23ea9f1090719d5fe63b05b916f8475">&#9670;&nbsp;</a></span>tcpTCP_FLAG_FIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_FIN&#160;&#160;&#160;( ( uint8_t ) 0x01U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >No more data from sender. </p>

</div>
</div>
<a id="aab413c82652ca09af97361cf9477a47c" name="aab413c82652ca09af97361cf9477a47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab413c82652ca09af97361cf9477a47c">&#9670;&nbsp;</a></span>tcpTCP_FLAG_SYN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_SYN&#160;&#160;&#160;( ( uint8_t ) 0x02U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Synchronize sequence numbers. </p>

</div>
</div>
<a id="aeaca8c0103423aaab32d151387adee18" name="aeaca8c0103423aaab32d151387adee18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaca8c0103423aaab32d151387adee18">&#9670;&nbsp;</a></span>tcpTCP_FLAG_RST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_RST&#160;&#160;&#160;( ( uint8_t ) 0x04U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reset the connection. </p>

</div>
</div>
<a id="a71daac922d12e3e3ff760fbfc7db8875" name="a71daac922d12e3e3ff760fbfc7db8875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71daac922d12e3e3ff760fbfc7db8875">&#9670;&nbsp;</a></span>tcpTCP_FLAG_PSH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_PSH&#160;&#160;&#160;( ( uint8_t ) 0x08U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Push function: please push buffered data to the recv application. </p>

</div>
</div>
<a id="a96dee2ad910b9b2121318ab0a22291dd" name="a96dee2ad910b9b2121318ab0a22291dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dee2ad910b9b2121318ab0a22291dd">&#9670;&nbsp;</a></span>tcpTCP_FLAG_ACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_ACK&#160;&#160;&#160;( ( uint8_t ) 0x10U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Acknowledgment field is significant. </p>

</div>
</div>
<a id="a0cecc71bb9663461bbcdd14e1cca10b0" name="a0cecc71bb9663461bbcdd14e1cca10b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cecc71bb9663461bbcdd14e1cca10b0">&#9670;&nbsp;</a></span>tcpTCP_FLAG_URG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_URG&#160;&#160;&#160;( ( uint8_t ) 0x20U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Urgent pointer field is significant. </p>

</div>
</div>
<a id="a9bd4fe51b7e508a123941990ff10ffee" name="a9bd4fe51b7e508a123941990ff10ffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd4fe51b7e508a123941990ff10ffee">&#9670;&nbsp;</a></span>tcpTCP_FLAG_ECN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_ECN&#160;&#160;&#160;( ( uint8_t ) 0x40U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ECN-Echo. </p>

</div>
</div>
<a id="aa88c66473fde8218a9e885b645e41a13" name="aa88c66473fde8218a9e885b645e41a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88c66473fde8218a9e885b645e41a13">&#9670;&nbsp;</a></span>tcpTCP_FLAG_CWR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_CWR&#160;&#160;&#160;( ( uint8_t ) 0x80U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Congestion Window Reduced. </p>

</div>
</div>
<a id="ac11f82b0e649e5d88a6a1196b08b401d" name="ac11f82b0e649e5d88a6a1196b08b401d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11f82b0e649e5d88a6a1196b08b401d">&#9670;&nbsp;</a></span>tcpTCP_FLAG_CTRL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_FLAG_CTRL&#160;&#160;&#160;( ( uint8_t ) 0x1FU )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A mask to filter all protocol flags. </p>

</div>
</div>
<a id="a0bba2554431f5b7fda5d97d222ef9786" name="a0bba2554431f5b7fda5d97d222ef9786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bba2554431f5b7fda5d97d222ef9786">&#9670;&nbsp;</a></span>tcpTCP_OPT_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_END&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >End of TCP options list. </p>

</div>
</div>
<a id="a0fdf7f0c704090fc5e0439f993a40f8f" name="a0fdf7f0c704090fc5e0439f993a40f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdf7f0c704090fc5e0439f993a40f8f">&#9670;&nbsp;</a></span>tcpTCP_OPT_NOOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_NOOP&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >"No-operation" TCP option. </p>

</div>
</div>
<a id="a1ca14d2b8c5971642e2d2645c492cc2a" name="a1ca14d2b8c5971642e2d2645c492cc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca14d2b8c5971642e2d2645c492cc2a">&#9670;&nbsp;</a></span>tcpTCP_OPT_MSS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_MSS&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Maximum segment size TCP option. </p>

</div>
</div>
<a id="a7fd42af6084ca092b20953b996f39719" name="a7fd42af6084ca092b20953b996f39719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd42af6084ca092b20953b996f39719">&#9670;&nbsp;</a></span>tcpTCP_OPT_WSOPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_WSOPT&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >TCP Window Scale Option (3-byte long). </p>

</div>
</div>
<a id="a7cecfff8a8e16e2059268c16af8f5615" name="a7cecfff8a8e16e2059268c16af8f5615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cecfff8a8e16e2059268c16af8f5615">&#9670;&nbsp;</a></span>tcpTCP_OPT_SACK_P</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_SACK_P&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Advertise that SACK is permitted. </p>

</div>
</div>
<a id="adc66468782cc29eb6ce182a07b2d11d6" name="adc66468782cc29eb6ce182a07b2d11d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc66468782cc29eb6ce182a07b2d11d6">&#9670;&nbsp;</a></span>tcpTCP_OPT_SACK_A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_SACK_A&#160;&#160;&#160;5U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >SACK option with first/last. </p>

</div>
</div>
<a id="a7fedb3a976274f11461a300b2d9568e6" name="a7fedb3a976274f11461a300b2d9568e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fedb3a976274f11461a300b2d9568e6">&#9670;&nbsp;</a></span>tcpTCP_OPT_TIMESTAMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_TIMESTAMP&#160;&#160;&#160;8U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Time-stamp option. </p>

</div>
</div>
<a id="a0d7cfb33a05d29167808c7c7a093d5bf" name="a0d7cfb33a05d29167808c7c7a093d5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7cfb33a05d29167808c7c7a093d5bf">&#9670;&nbsp;</a></span>tcpTCP_OPT_MSS_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_MSS_LEN&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Length of TCP MSS option. </p>

</div>
</div>
<a id="a3fe51ca2c0ca39f68c207456152fad2e" name="a3fe51ca2c0ca39f68c207456152fad2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe51ca2c0ca39f68c207456152fad2e">&#9670;&nbsp;</a></span>tcpTCP_OPT_WSOPT_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_WSOPT_LEN&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Length of TCP WSOPT option. </p>

</div>
</div>
<a id="ad565b934d8982b674a926eefa85481fb" name="ad565b934d8982b674a926eefa85481fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad565b934d8982b674a926eefa85481fb">&#9670;&nbsp;</a></span>tcpTCP_OPT_TIMESTAMP_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OPT_TIMESTAMP_LEN&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >fixed length of the time-stamp option. </p>

</div>
</div>
<a id="ab2443d4b4e820eba87abb0cc920cccff" name="ab2443d4b4e820eba87abb0cc920cccff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2443d4b4e820eba87abb0cc920cccff">&#9670;&nbsp;</a></span>ipconfigTCP_ACK_EARLIER_PACKET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipconfigTCP_ACK_EARLIER_PACKET&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Acknowledge an earlier packet. </p>

</div>
</div>
<a id="ae3395a76923220eca4221c12dff07d3e" name="ae3395a76923220eca4221c12dff07d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3395a76923220eca4221c12dff07d3e">&#9670;&nbsp;</a></span>tcpDELAYED_ACK_SHORT_DELAY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpDELAYED_ACK_SHORT_DELAY_MS&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Should not become smaller than 1. </p>

</div>
</div>
<a id="a2813bcb2476a861459453422d1960008" name="a2813bcb2476a861459453422d1960008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2813bcb2476a861459453422d1960008">&#9670;&nbsp;</a></span>tcpDELAYED_ACK_LONGER_DELAY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpDELAYED_ACK_LONGER_DELAY_MS&#160;&#160;&#160;( 20 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Longer delay for ACK. </p>

</div>
</div>
<a id="ae9e28e136632b3bc7881c2ef87e966c2" name="ae9e28e136632b3bc7881c2ef87e966c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e28e136632b3bc7881c2ef87e966c2">&#9670;&nbsp;</a></span>tcpTCP_OFFSET_STANDARD_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcpTCP_OFFSET_STANDARD_LENGTH&#160;&#160;&#160;( 0x50U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Standard TCP packet offset. </p>

</div>
</div>
<a id="a688a156ac82e335f6acb73564af691e7" name="a688a156ac82e335f6acb73564af691e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688a156ac82e335f6acb73564af691e7">&#9670;&nbsp;</a></span>xIPHeaderSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xIPHeaderSize</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pxNetworkBuffer</td><td>)</td>
          <td>&#160;&#160;&#160;( ipSIZE_OF_IPv4_HEADER )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Size of IP Header. </p>

</div>
</div>
<a id="a8136ac000e6a04d5f098cd691ac1a14b" name="a8136ac000e6a04d5f098cd691ac1a14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8136ac000e6a04d5f098cd691ac1a14b">&#9670;&nbsp;</a></span>uxIPHeaderSizeSocket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define uxIPHeaderSizeSocket</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pxSocket</td><td>)</td>
          <td>&#160;&#160;&#160;( ipSIZE_OF_IPv4_HEADER )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Size of IP Header socket. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a074e94106db91d94f21c0580affde782" name="a074e94106db91d94f21c0580affde782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074e94106db91d94f21c0580affde782">&#9670;&nbsp;</a></span>prvTCPSocketIsActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPSocketIsActive </td>
          <td>(</td>
          <td class="paramtype">eIPTCPState_t&#160;</td>
          <td class="paramname"><em>xStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the socket is active or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xStatus</td><td>The status of the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the socket must be checked. Non-active sockets are waiting for user action, either connect() or close(). </dd></dl>

</div>
</div>
<a id="abfb9df3f6539966ec17c4752cd99e035" name="abfb9df3f6539966ec17c4752cd99e035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb9df3f6539966ec17c4752cd99e035">&#9670;&nbsp;</a></span>prvTCPSendPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t prvTCPSendPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#abfb9df3f6539966ec17c4752cd99e035" title="prvTCPSendPacket() will be called when the socket time-out has been reached.">prvTCPSendPacket()</a> will be called when the socket time-out has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes to be sent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is only called by <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a6f0ad2de00346e1017a692e4da7c3f0c" title="As soon as a TCP socket timer expires, this function will be called (from xTCPTimerCheck)....">xTCPSocketCheck()</a>. </dd></dl>

</div>
</div>
<a id="ae55092c8fe479837a69c29167b5e16ae" name="ae55092c8fe479837a69c29167b5e16ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55092c8fe479837a69c29167b5e16ae">&#9670;&nbsp;</a></span>prvTCPSendRepeated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t prvTCPSendRepeated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prvTCPSendRepeated will try to send a series of messages, as long as there is data to be sent and as long as the transmit window isn't full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxNetworkBuffer</td><td>Pointer to pointer to the network buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes sent. </dd></dl>

</div>
</div>
<a id="a90c3299ce1b59128557449658e170da3" name="a90c3299ce1b59128557449658e170da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c3299ce1b59128557449658e170da3">&#9670;&nbsp;</a></span>prvTCPReturnPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvTCPReturnPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xReleaseAfterSend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a real network buffer or to a TCP socket field called 'xTCP.xPacket'. A temporary xNetworkBuffer will be used to pass the data to the NIC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxDescriptor</td><td>The network buffer descriptor carrying the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulLen</td><td>Length of the packet being sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xReleaseAfterSend</td><td>pdTRUE if the ownership of the descriptor is transferred to the network interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486e0a50c3dc44834ee585ed9c62766b" name="a486e0a50c3dc44834ee585ed9c62766b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486e0a50c3dc44834ee585ed9c62766b">&#9670;&nbsp;</a></span>prvTCPCreateWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvTCPCreateWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the TCP window for the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket for which the window is being created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The SYN event is very important: the sequence numbers, which have a kind of random starting value, are being synchronized. The sliding window manager (in <a class="el" href="_free_r_t_o_s___t_c_p___w_i_n_8c.html" title="Module which handles the TCP windowing schemes for FreeRTOS+TCP. Many functions have two versions - o...">FreeRTOS_TCP_WIN.c</a>) needs to know them, along with the Maximum Segment Size (MSS). </dd></dl>

</div>
</div>
<a id="a259d393932637c52fd7e1eb22c10b3c6" name="a259d393932637c52fd7e1eb22c10b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259d393932637c52fd7e1eb22c10b3c6">&#9670;&nbsp;</a></span>prvTCPPrepareConnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPPrepareConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let ARP look-up the MAC-address of the peer and initialise the first SYN packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the TCP connection. The first packet shall be created in this socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE: if the packet was successfully created and the first SYN can be sent. Else pdFALSE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Connecting sockets have a special state: eCONNECT_SYN. In this phase, the Ethernet address of the target will be found using ARP. In case the target IP address is not within the netmask, the hardware address of the gateway will be used. </dd></dl>

</div>
</div>
<a id="aaa4372b4f0f440715d288b7fd5681be3" name="aaa4372b4f0f440715d288b7fd5681be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4372b4f0f440715d288b7fd5681be3">&#9670;&nbsp;</a></span>prvCheckOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_static void prvCheckOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the TCP option(s) received, if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket handling the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer containing the TCP packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It has already been verified that: ((pxTCPHeader-&gt;ucTCPOffset &amp; 0xf0) &gt; 0x50), meaning that the TP header is longer than the usual 20 (5 x 4) bytes. </dd></dl>

</div>
</div>
<a id="a8f5ccd90ad6e056252cbde7d34c9bda0" name="a8f5ccd90ad6e056252cbde7d34c9bda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5ccd90ad6e056252cbde7d34c9bda0">&#9670;&nbsp;</a></span>prvSingleStepTCPHeaderOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_static size_t prvSingleStepTCPHeaderOptions </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>pucPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxTotalLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *const&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xHasSYNFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify and deal with a single TCP header option, advancing the pointer to the header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucPtr</td><td>Pointer to the TCP packet options. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxTotalLength</td><td>Length of the TCP packet options. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>Socket handling the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xHasSYNFlag</td><td>Whether the header has SYN flag or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns pdTRUE or pdFALSE depending on whether the caller should continue to parse more header options or break the loop. </dd></dl>

</div>
</div>
<a id="a5bd3ea49e8ee6f2c7a12bb2708575d88" name="a5bd3ea49e8ee6f2c7a12bb2708575d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd3ea49e8ee6f2c7a12bb2708575d88">&#9670;&nbsp;</a></span>prvReadSackOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_static void prvReadSackOption </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>pucPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *const&#160;</td>
          <td class="paramname"><em>pxSocket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip past TCP header options when doing Selective ACK, until there are no more options left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucPtr</td><td>Pointer to the TCP packet options. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIndex</td><td>Index of options in the TCP packet options. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>Socket handling the TCP connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ffa471bf4c769535d3f7b9d5a968cdb" name="a0ffa471bf4c769535d3f7b9d5a968cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffa471bf4c769535d3f7b9d5a968cdb">&#9670;&nbsp;</a></span>prvSetSynAckOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static UBaseType_t prvSetSynAckOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCPHeader_t *&#160;</td>
          <td class="paramname"><em>pxTCPHeader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When opening a TCP connection, while SYN's are being sent, the parties may communicate what MSS (Maximum Segment Size) they intend to use, whether Selective ACK's ( SACK ) are supported, and the size of the reception window ( WSOPT ). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket being used for communication. It is used to set the MSS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pxTCPHeader</td><td>The TCP packet header being used in the SYN transmission. The MSS and corresponding options shall be set in this header itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The option length after the TCP header was updated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>MSS is the net size of the payload, an is always smaller than MTU. </dd></dl>

</div>
</div>
<a id="af1e47864a5591d814aa9baf281c20cd5" name="af1e47864a5591d814aa9baf281c20cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e47864a5591d814aa9baf281c20cd5">&#9670;&nbsp;</a></span>prvTCPTouchSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvTCPTouchSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Touch' the socket to keep it alive/updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket to be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is used for anti-hanging protection and TCP keep-alive messages. Called in two places: after receiving a packet and after a state change. The socket's alive timer may be reset. </dd></dl>

</div>
</div>
<a id="a03f032b5eef69f4f6a2ba16a2c516954" name="a03f032b5eef69f4f6a2ba16a2c516954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f032b5eef69f4f6a2ba16a2c516954">&#9670;&nbsp;</a></span>prvTCPPrepareSend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t prvTCPPrepareSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxOptionsLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare an outgoing message, in case anything has to be sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxNetworkBuffer</td><td>Pointer to the pointer to the network buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOptionsLength</td><td>The length of the TCP options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the data to be sent if everything is correct. Else, -1 is returned in case of any error. </dd></dl>

</div>
</div>
<a id="ae80be66ff5dea32208cc3303072fbfa3" name="ae80be66ff5dea32208cc3303072fbfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80be66ff5dea32208cc3303072fbfa3">&#9670;&nbsp;</a></span>prvTCPNextTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TickType_t prvTCPNextTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate after how much time this socket needs to be checked again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of clock ticks before the timer expires. </dd></dl>

</div>
</div>
<a id="a5c3b5073967e63a162c6fd13dc9b2a45" name="a5c3b5073967e63a162c6fd13dc9b2a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3b5073967e63a162c6fd13dc9b2a45">&#9670;&nbsp;</a></span>prvTCPAddTxData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvTCPAddTxData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The API <a class="el" href="_free_r_t_o_s___sockets_8c.html#abfb04a35d27c55380be674ebd8204351" title="Send data using a TCP socket. It is not necessary to have the socket connected already....">FreeRTOS_send()</a> adds data to the TX stream. Add this data to the windowing system to it can be transmitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed19306eb74e28863615dd7be8e2e1a7" name="aed19306eb74e28863615dd7be8e2e1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed19306eb74e28863615dd7be8e2e1a7">&#9670;&nbsp;</a></span>prvTCPHandleFin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPHandleFin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#aed19306eb74e28863615dd7be8e2e1a7" title="prvTCPHandleFin() will be called to handle connection closure. The closure starts when either a FIN h...">prvTCPHandleFin()</a> will be called to handle connection closure. The closure starts when either a FIN has been received and accepted, or when the socket has sent a FIN flag to the peer. Before being called, it has been checked that both reception and transmission are complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>Socket owning the the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer carrying the TCP packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the packet to be sent. </dd></dl>

</div>
</div>
<a id="a5273259449f802266c3c5a8d0ef03389" name="a5273259449f802266c3c5a8d0ef03389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5273259449f802266c3c5a8d0ef03389">&#9670;&nbsp;</a></span>prvCheckRxData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvCheckRxData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>ppucRecvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a5273259449f802266c3c5a8d0ef03389" title="prvCheckRxData(): called from prvTCPHandleState(). The first thing that will be done is find the TCP ...">prvCheckRxData()</a>: called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. The first thing that will be done is find the TCP payload data and check the length of this data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer holding the received data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppucRecvData</td><td>It will point to first byte of the TCP payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the received buffer. </dd></dl>

</div>
</div>
<a id="a918dc39521690f49ba16c2ed9deacf4e" name="a918dc39521690f49ba16c2ed9deacf4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918dc39521690f49ba16c2ed9deacf4e">&#9670;&nbsp;</a></span>prvStoreRxData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvStoreRxData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucRecvData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulReceiveLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a918dc39521690f49ba16c2ed9deacf4e" title="prvStoreRxData(): called from prvTCPHandleState(). The second thing is to do is check if the payload ...">prvStoreRxData()</a>: called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. The second thing is to do is check if the payload data may be accepted. If so, they will be added to the reception queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pucRecvData</td><td>Pointer to received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulReceiveLength</td><td>The length of the received data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure of storing data. </dd></dl>

</div>
</div>
<a id="a2f106d9f19f8c57b3b851fb77eab9445" name="a2f106d9f19f8c57b3b851fb77eab9445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f106d9f19f8c57b3b851fb77eab9445">&#9670;&nbsp;</a></span>prvSetOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static UBaseType_t prvSetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the TCP options (if any) for the outgoing packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer holding the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the TCP options after they are set. </dd></dl>

</div>
</div>
<a id="a38bfd1b31c5ec1532040b5c728b52222" name="a38bfd1b31c5ec1532040b5c728b52222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bfd1b31c5ec1532040b5c728b52222">&#9670;&nbsp;</a></span>prvHandleSynReceived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvHandleSynReceived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulReceiveLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxOptionsLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a38bfd1b31c5ec1532040b5c728b52222" title="prvHandleSynReceived(): called from prvTCPHandleState(). Called from the states: eSYN_RECEIVED and eC...">prvHandleSynReceived()</a>: called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. Called from the states: eSYN_RECEIVED and eCONNECT_SYN. If the flags received are correct, the socket will move to eESTABLISHED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket handling the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The pointer to the network buffer carrying the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulReceiveLength</td><td>Length in bytes of the data received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOptionsLength</td><td>Length of the TCP options in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the data to be sent. </dd></dl>

</div>
</div>
<a id="a321329a25c8f6de7856bec44678d6326" name="a321329a25c8f6de7856bec44678d6326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321329a25c8f6de7856bec44678d6326">&#9670;&nbsp;</a></span>prvHandleEstablished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvHandleEstablished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulReceiveLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxOptionsLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a321329a25c8f6de7856bec44678d6326" title="prvHandleEstablished(): called from prvTCPHandleState() Called if the status is eESTABLISHED....">prvHandleEstablished()</a>: called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a> Called if the status is eESTABLISHED. Data reception has been handled earlier. Here the ACK's from peer will be checked, and if a FIN is received, the code will check if it may be accepted, i.e. if all expected data has been completely received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxNetworkBuffer</td><td>Pointer to pointer to the network buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulReceiveLength</td><td>The length of the received packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOptionsLength</td><td>Length of TCP options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The send length of the packet to be sent. </dd></dl>

</div>
</div>
<a id="ad48f7b6332e810a14c8269f17775ea10" name="ad48f7b6332e810a14c8269f17775ea10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48f7b6332e810a14c8269f17775ea10">&#9670;&nbsp;</a></span>prvSendData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvSendData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulReceiveLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. There is data to be sent. If ipconfigUSE_TCP_WIN is defined, and if only an ACK must be sent, it will be checked if it would better be postponed for efficiency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the TCP connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ppxNetworkBuffer</td><td>Pointer to pointer to the network buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulReceiveLength</td><td>The length of the received buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xByteCount</td><td>Length of the data to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually sent. </dd></dl>

</div>
</div>
<a id="a396f3542839fd1e377e333918afd81a4" name="a396f3542839fd1e377e333918afd81a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396f3542839fd1e377e333918afd81a4">&#9670;&nbsp;</a></span>prvTCPHandleState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPHandleState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check incoming packets for valid data and handle the state of the TCP connection and respond according to the situation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket whose connection state is being handled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ppxNetworkBuffer</td><td>The network buffer descriptor holding the packet received from the peer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the data is correct and some packet was sent to the peer, then the number of bytes sent is returned, or else a negative value is returned indicating an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a> is the most important function of this TCP stack We've tried to keep it (relatively short) by putting a lot of code in the static functions above: <pre class="fragment"> prvCheckRxData()
 prvStoreRxData()
 prvSetOptions()
 prvHandleSynReceived()
 prvHandleEstablished()
 prvSendData()
</pre> As these functions are declared static, and they're called from one location only, most compilers will inline them, thus avoiding a call and return. </dd></dl>

</div>
</div>
<a id="a1f06e746cb1cfac5d3e8c5a9465ba950" name="a1f06e746cb1cfac5d3e8c5a9465ba950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f06e746cb1cfac5d3e8c5a9465ba950">&#9670;&nbsp;</a></span>prvTCPSendSpecialPacketHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPSendSpecialPacketHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTCPFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common code for sending a TCP protocol control packet (i.e. no options, no payload, just flags). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer received from the peer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTCPFlags</td><td>The flags to determine what kind of packet this is.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL always indicating that the packet was not consumed. </dd></dl>

</div>
</div>
<a id="abd027c2104ce7522015fe84d02681516" name="abd027c2104ce7522015fe84d02681516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd027c2104ce7522015fe84d02681516">&#9670;&nbsp;</a></span>prvTCPSendChallengeAck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPSendChallengeAck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A "challenge ACK" is as per <a href="https://tools.ietf.org/html/rfc5961#section-3.2">https://tools.ietf.org/html/rfc5961#section-3.2</a>, case #3. In summary, an RST was received with a sequence number that is unexpected but still within the window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer descriptor with the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value back from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a1f06e746cb1cfac5d3e8c5a9465ba950" title="Common code for sending a TCP protocol control packet (i.e. no options, no payload,...">prvTCPSendSpecialPacketHelper</a>. </dd></dl>

</div>
</div>
<a id="ac7a1dc6f7c485315189b8b0f3094d839" name="ac7a1dc6f7c485315189b8b0f3094d839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a1dc6f7c485315189b8b0f3094d839">&#9670;&nbsp;</a></span>prvTCPSendReset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPSendReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a RST (Reset) to peer in case the packet cannot be handled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer descriptor with the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value back from <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a1f06e746cb1cfac5d3e8c5a9465ba950" title="Common code for sending a TCP protocol control packet (i.e. no options, no payload,...">prvTCPSendSpecialPacketHelper</a>. </dd></dl>

</div>
</div>
<a id="adfc845a88dfffbbcd658bb30f10508ad" name="adfc845a88dfffbbcd658bb30f10508ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc845a88dfffbbcd658bb30f10508ad">&#9670;&nbsp;</a></span>prvSocketSetMSS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvSocketSetMSS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the MSS (Maximum segment size) associated with the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket whose MSS is to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2785c9db86dfb1f5f6b01155ddd54e0" name="ac2785c9db86dfb1f5f6b01155ddd54e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2785c9db86dfb1f5f6b01155ddd54e0">&#9670;&nbsp;</a></span>prvHandleListen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> * prvHandleListen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle 'listen' event on the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket on which the listen occurred. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer carrying the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a new socket/duplicate socket is created, then the pointer to that socket is returned or else, a NULL pointer is returned. </dd></dl>

</div>
</div>
<a id="af01e793e6003047552ed3f542f0a66ff" name="af01e793e6003047552ed3f542f0a66ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01e793e6003047552ed3f542f0a66ff">&#9670;&nbsp;</a></span>prvTCPSocketCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPSocketCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxNewSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates a socket after a listening socket receives a connection and bind the new socket to the same port as the listening socket. Also, let the new socket inherit all properties from the listening socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNewSocket</td><td>Pointer to the new socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>Pointer to the socket being duplicated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If all steps all successful, then pdTRUE is returned. Else, pdFALSE. </dd></dl>

</div>
</div>
<a id="ad42a8368c193b45516ebc2082c8c6ea3" name="ad42a8368c193b45516ebc2082c8c6ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42a8368c193b45516ebc2082c8c6ea3">&#9670;&nbsp;</a></span>prvTCPBufferResize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> * prvTCPBufferResize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxOptionsLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the size of a network buffer is big enough to hold the outgoing message. Allocate a new bigger network buffer when necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>Socket whose buffer is being resized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer whose size is being increased. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lDataLen</td><td>Length of the data to be put in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOptionsLength</td><td>Length of options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the resizing is successful: The new buffer with the size being asked for with old data copied in it. Else, NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The old network buffer will be released if the resizing is successful and cannot be used any longer. </dd></dl>

</div>
</div>
<a id="aed3d321465a45d65a96c7762cd5a8612" name="aed3d321465a45d65a96c7762cd5a8612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3d321465a45d65a96c7762cd5a8612">&#9670;&nbsp;</a></span>prvWinScaleFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t prvWinScaleFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the window scaling factor for the TCP connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the TCP connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaling factor. </dd></dl>

</div>
</div>
<a id="a6f0ad2de00346e1017a692e4da7c3f0c" name="a6f0ad2de00346e1017a692e4da7c3f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0ad2de00346e1017a692e4da7c3f0c">&#9670;&nbsp;</a></span>xTCPSocketCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xTCPSocketCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As soon as a TCP socket timer expires, this function will be called (from xTCPTimerCheck). It can send a delayed ACK or new data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>socket to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code on failure. A negative value will be returned in case the hang-protection has put the socket in a wait-close state.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sequence of calling (normally) : IP-Task: <a class="el" href="_free_r_t_o_s___sockets_8c.html#ad3802e1a3603f571bcb185f2afbd48de" title="A TCP timer has expired, now check all TCP sockets for:">xTCPTimerCheck()</a> // Check all sockets ( declared in <a class="el" href="_free_r_t_o_s___sockets_8c.html" title="Implements the Sockets API based on Berkeley sockets for the FreeRTOS+TCP network stack....">FreeRTOS_Sockets.c</a> ) <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a6f0ad2de00346e1017a692e4da7c3f0c" title="As soon as a TCP socket timer expires, this function will be called (from xTCPTimerCheck)....">xTCPSocketCheck()</a> // Either send a delayed ACK or call <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#abfb9df3f6539966ec17c4752cd99e035" title="prvTCPSendPacket() will be called when the socket time-out has been reached.">prvTCPSendPacket()</a> <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#abfb9df3f6539966ec17c4752cd99e035" title="prvTCPSendPacket() will be called when the socket time-out has been reached.">prvTCPSendPacket()</a> // Either send a SYN or call prvTCPSendRepeated ( regular messages ) <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae55092c8fe479837a69c29167b5e16ae" title="prvTCPSendRepeated will try to send a series of messages, as long as there is data to be sent and as ...">prvTCPSendRepeated()</a> // Send at most 8 messages on a row <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a90c3299ce1b59128557449658e170da3" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a> // Prepare for returning xNetworkInterfaceOutput() // Sends data to the NIC ( declared in portable/NetworkInterface/xxx ) </dd></dl>

</div>
</div>
<a id="a97d34454b4f1d4b0a4f5e5b998fdf578" name="a97d34454b4f1d4b0a4f5e5b998fdf578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d34454b4f1d4b0a4f5e5b998fdf578">&#9670;&nbsp;</a></span>vTCPStateChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vTCPStateChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum eTCP_STATE&#160;</td>
          <td class="paramname"><em>eTCPState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changing to a new state. Centralised here to do specific actions such as resetting the alive timer, calling the user's OnConnect handler to notify that a socket has got (dis)connected, and setting bit to unblock a call to <a class="el" href="_free_r_t_o_s___sockets_8c.html#a659a570c1f1b5a11c17d816cb5541291" title="The select() statement: wait for an event to occur on any of the sockets included in a socket set.">FreeRTOS_select()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket whose state we are trying to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eTCPState</td><td>The state to which we want to change to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3afd3312f86e44f4b4d95ab1e7bd34be" name="a3afd3312f86e44f4b4d95ab1e7bd34be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afd3312f86e44f4b4d95ab1e7bd34be">&#9670;&nbsp;</a></span>xProcessReceivedTCPPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xProcessReceivedTCPPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_network_buffer_descriptor__t.html">NetworkBufferDescriptor_t</a> *&#160;</td>
          <td class="paramname"><em>pxDescriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the received TCP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxDescriptor</td><td>The descriptor in which the TCP packet is held.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the processing of the packet was successful, then pdPASS is returned or else pdFAIL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>FreeRTOS_TCP_IP has only 2 public functions, this is the second one: <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a3afd3312f86e44f4b4d95ab1e7bd34be" title="Process the received TCP packet.">xProcessReceivedTCPPacket()</a> <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a396f3542839fd1e377e333918afd81a4" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a> <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a03f032b5eef69f4f6a2ba16a2c516954" title="Prepare an outgoing message, in case anything has to be sent.">prvTCPPrepareSend()</a> <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a90c3299ce1b59128557449658e170da3" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a> xNetworkInterfaceOutput() // Sends data to the NIC <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ae55092c8fe479837a69c29167b5e16ae" title="prvTCPSendRepeated will try to send a series of messages, as long as there is data to be sent and as ...">prvTCPSendRepeated()</a> <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a90c3299ce1b59128557449658e170da3" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a> // Prepare for returning xNetworkInterfaceOutput() // Sends data to the NIC </dd></dl>

</div>
</div>
<a id="abd9d9857511e8c986d7eb52849cfe73d" name="abd9d9857511e8c986d7eb52849cfe73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9d9857511e8c986d7eb52849cfe73d">&#9670;&nbsp;</a></span>xTCPCheckNewClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xTCPCheckNewClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_free_r_t_o_s___socket__t.html">FreeRTOS_Socket_t</a> *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the API accept(), the user asks is there is a new client? As API's can not walk through the xBoundTCPSocketsList the IP-task will do this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket for which the bound socket list will be iterated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if there is a new client, then pdTRUE is returned or else, pdFALSE. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html">FreeRTOS_TCP_IP.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
