<!-- This file provides the custom header for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.14"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
        Common I/O: iot_adc.h File Reference
    </title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="foobar.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
    <tbody>
        <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">
                    <span id="afrprefix">FreeRTOS:</span>
                    Common I/O
                </div>
                <div id="projectbrief">
                    AWS IoT Common I/O library
                </div>
            </td>
        </tr>
        <tr>
            <td id="returntomain">
                <a href="../index.html">Return to main page &uarr;</a>
            </td>
        </tr>
    </tbody>
    </table>
    </div>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<!-- end header part --><!-- Generated by Doxygen 1.8.14 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('iot__adc_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">iot_adc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>File for the HAL APIs of ADC called by application layer.  
<a href="#details">More...</a></p>

<p><a href="iot__adc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_adc_config__t.html">IotAdcConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data structures for ioctl request  <a href="struct_iot_adc_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_adc_ch_status__t.html">IotAdcChStatus_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data structure for ioctl GetChStatus  <a href="struct_iot_adc_ch_status__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_adc_ch_buffer__t.html">IotAdcChBuffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data structure for ioctl SetChBuffer setting channel data buffer is optional using this ioctl if client doesn't pass in data buffer for driver to use, callback is triggered for every ADC sample to pass data back to client as driver doesn't have buffer to accumulate data. As soon as callback returns, xConverted_Data becomes invalid. On the other hand however if client does pass a buffer for driver to use, callback is triggered only after driver has filled buffer with xBufLen samples, client buffer is passed back in callback as XConverted_Data whose life span is controlled by the client even after callback returns.  <a href="struct_iot_adc_ch_buffer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_adc_chain__t.html">IotAdcChain_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some ADC host controller supports grouping multiple ADC channels into a chain. When the chain is triggered to sample ADC data, all ADC channels in the group are sampled in sequence so that client doesn't need to trigger each channel individually. Coverted ADC samples from such chain group can be passed back to the client with a single callback. This data structure is used for ioctl to define ADC chain setting.  <a href="struct_iot_adc_chain__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aba01db325e6bd3edba929aeb2643de60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#aba01db325e6bd3edba929aeb2643de60">IOT_ADC_SUCCESS</a>&#160;&#160;&#160;( 0 )</td></tr>
<tr class="memdesc:aba01db325e6bd3edba929aeb2643de60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error code returned by ADC driver.  <a href="#aba01db325e6bd3edba929aeb2643de60">More...</a><br /></td></tr>
<tr class="separator:aba01db325e6bd3edba929aeb2643de60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1016b7edb9e249cdee6b4a6f87f6f046"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a1016b7edb9e249cdee6b4a6f87f6f046">IOT_ADC_FAILED</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:a1016b7edb9e249cdee6b4a6f87f6f046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308933792f5a5743c99392447cb5c7d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a308933792f5a5743c99392447cb5c7d5">IOT_ADC_INVALID_VALUE</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="separator:a308933792f5a5743c99392447cb5c7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ac6ed2ffece2d0e0acbcfbaa827cfa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a92ac6ed2ffece2d0e0acbcfbaa827cfa">IOT_ADC_NOT_OPEN</a>&#160;&#160;&#160;( 3 )</td></tr>
<tr class="separator:a92ac6ed2ffece2d0e0acbcfbaa827cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f26c419bcd48255452baf502df4f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a0d1f26c419bcd48255452baf502df4f2">IOT_ADC_FUNCTION_NOT_SUPPORTED</a>&#160;&#160;&#160;( 4 )</td></tr>
<tr class="separator:a0d1f26c419bcd48255452baf502df4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbfbc918d3d2b92f0c9807d6b85e2ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a3bbfbc918d3d2b92f0c9807d6b85e2ec">IOT_ADC_CH_BUSY</a>&#160;&#160;&#160;( 5 )</td></tr>
<tr class="separator:a3bbfbc918d3d2b92f0c9807d6b85e2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92cdf1424eeebd0d6b46b3d2dc9976e7"><td class="memItemLeft" align="right" valign="top"><a id="a92cdf1424eeebd0d6b46b3d2dc9976e7"></a>
typedef struct IotAdcDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a></td></tr>
<tr class="memdesc:a92cdf1424eeebd0d6b46b3d2dc9976e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">IotAdcHandle_t is the handle type returned by calling <a class="el" href="iot__adc_8h.html#a864120f9515e3e82291750d96e1e1bc3" title="Initializes ADC controller with default configuration. init ADC controller, enable ADC clock...">iot_adc_open()</a>. This is initialized in open and returned to caller. The caller must pass this pointer to the rest of the ADC APIs. <br /></td></tr>
<tr class="separator:a92cdf1424eeebd0d6b46b3d2dc9976e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712a5807bddc87dab3136cc82bf856de"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a712a5807bddc87dab3136cc82bf856de">IotAdcCallback_t</a>) (uint16_t *pusConvertedData, void *pvUserContext)</td></tr>
<tr class="memdesc:a712a5807bddc87dab3136cc82bf856de"><td class="mdescLeft">&#160;</td><td class="mdescRight">adc notification callback type  <a href="#a712a5807bddc87dab3136cc82bf856de">More...</a><br /></td></tr>
<tr class="separator:a712a5807bddc87dab3136cc82bf856de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a637d786ac90af1e36e6d2569f7216050"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a637d786ac90af1e36e6d2569f7216050">IotAdcChState_t</a> { <a class="el" href="iot__adc_8h.html#a637d786ac90af1e36e6d2569f7216050a97a1b2e85321bed36bb91097f46a8659">eChStateIdle</a>, 
<a class="el" href="iot__adc_8h.html#a637d786ac90af1e36e6d2569f7216050ad8f4375e3be86371ee84379c07b0f8a9">eChStateBusy</a>
 }</td></tr>
<tr class="separator:a637d786ac90af1e36e6d2569f7216050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3455e4f78011b07d403d32259b0299c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299c">IotAdcIoctlRequest_t</a> { <br />
&#160;&#160;<a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299caff53edbaabe0507ab65dcbeeeaba036e">eSetAdcConfig</a>, 
<a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299ca2f01c7bbfcb0d922ee0f0aa2f7b5f94f">eGetAdcConfig</a>, 
<a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299ca07fb8f347c2d609d7888fe13d8b906be">eGetChStatus</a>, 
<a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299cac1b66abb20a822f8c4ab6827579d9689">eSetChBuffer</a>, 
<br />
&#160;&#160;<a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299ca7eaa6768969e1cddb48ac5cfaa224c4a">eSetAdcChain</a>
<br />
 }</td></tr>
<tr class="memdesc:ad3455e4f78011b07d403d32259b0299c"><td class="mdescLeft">&#160;</td><td class="mdescRight">adc ioctl request types.  <a href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299c">More...</a><br /></td></tr>
<tr class="separator:ad3455e4f78011b07d403d32259b0299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a864120f9515e3e82291750d96e1e1bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a864120f9515e3e82291750d96e1e1bc3">iot_adc_open</a> (int32_t lAdc)</td></tr>
<tr class="memdesc:a864120f9515e3e82291750d96e1e1bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes ADC controller with default configuration. init ADC controller, enable ADC clock, reset HW FIFO, set default configuration parameters, etc. Also allocate all required resources for ADC operation such as software data buffer etc.  <a href="#a864120f9515e3e82291750d96e1e1bc3">More...</a><br /></td></tr>
<tr class="separator:a864120f9515e3e82291750d96e1e1bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a729bdb2e47acb7a750caeb55e646eb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a6a729bdb2e47acb7a750caeb55e646eb">iot_adc_close</a> (<a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const pxAdc)</td></tr>
<tr class="memdesc:a6a729bdb2e47acb7a750caeb55e646eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close ADC controller. All pending operation will be cancelled, put ADC module in reset state or low power state if possible. Release all resources claimed during open call.  <a href="#a6a729bdb2e47acb7a750caeb55e646eb">More...</a><br /></td></tr>
<tr class="separator:a6a729bdb2e47acb7a750caeb55e646eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7640cc3ed7d0768dd9bf875c7e71c582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a7640cc3ed7d0768dd9bf875c7e71c582">iot_adc_set_callback</a> (<a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const pxAdc, uint8_t ucAdcChannel, <a class="el" href="iot__adc_8h.html#a712a5807bddc87dab3136cc82bf856de">IotAdcCallback_t</a> xAdcCallback, void *pvUserContext)</td></tr>
<tr class="memdesc:a7640cc3ed7d0768dd9bf875c7e71c582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets channel callback on availability of channel scan data. On availability of ADC scan data, the application is notified with a function callback. The callback function and user context for callback are set using iot_adc_set_callback.  <a href="#a7640cc3ed7d0768dd9bf875c7e71c582">More...</a><br /></td></tr>
<tr class="separator:a7640cc3ed7d0768dd9bf875c7e71c582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0e064b1b2618de067c1622d51e180b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a5e0e064b1b2618de067c1622d51e180b">iot_adc_start</a> (<a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const pxAdc, uint8_t ucAdcChannel)</td></tr>
<tr class="memdesc:a5e0e064b1b2618de067c1622d51e180b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start data acquisition for ADC channel until iot_adc_stop API is called. data will be passed back to client using callback function. by default each callback will pass back one data sample, however if client has used ioctl to pass in data buffer, only when buffer is full will callback be triggered.  <a href="#a5e0e064b1b2618de067c1622d51e180b">More...</a><br /></td></tr>
<tr class="separator:a5e0e064b1b2618de067c1622d51e180b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea645e9c4925b8581a5003ceacff3f0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#abea645e9c4925b8581a5003ceacff3f0">iot_adc_stop</a> (<a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const pxAdc, uint8_t ucAdcChannel)</td></tr>
<tr class="memdesc:abea645e9c4925b8581a5003ceacff3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop data acquisition for ADC channel.  <a href="#abea645e9c4925b8581a5003ceacff3f0">More...</a><br /></td></tr>
<tr class="separator:abea645e9c4925b8581a5003ceacff3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34af2256e01c221dd4e2bccb535377f7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#a34af2256e01c221dd4e2bccb535377f7">iot_adc_read_sample</a> (<a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const pxAdc, uint8_t ucAdcChannel, uint16_t *pusAdcSample)</td></tr>
<tr class="memdesc:a34af2256e01c221dd4e2bccb535377f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">read one ADC data sample. This API will return one ADC sample.  <a href="#a34af2256e01c221dd4e2bccb535377f7">More...</a><br /></td></tr>
<tr class="separator:a34af2256e01c221dd4e2bccb535377f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4de5a004233505d2b6e8d484e431e1f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="iot__adc_8h.html#ab4de5a004233505d2b6e8d484e431e1f">iot_adc_ioctl</a> (<a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const pxAdc, <a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299c">IotAdcIoctlRequest_t</a> xRequest, void *const pvBuffer)</td></tr>
<tr class="memdesc:ab4de5a004233505d2b6e8d484e431e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for various ADC control functions.  <a href="#ab4de5a004233505d2b6e8d484e431e1f">More...</a><br /></td></tr>
<tr class="separator:ab4de5a004233505d2b6e8d484e431e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>File for the HAL APIs of ADC called by application layer. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aba01db325e6bd3edba929aeb2643de60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba01db325e6bd3edba929aeb2643de60">&#9670;&nbsp;</a></span>IOT_ADC_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_ADC_SUCCESS&#160;&#160;&#160;( 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error code returned by ADC driver. </p>
<p>ADC operation completed successfully. </p>

</div>
</div>
<a id="a1016b7edb9e249cdee6b4a6f87f6f046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1016b7edb9e249cdee6b4a6f87f6f046">&#9670;&nbsp;</a></span>IOT_ADC_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_ADC_FAILED&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC operation failed. </p>

</div>
</div>
<a id="a308933792f5a5743c99392447cb5c7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308933792f5a5743c99392447cb5c7d5">&#9670;&nbsp;</a></span>IOT_ADC_INVALID_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_ADC_INVALID_VALUE&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>At least one parameter is invalid. </p>

</div>
</div>
<a id="a92ac6ed2ffece2d0e0acbcfbaa827cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ac6ed2ffece2d0e0acbcfbaa827cfa">&#9670;&nbsp;</a></span>IOT_ADC_NOT_OPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_ADC_NOT_OPEN&#160;&#160;&#160;( 3 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC operation not possible unless ADC instance is opened. </p>

</div>
</div>
<a id="a0d1f26c419bcd48255452baf502df4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1f26c419bcd48255452baf502df4f2">&#9670;&nbsp;</a></span>IOT_ADC_FUNCTION_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_ADC_FUNCTION_NOT_SUPPORTED&#160;&#160;&#160;( 4 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC operation not supported. </p>

</div>
</div>
<a id="a3bbfbc918d3d2b92f0c9807d6b85e2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbfbc918d3d2b92f0c9807d6b85e2ec">&#9670;&nbsp;</a></span>IOT_ADC_CH_BUSY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_ADC_CH_BUSY&#160;&#160;&#160;( 5 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC channel is busy at current time. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a712a5807bddc87dab3136cc82bf856de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712a5807bddc87dab3136cc82bf856de">&#9670;&nbsp;</a></span>IotAdcCallback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( *  IotAdcCallback_t) (uint16_t *pusConvertedData, void *pvUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adc notification callback type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>User Context passed when setting the callback. This is not used or modified by the driver. The context is provided by the caller when setting the callback, and is passed back to the caller in the callback. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pusConvertedData</td><td>pointer to converted ADC sample data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a637d786ac90af1e36e6d2569f7216050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637d786ac90af1e36e6d2569f7216050">&#9670;&nbsp;</a></span>IotAdcChState_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="iot__adc_8h.html#a637d786ac90af1e36e6d2569f7216050">IotAdcChState_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a637d786ac90af1e36e6d2569f7216050a97a1b2e85321bed36bb91097f46a8659"></a>eChStateIdle&#160;</td><td class="fielddoc"><p>ADC channel is idle. </p>
</td></tr>
<tr><td class="fieldname"><a id="a637d786ac90af1e36e6d2569f7216050ad8f4375e3be86371ee84379c07b0f8a9"></a>eChStateBusy&#160;</td><td class="fielddoc"><p>ADC channel is busy. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad3455e4f78011b07d403d32259b0299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3455e4f78011b07d403d32259b0299c">&#9670;&nbsp;</a></span>IotAdcIoctlRequest_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299c">IotAdcIoctlRequest_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adc ioctl request types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad3455e4f78011b07d403d32259b0299caff53edbaabe0507ab65dcbeeeaba036e"></a>eSetAdcConfig&#160;</td><td class="fielddoc"><p>Set the ADC Configuration. Takes <a class="el" href="struct_iot_adc_config__t.html" title="data structures for ioctl request ">IotAdcConfig_t</a> parameter. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3455e4f78011b07d403d32259b0299ca2f01c7bbfcb0d922ee0f0aa2f7b5f94f"></a>eGetAdcConfig&#160;</td><td class="fielddoc"><p>Get the ADC Configuration. Returns results in <a class="el" href="struct_iot_adc_config__t.html" title="data structures for ioctl request ">IotAdcConfig_t</a> parameter. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3455e4f78011b07d403d32259b0299ca07fb8f347c2d609d7888fe13d8b906be"></a>eGetChStatus&#160;</td><td class="fielddoc"><p>Get the Channel Status. Returns results in <a class="el" href="struct_iot_adc_ch_status__t.html" title="data structure for ioctl GetChStatus ">IotAdcChStatus_t</a> parameter. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3455e4f78011b07d403d32259b0299cac1b66abb20a822f8c4ab6827579d9689"></a>eSetChBuffer&#160;</td><td class="fielddoc"><p>Set the buffer for ADC values to be stored in. Takes <a class="el" href="struct_iot_adc_ch_buffer__t.html" title="data structure for ioctl SetChBuffer setting channel data buffer is optional using this ioctl if clie...">IotAdcChBuffer_t</a> parameter. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad3455e4f78011b07d403d32259b0299ca7eaa6768969e1cddb48ac5cfaa224c4a"></a>eSetAdcChain&#160;</td><td class="fielddoc"><p>ADC Chain for multiple ADC channels. Takes <a class="el" href="struct_iot_adc_chain__t.html" title="Some ADC host controller supports grouping multiple ADC channels into a chain. When the chain is trig...">IotAdcChain_t</a> parameter. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a864120f9515e3e82291750d96e1e1bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864120f9515e3e82291750d96e1e1bc3">&#9670;&nbsp;</a></span>iot_adc_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> iot_adc_open </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lAdc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes ADC controller with default configuration. init ADC controller, enable ADC clock, reset HW FIFO, set default configuration parameters, etc. Also allocate all required resources for ADC operation such as software data buffer etc. </p>
<dl class="section warning"><dt>Warning</dt><dd>Must be called prior to any other ADC api's so that a valid handle is obtained. </dd>
<dd>
Once opened, the same ADC instance must be closed before calling open again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lAdc</td><td>The instance of ADC controller to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>handle to the ADC controller on success</li>
<li>NULL, if<ul>
<li>invalid instance number</li>
<li>open same instance more than once before closing it. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6a729bdb2e47acb7a750caeb55e646eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a729bdb2e47acb7a750caeb55e646eb">&#9670;&nbsp;</a></span>iot_adc_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_adc_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxAdc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close ADC controller. All pending operation will be cancelled, put ADC module in reset state or low power state if possible. Release all resources claimed during open call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAdc</td><td>handle to ADC controller returned from <a class="el" href="iot__adc_8h.html#a864120f9515e3e82291750d96e1e1bc3" title="Initializes ADC controller with default configuration. init ADC controller, enable ADC clock...">iot_adc_open()</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_ADC_SUCCESS, on success;</li>
<li>IOT_I2C_INVALID_VALUE, if pxAdc is NULL</li>
<li>IOT_ADC_NOT_OPEN, if is not in open state (already closed). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7640cc3ed7d0768dd9bf875c7e71c582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7640cc3ed7d0768dd9bf875c7e71c582">&#9670;&nbsp;</a></span>iot_adc_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iot_adc_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxAdc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucAdcChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iot__adc_8h.html#a712a5807bddc87dab3136cc82bf856de">IotAdcCallback_t</a>&#160;</td>
          <td class="paramname"><em>xAdcCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvUserContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets channel callback on availability of channel scan data. On availability of ADC scan data, the application is notified with a function callback. The callback function and user context for callback are set using iot_adc_set_callback. </p>
<dl class="section note"><dt>Note</dt><dd>This callback is per AdcChannel for each handle. </dd>
<dd>
If input handle or AdcChannel is invalid, or if callback function is NULL, this function silently takes no action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAdc</td><td>The Adc handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucAdcChannel</td><td>The Adc channel for which the callback is set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xAdcCallback</td><td>The callback function to be called on availability of ADC channel data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>The user context to be passed when callback is called.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Callback Function</b> For asychronous ADC calls, a callback function is used to signal when the async task is complete. This example uses a Semaphore to signal the completion. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> prvAdcChCallback( uint16_t * pusConvertedData,</div><div class="line">                              <span class="keywordtype">void</span> * pvUserContext )</div><div class="line">{</div><div class="line">    BaseType_t xHigherPriorityTaskWoken;</div><div class="line">    xSemaphoreGiveFromISR( xIotAdcSemaphore, &amp;xHigherPriorityTaskWoken );</div><div class="line">    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a5e0e064b1b2618de067c1622d51e180b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0e064b1b2618de067c1622d51e180b">&#9670;&nbsp;</a></span>iot_adc_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_adc_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxAdc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucAdcChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start data acquisition for ADC channel until iot_adc_stop API is called. data will be passed back to client using callback function. by default each callback will pass back one data sample, however if client has used ioctl to pass in data buffer, only when buffer is full will callback be triggered. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="iot__adc_8h.html#a7640cc3ed7d0768dd9bf875c7e71c582" title="Sets channel callback on availability of channel scan data. On availability of ADC scan data...">iot_adc_set_callback()</a> must be called prior to this in order to get notification when adc scan is complete and data is available</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="iot__adc_8h.html#a7640cc3ed7d0768dd9bf875c7e71c582" title="Sets channel callback on availability of channel scan data. On availability of ADC scan data...">iot_adc_set_callback()</a> must be called prior to <a class="el" href="iot__adc_8h.html#a5e0e064b1b2618de067c1622d51e180b" title="Start data acquisition for ADC channel until iot_adc_stop API is called. data will be passed back to ...">iot_adc_start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAdc.</td><td>The ADC handle returned in the open() call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucAdcChannel.</td><td>The ADC channel to start data acquisition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_ADC_SUCCESS on success</li>
<li>IOT_ADC_INVALID_VALUE, on NULL handle or invalid AdcChannel</li>
<li>IOT_ADC_NOT_OPEN if ADC has not been opened yet.</li>
<li>IOT_ADC_CH_BUSY if ADC operation has started but is not complete</li>
<li>IOT_ADC_FAILED if not callback function has been set. <b>Example Asynchronous read</b> <div class="fragment"><div class="line"><span class="comment">// ADC Instance to open</span></div><div class="line">int32_t lAdcInstance = 0;</div><div class="line"></div><div class="line"><span class="comment">// Return value of ADC functions</span></div><div class="line">int32_t lRetVal;</div><div class="line"></div><div class="line"><span class="comment">// ADC Channel to read</span></div><div class="line">int32_t lAdcChannel = 0;</div><div class="line"></div><div class="line"><span class="comment">// User/Driver context; if necessary</span></div><div class="line"><span class="keywordtype">void</span> xUserContext = NULL;</div><div class="line"></div><div class="line"><span class="comment">// Open the ADC instance and get a handle.</span></div><div class="line">xAdcHandle = <a class="code" href="iot__adc_8h.html#a864120f9515e3e82291750d96e1e1bc3">iot_adc_open</a>( lAdcInstance );</div><div class="line"><span class="comment">// assert(lRetVal == IOT_ADC_SUCCESS);</span></div><div class="line"></div><div class="line"><span class="comment">// set the callback function</span></div><div class="line"><a class="code" href="iot__adc_8h.html#a7640cc3ed7d0768dd9bf875c7e71c582">iot_adc_set_callback</a>( xAdcHandle, lAdcChannel, prvAdcChCallback, &amp;xUserCntx );</div><div class="line"></div><div class="line"><span class="comment">// start channel data scan on channel</span></div><div class="line">lRetVal = <a class="code" href="iot__adc_8h.html#a5e0e064b1b2618de067c1622d51e180b">iot_adc_start</a>( xAdcHandle, lAdcChannel );</div><div class="line"> <span class="comment">// assert( IOT_ADC_SUCCESS == lRetVal );</span></div><div class="line"></div><div class="line"> <span class="comment">// wait for the Adc operation to complete</span></div><div class="line"> lRetVal = xSemaphoreTake( xIotAdcSemaphore, lIotAdcChWaitTime );</div><div class="line"> <span class="comment">// assert ( pdTRUE == lRetVal );</span></div><div class="line"></div><div class="line"> <span class="comment">// stop channel data scan</span></div><div class="line"> lRetVal = <a class="code" href="iot__adc_8h.html#abea645e9c4925b8581a5003ceacff3f0">iot_adc_stop</a>( xAdcHandle, lAdcChannel );</div><div class="line"> assert( <a class="code" href="iot__adc_8h.html#aba01db325e6bd3edba929aeb2643de60">IOT_ADC_SUCCESS</a> == lRetVal );</div><div class="line"></div><div class="line"> <span class="comment">// close ADC module</span></div><div class="line"> lRetVal = <a class="code" href="iot__adc_8h.html#a6a729bdb2e47acb7a750caeb55e646eb">iot_adc_close</a>( xAdcHandle );</div><div class="line"> <span class="comment">// assert( IOT_ADC_SUCCESS == lRetVal );</span></div></div><!-- fragment --> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abea645e9c4925b8581a5003ceacff3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea645e9c4925b8581a5003ceacff3f0">&#9670;&nbsp;</a></span>iot_adc_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_adc_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxAdc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucAdcChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop data acquisition for ADC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAdc.</td><td>The ADC handle returned in the open() call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucAdcChannel.</td><td>The ADC channel to stop data acquisition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_ADC_SCUCCESS on success</li>
<li>IOT_ADC_INVALID_VALUE, on NULL handle or invalid AdcChannel</li>
<li>IOT_ADC_NOT_OPEN if Adc has been closed without re-opening. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a34af2256e01c221dd4e2bccb535377f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34af2256e01c221dd4e2bccb535377f7">&#9670;&nbsp;</a></span>iot_adc_read_sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_adc_read_sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxAdc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucAdcChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusAdcSample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read one ADC data sample. This API will return one ADC sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAdc.</td><td>The ADC handle returned in the open() call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucAdcChannel.</td><td>The ADC channel to read data from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pusAdcSample.</td><td>ADC channel read sample value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_ADC_SCUCCESS on success</li>
<li>IOT_ADC_INVALID_VALUE, on NULL handle or invalid AdcChannel</li>
<li>IOT_ADC_CH_BUSY if ADC operation not complete.</li>
<li>IOT_ADC_NOT_OPEN if Adc has been closed without re-opening. <b>Example Synchronous read</b> <div class="fragment"><div class="line"><span class="comment">// ADC Instance to open</span></div><div class="line">int32_t lAdcInstance = 0;</div><div class="line"></div><div class="line"><span class="comment">// ADC Channel to read</span></div><div class="line">int32_t lAdcChannel = 0;</div><div class="line"></div><div class="line"><span class="comment">// Declare and ADC handle</span></div><div class="line"><a class="code" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> xAdcHandle;</div><div class="line"></div><div class="line"><span class="comment">// Return value of ADC functions</span></div><div class="line">int32_t lRetVal;</div><div class="line"></div><div class="line"><span class="comment">// ADC value read</span></div><div class="line">uint16_t usSample;</div><div class="line"></div><div class="line"><span class="comment">// Open the ADC instance and get a handle.</span></div><div class="line">xAdcHandle = <a class="code" href="iot__adc_8h.html#a864120f9515e3e82291750d96e1e1bc3">iot_adc_open</a>( lAdcInstance );</div><div class="line"><span class="comment">// assert(lRetVal == IOT_ADC_SUCCESS);</span></div><div class="line"></div><div class="line"><span class="comment">// Read sample from ADC channel</span></div><div class="line">lRetVal = <a class="code" href="iot__adc_8h.html#a34af2256e01c221dd4e2bccb535377f7">iot_adc_read_sample</a>( xAdcHandle, lAdcChannel, &amp;usSample);</div><div class="line"><span class="comment">// assert(lRetVal == IOT_ADC_SUCCESS);</span></div><div class="line"></div><div class="line"><span class="comment">// Close the ADC instance and get a handle.</span></div><div class="line">lRetVal = <a class="code" href="iot__adc_8h.html#a6a729bdb2e47acb7a750caeb55e646eb">iot_adc_close</a>( xAdcHandle );</div><div class="line"><span class="comment">// assert(lRetVal == IOT_ADC_SUCCESS);</span></div></div><!-- fragment --> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab4de5a004233505d2b6e8d484e431e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4de5a004233505d2b6e8d484e431e1f">&#9670;&nbsp;</a></span>iot_adc_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_adc_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iot__adc_8h.html#a92cdf1424eeebd0d6b46b3d2dc9976e7">IotAdcHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxAdc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iot__adc_8h.html#ad3455e4f78011b07d403d32259b0299c">IotAdcIoctlRequest_t</a>&#160;</td>
          <td class="paramname"><em>xRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for various ADC control functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAdc</td><td>The Adc handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xRequest</td><td>ioctl request defined by IotAdcIoctlRequest_s enums </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>pvBuffer data buffer for ioctl request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_ADC_SCUCCESS on success</li>
<li>IOT_ADC_INVALID_VALUE, on NULL handle or invalid request or NULL or invalid buffer pointer</li>
<li>IOT_ADC_CH_BUSY if ADC operation not complete.</li>
<li>IOT_ADC_NOT_OPEN if Adc has been closed without re-opening.</li>
<li>IOT_ADC_FAILED if invalid ADC chain is requested.</li>
<li>IOT_ADC_FUNCTION_NOT_SUPPORTED only valid for eSetAdcChain, if feature not supported </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- This file provides the custom footer for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Generated by
      <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14
    </li>
    <li class="footer">
      Last updated Mon Nov 25 2019
    </li>
    <li class="footer" style="float:left">
    </li>
  </ul>
</div>
</body>
</html>
