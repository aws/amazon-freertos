<!-- This file provides the custom header for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.14"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
        Common I/O: I2C Abstraction APIs.
    </title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="foobar.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
    <tbody>
        <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">
                    <span id="afrprefix">FreeRTOS:</span>
                    Common I/O
                </div>
                <div id="projectbrief">
                    AWS IoT Common I/O library
                </div>
            </td>
        </tr>
        <tr>
            <td id="returntomain">
                <a href="../index.html">Return to main page &uarr;</a>
            </td>
        </tr>
    </tbody>
    </table>
    </div>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<!-- end header part --><!-- Generated by Doxygen 1.8.14 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__iot__i2c.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C Abstraction APIs.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_i2_c_config__t.html">IotI2CConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C bus configuration.  <a href="struct_iot_i2_c_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga39dedd82c859dd488c36bc5e3a08bfa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga39dedd82c859dd488c36bc5e3a08bfa3">IOT_I2C_STANDARD_MODE_BPS</a>&#160;&#160;&#160;( 100000 )</td></tr>
<tr class="separator:ga39dedd82c859dd488c36bc5e3a08bfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66720ecc3ff5a93ac9d7cfa7f13de54c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga66720ecc3ff5a93ac9d7cfa7f13de54c">IOT_I2C_FAST_MODE_BPS</a>&#160;&#160;&#160;( 400000 )</td></tr>
<tr class="separator:ga66720ecc3ff5a93ac9d7cfa7f13de54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6197dc227a3c6df7122de50a8ee8550e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga6197dc227a3c6df7122de50a8ee8550e">IOT_I2C_FAST_MODE_PLUS_BPS</a>&#160;&#160;&#160;( 1000000 )</td></tr>
<tr class="separator:ga6197dc227a3c6df7122de50a8ee8550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04adf3426f58755529fd9346b3d7f2ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga04adf3426f58755529fd9346b3d7f2ec">IOT_I2C_HIGH_SPEED_BPS</a>&#160;&#160;&#160;( 3400000 )</td></tr>
<tr class="separator:ga04adf3426f58755529fd9346b3d7f2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f948585154dcb4c56ee3fe2de98b65f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga9f948585154dcb4c56ee3fe2de98b65f">IOT_I2C_SUCCESS</a>&#160;&#160;&#160;( 0 )</td></tr>
<tr class="separator:ga9f948585154dcb4c56ee3fe2de98b65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3d32e22885563ee966d31d22a7a533"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga7c3d32e22885563ee966d31d22a7a533">IOT_I2C_INVALID_VALUE</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:ga7c3d32e22885563ee966d31d22a7a533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8248dfa6b9f354c200b4306105113f99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga8248dfa6b9f354c200b4306105113f99">IOT_I2C_BUSY</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="separator:ga8248dfa6b9f354c200b4306105113f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcd783d68a244d1f48937e6d8c0bed7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga6fcd783d68a244d1f48937e6d8c0bed7">IOT_I2C_WRITE_FAILED</a>&#160;&#160;&#160;( 3 )</td></tr>
<tr class="separator:ga6fcd783d68a244d1f48937e6d8c0bed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26399840bffad58422bc26c1718e293"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gae26399840bffad58422bc26c1718e293">IOT_I2C_READ_FAILED</a>&#160;&#160;&#160;( 4 )</td></tr>
<tr class="separator:gae26399840bffad58422bc26c1718e293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0dd2eb48b5a66eb69d3537f358134f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gaa0dd2eb48b5a66eb69d3537f358134f6">IOT_I2C_NACK</a>&#160;&#160;&#160;( 5 )</td></tr>
<tr class="separator:gaa0dd2eb48b5a66eb69d3537f358134f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d147622319b047effeefebbe0b86cb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga4d147622319b047effeefebbe0b86cb3">IOT_I2C_BUS_TIMEOUT</a>&#160;&#160;&#160;( 6 )</td></tr>
<tr class="separator:ga4d147622319b047effeefebbe0b86cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc577b4e35153b903f04d7b0b6cf225e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gadc577b4e35153b903f04d7b0b6cf225e">IOT_I2C_NOTHING_TO_CANCEL</a>&#160;&#160;&#160;( 7 )</td></tr>
<tr class="separator:gadc577b4e35153b903f04d7b0b6cf225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4372dada4f0dd84f288a52df0b3a49e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gaa4372dada4f0dd84f288a52df0b3a49e">IOT_I2C_FUNCTION_NOT_SUPPORTED</a>&#160;&#160;&#160;( 8 )</td></tr>
<tr class="separator:gaa4372dada4f0dd84f288a52df0b3a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23288108c96fad5d4f047c9a59d969d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga23288108c96fad5d4f047c9a59d969d8">IOT_I2C_SLAVE_ADDRESS_NOT_SET</a>&#160;&#160;&#160;( 9 )</td></tr>
<tr class="separator:ga23288108c96fad5d4f047c9a59d969d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6b10b8bf106ac971adacb0ba2d55ce79"><td class="memItemLeft" align="right" valign="top"><a id="ga6b10b8bf106ac971adacb0ba2d55ce79"></a>
typedef struct IotI2CDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a></td></tr>
<tr class="memdesc:ga6b10b8bf106ac971adacb0ba2d55ce79"><td class="mdescLeft">&#160;</td><td class="mdescRight">IotI2CHandle_t is the handle type returned by calling <a class="el" href="group__iot__i2c.html#gaf8f5f0ebea988cc69c1a475bd9de495c" title="Initiates and reserves an I2C instance as master. ">iot_i2c_open()</a>. This is initialized in open and returned to caller. The caller must pass this pointer to the rest of APIs. <br /></td></tr>
<tr class="separator:ga6b10b8bf106ac971adacb0ba2d55ce79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfbdc6f340ac300bd82f5bbe37c1930"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga9cfbdc6f340ac300bd82f5bbe37c1930">IotI2CCallback_t</a>) (<a class="el" href="group__iot__i2c.html#gaaa0d0c7fc5d58748f18f06ac6c206188">IotI2COperationStatus_t</a> xOpStatus, void *pvUserContext)</td></tr>
<tr class="memdesc:ga9cfbdc6f340ac300bd82f5bbe37c1930"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback function for completion of I2C operation.  <a href="#ga9cfbdc6f340ac300bd82f5bbe37c1930">More...</a><br /></td></tr>
<tr class="separator:ga9cfbdc6f340ac300bd82f5bbe37c1930"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gacc842976e064b31f5525816ce492df4b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gacc842976e064b31f5525816ce492df4b">IotI2CBusStatus_t</a> { <a class="el" href="group__iot__i2c.html#ggacc842976e064b31f5525816ce492df4ba675f57e9e0a861ab91b25bf6edc1cf12">eI2CBusIdle</a> = 0, 
<a class="el" href="group__iot__i2c.html#ggacc842976e064b31f5525816ce492df4ba952c730267c3789ef5e53163dde290da">eI2cBusBusy</a> = IOT_I2C_BUSY
 }</td></tr>
<tr class="memdesc:gacc842976e064b31f5525816ce492df4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Bus status.  <a href="group__iot__i2c.html#gacc842976e064b31f5525816ce492df4b">More...</a><br /></td></tr>
<tr class="separator:gacc842976e064b31f5525816ce492df4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0d0c7fc5d58748f18f06ac6c206188"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gaaa0d0c7fc5d58748f18f06ac6c206188">IotI2COperationStatus_t</a> { <a class="el" href="group__iot__i2c.html#ggaaa0d0c7fc5d58748f18f06ac6c206188a89e6508639a38834cb5f865aefe13d7d">eI2CCompleted</a> = IOT_I2C_SUCCESS, 
<a class="el" href="group__iot__i2c.html#ggaaa0d0c7fc5d58748f18f06ac6c206188a85f05ef36457d23a97434611891dfa5d">eI2CDriverFailed</a>, 
<a class="el" href="group__iot__i2c.html#ggaaa0d0c7fc5d58748f18f06ac6c206188ab454d36ee9565b25abfdd853d04a59d3">eI2CNackFromSlave</a> = IOT_I2C_NACK, 
<a class="el" href="group__iot__i2c.html#ggaaa0d0c7fc5d58748f18f06ac6c206188ab0002506f3d88f5f775118ed798d9372">eI2CMasterTimeout</a> = IOT_I2C_BUS_TIMEOUT
 }</td></tr>
<tr class="memdesc:gaaa0d0c7fc5d58748f18f06ac6c206188"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C operation status.  <a href="group__iot__i2c.html#gaaa0d0c7fc5d58748f18f06ac6c206188">More...</a><br /></td></tr>
<tr class="separator:gaaa0d0c7fc5d58748f18f06ac6c206188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6c106295bcbda3469e1e4d792a6075d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gaf6c106295bcbda3469e1e4d792a6075d">IotI2CIoctlRequest_t</a> { <br />
&#160;&#160;<a class="el" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da8f87883392ee2b403a16b5390e89b4c6">eI2CSendNoStopFlag</a>, 
<a class="el" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da1e1afe232ebb3c786387f6fb4fcb9f23">eI2CSetSlaveAddr</a>, 
<a class="el" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da296485174fb38af72af642364c366d82">eI2CSetMasterConfig</a>, 
<a class="el" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075daa38fd06bf7ad043a8130d43ae1178d60">eI2CGetMasterConfig</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da6a83e28f0cdf3e0146b1157ebf978133">eI2CGetBusState</a>, 
<a class="el" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da7337865bb3b2c53874446f372da02312">eI2CBusReset</a>, 
<a class="el" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da12b87e84b9702f09651e63ef77c8bf94">eI2CGetTxNoOfbytes</a>, 
<a class="el" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075daf8542407b24b649e862359ad11ca9abb">eI2CGetRxNoOfbytes</a>
<br />
 }</td></tr>
<tr class="memdesc:gaf6c106295bcbda3469e1e4d792a6075d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ioctl request types.  <a href="group__iot__i2c.html#gaf6c106295bcbda3469e1e4d792a6075d">More...</a><br /></td></tr>
<tr class="separator:gaf6c106295bcbda3469e1e4d792a6075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf8f5f0ebea988cc69c1a475bd9de495c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gaf8f5f0ebea988cc69c1a475bd9de495c">iot_i2c_open</a> (int32_t lI2CInstance)</td></tr>
<tr class="memdesc:gaf8f5f0ebea988cc69c1a475bd9de495c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates and reserves an I2C instance as master.  <a href="#gaf8f5f0ebea988cc69c1a475bd9de495c">More...</a><br /></td></tr>
<tr class="separator:gaf8f5f0ebea988cc69c1a475bd9de495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e3b3385a789286583cdb6b3e403f43e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga5e3b3385a789286583cdb6b3e403f43e">iot_i2c_set_callback</a> (<a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const pxI2CPeripheral, <a class="el" href="group__iot__i2c.html#ga9cfbdc6f340ac300bd82f5bbe37c1930">IotI2CCallback_t</a> xCallback, void *pvUserContext)</td></tr>
<tr class="memdesc:ga5e3b3385a789286583cdb6b3e403f43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application callback to be called on completion of an operation.  <a href="#ga5e3b3385a789286583cdb6b3e403f43e">More...</a><br /></td></tr>
<tr class="separator:ga5e3b3385a789286583cdb6b3e403f43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80a773727ade2369c1c0f1d529ba280"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gad80a773727ade2369c1c0f1d529ba280">iot_i2c_read_sync</a> (<a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const pxI2CPeripheral, uint8_t *const pucBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gad80a773727ade2369c1c0f1d529ba280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the I2C master read operation in synchronous mode.  <a href="#gad80a773727ade2369c1c0f1d529ba280">More...</a><br /></td></tr>
<tr class="separator:gad80a773727ade2369c1c0f1d529ba280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b7f8bf2ea30d68fac0d082ec21265f5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga3b7f8bf2ea30d68fac0d082ec21265f5">iot_i2c_write_sync</a> (<a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const pxI2CPeripheral, uint8_t *const pucBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga3b7f8bf2ea30d68fac0d082ec21265f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the I2C master write operation in synchronous mode.  <a href="#ga3b7f8bf2ea30d68fac0d082ec21265f5">More...</a><br /></td></tr>
<tr class="separator:ga3b7f8bf2ea30d68fac0d082ec21265f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2759a113c8be82ed14bc8059e09ff8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga4a2759a113c8be82ed14bc8059e09ff8">iot_i2c_read_async</a> (<a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const pxI2CPeripheral, uint8_t *const pucBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga4a2759a113c8be82ed14bc8059e09ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the I2C master read operation in asynchronous mode.  <a href="#ga4a2759a113c8be82ed14bc8059e09ff8">More...</a><br /></td></tr>
<tr class="separator:ga4a2759a113c8be82ed14bc8059e09ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab86ebe47dc9c0cb0337f24cf4505f570"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gab86ebe47dc9c0cb0337f24cf4505f570">iot_i2c_write_async</a> (<a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const pxI2CPeripheral, uint8_t *const pucBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gab86ebe47dc9c0cb0337f24cf4505f570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the I2C master write operation in asynchronous mode.  <a href="#gab86ebe47dc9c0cb0337f24cf4505f570">More...</a><br /></td></tr>
<tr class="separator:gab86ebe47dc9c0cb0337f24cf4505f570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f7684f8555cf807339aa717733cca7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#gad1f7684f8555cf807339aa717733cca7">iot_i2c_ioctl</a> (<a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const pxI2CPeripheral, <a class="el" href="group__iot__i2c.html#gaf6c106295bcbda3469e1e4d792a6075d">IotI2CIoctlRequest_t</a> xI2CRequest, void *const pvBuffer)</td></tr>
<tr class="memdesc:gad1f7684f8555cf807339aa717733cca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the I2C master with user configuration.  <a href="#gad1f7684f8555cf807339aa717733cca7">More...</a><br /></td></tr>
<tr class="separator:gad1f7684f8555cf807339aa717733cca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c79a2c4038796eca1333ce1d964a139"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga4c79a2c4038796eca1333ce1d964a139">iot_i2c_close</a> (<a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const pxI2CPeripheral)</td></tr>
<tr class="memdesc:ga4c79a2c4038796eca1333ce1d964a139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the ongoing operation and de-initializes the I2C peripheral.  <a href="#ga4c79a2c4038796eca1333ce1d964a139">More...</a><br /></td></tr>
<tr class="separator:ga4c79a2c4038796eca1333ce1d964a139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3139a61ef95d7d7c4ee9137b5f78d9f7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__i2c.html#ga3139a61ef95d7d7c4ee9137b5f78d9f7">iot_i2c_cancel</a> (<a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const pxI2CPeripheral)</td></tr>
<tr class="memdesc:ga3139a61ef95d7d7c4ee9137b5f78d9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to cancel the current operation in progress, if possible.  <a href="#ga3139a61ef95d7d7c4ee9137b5f78d9f7">More...</a><br /></td></tr>
<tr class="separator:ga3139a61ef95d7d7c4ee9137b5f78d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga39dedd82c859dd488c36bc5e3a08bfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39dedd82c859dd488c36bc5e3a08bfa3">&#9670;&nbsp;</a></span>IOT_I2C_STANDARD_MODE_BPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_STANDARD_MODE_BPS&#160;&#160;&#160;( 100000 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The speeds supported by I2C bus.Standard mode bits per second. </p>

</div>
</div>
<a id="ga66720ecc3ff5a93ac9d7cfa7f13de54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66720ecc3ff5a93ac9d7cfa7f13de54c">&#9670;&nbsp;</a></span>IOT_I2C_FAST_MODE_BPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_FAST_MODE_BPS&#160;&#160;&#160;( 400000 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast mode bits per second. </p>

</div>
</div>
<a id="ga6197dc227a3c6df7122de50a8ee8550e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6197dc227a3c6df7122de50a8ee8550e">&#9670;&nbsp;</a></span>IOT_I2C_FAST_MODE_PLUS_BPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_FAST_MODE_PLUS_BPS&#160;&#160;&#160;( 1000000 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast plus mode bits per second. </p>

</div>
</div>
<a id="ga04adf3426f58755529fd9346b3d7f2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04adf3426f58755529fd9346b3d7f2ec">&#9670;&nbsp;</a></span>IOT_I2C_HIGH_SPEED_BPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_HIGH_SPEED_BPS&#160;&#160;&#160;( 3400000 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>High speed mode bits per second. </p>

</div>
</div>
<a id="ga9f948585154dcb4c56ee3fe2de98b65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f948585154dcb4c56ee3fe2de98b65f">&#9670;&nbsp;</a></span>IOT_I2C_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_SUCCESS&#160;&#160;&#160;( 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The return codes for the functions in I2C.I2C operation completed successfully. </p>

</div>
</div>
<a id="ga7c3d32e22885563ee966d31d22a7a533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c3d32e22885563ee966d31d22a7a533">&#9670;&nbsp;</a></span>IOT_I2C_INVALID_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_INVALID_VALUE&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>At least one parameter is invalid. </p>

</div>
</div>
<a id="ga8248dfa6b9f354c200b4306105113f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8248dfa6b9f354c200b4306105113f99">&#9670;&nbsp;</a></span>IOT_I2C_BUSY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_BUSY&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C bus is busy at current time. </p>

</div>
</div>
<a id="ga6fcd783d68a244d1f48937e6d8c0bed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fcd783d68a244d1f48937e6d8c0bed7">&#9670;&nbsp;</a></span>IOT_I2C_WRITE_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_WRITE_FAILED&#160;&#160;&#160;( 3 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C driver returns error when performing write operation. </p>

</div>
</div>
<a id="gae26399840bffad58422bc26c1718e293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26399840bffad58422bc26c1718e293">&#9670;&nbsp;</a></span>IOT_I2C_READ_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_READ_FAILED&#160;&#160;&#160;( 4 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C driver returns error when performing read operation. </p>

</div>
</div>
<a id="gaa0dd2eb48b5a66eb69d3537f358134f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0dd2eb48b5a66eb69d3537f358134f6">&#9670;&nbsp;</a></span>IOT_I2C_NACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_NACK&#160;&#160;&#160;( 5 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unexpected NACK is caught. </p>

</div>
</div>
<a id="ga4d147622319b047effeefebbe0b86cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d147622319b047effeefebbe0b86cb3">&#9670;&nbsp;</a></span>IOT_I2C_BUS_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_BUS_TIMEOUT&#160;&#160;&#160;( 6 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C operation not completed within specified timeout. </p>

</div>
</div>
<a id="gadc577b4e35153b903f04d7b0b6cf225e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc577b4e35153b903f04d7b0b6cf225e">&#9670;&nbsp;</a></span>IOT_I2C_NOTHING_TO_CANCEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_NOTHING_TO_CANCEL&#160;&#160;&#160;( 7 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No ongoing transaction when cancel operation is performed. </p>

</div>
</div>
<a id="gaa4372dada4f0dd84f288a52df0b3a49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4372dada4f0dd84f288a52df0b3a49e">&#9670;&nbsp;</a></span>IOT_I2C_FUNCTION_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_FUNCTION_NOT_SUPPORTED&#160;&#160;&#160;( 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C operation is not supported. </p>

</div>
</div>
<a id="ga23288108c96fad5d4f047c9a59d969d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23288108c96fad5d4f047c9a59d969d8">&#9670;&nbsp;</a></span>IOT_I2C_SLAVE_ADDRESS_NOT_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_I2C_SLAVE_ADDRESS_NOT_SET&#160;&#160;&#160;( 9 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Slave address is not set before calling I2C read or write operation. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9cfbdc6f340ac300bd82f5bbe37c1930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cfbdc6f340ac300bd82f5bbe37c1930">&#9670;&nbsp;</a></span>IotI2CCallback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  IotI2CCallback_t) (<a class="el" href="group__iot__i2c.html#gaaa0d0c7fc5d58748f18f06ac6c206188">IotI2COperationStatus_t</a> xOpStatus, void *pvUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback function for completion of I2C operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">xOpStatus</td><td>I2C asynchronous operation status. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>User Context passed when setting the callback. This is not used or modified by the driver. The context is provided by the caller when setting the callback, and is passed back to the caller in the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gacc842976e064b31f5525816ce492df4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc842976e064b31f5525816ce492df4b">&#9670;&nbsp;</a></span>IotI2CBusStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__i2c.html#gacc842976e064b31f5525816ce492df4b">IotI2CBusStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Bus status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacc842976e064b31f5525816ce492df4ba675f57e9e0a861ab91b25bf6edc1cf12"></a>eI2CBusIdle&#160;</td><td class="fielddoc"><p>I2C bus is idle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacc842976e064b31f5525816ce492df4ba952c730267c3789ef5e53163dde290da"></a>eI2cBusBusy&#160;</td><td class="fielddoc"><p>I2C bus is busy. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaaa0d0c7fc5d58748f18f06ac6c206188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa0d0c7fc5d58748f18f06ac6c206188">&#9670;&nbsp;</a></span>IotI2COperationStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__i2c.html#gaaa0d0c7fc5d58748f18f06ac6c206188">IotI2COperationStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C operation status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaa0d0c7fc5d58748f18f06ac6c206188a89e6508639a38834cb5f865aefe13d7d"></a>eI2CCompleted&#160;</td><td class="fielddoc"><p>I2C operation completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa0d0c7fc5d58748f18f06ac6c206188a85f05ef36457d23a97434611891dfa5d"></a>eI2CDriverFailed&#160;</td><td class="fielddoc"><p>I2C driver returns error during last operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa0d0c7fc5d58748f18f06ac6c206188ab454d36ee9565b25abfdd853d04a59d3"></a>eI2CNackFromSlave&#160;</td><td class="fielddoc"><p>Unexpected NACK is caught. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa0d0c7fc5d58748f18f06ac6c206188ab0002506f3d88f5f775118ed798d9372"></a>eI2CMasterTimeout&#160;</td><td class="fielddoc"><p>I2C operation not completed within specified timeout. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf6c106295bcbda3469e1e4d792a6075d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6c106295bcbda3469e1e4d792a6075d">&#9670;&nbsp;</a></span>IotI2CIoctlRequest_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__i2c.html#gaf6c106295bcbda3469e1e4d792a6075d">IotI2CIoctlRequest_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ioctl request types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf6c106295bcbda3469e1e4d792a6075da8f87883392ee2b403a16b5390e89b4c6"></a>eI2CSendNoStopFlag&#160;</td><td class="fielddoc"><p>! Set flag to not send stop after transaction ! Default is always stop for every transaction ! Flag will auto reset to stop after one transaction if you set no stop </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6c106295bcbda3469e1e4d792a6075da1e1afe232ebb3c786387f6fb4fcb9f23"></a>eI2CSetSlaveAddr&#160;</td><td class="fielddoc"><p>! This can be either 7-bit address or 10-bit address. All the operations use this slave address after it is set. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6c106295bcbda3469e1e4d792a6075da296485174fb38af72af642364c366d82"></a>eI2CSetMasterConfig&#160;</td><td class="fielddoc"><p>! Sets the I2C bus frequency and timeout using the struct <a class="el" href="struct_iot_i2_c_config__t.html" title="I2C bus configuration. ">IotI2CConfig_t</a>, default speed is Standard mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6c106295bcbda3469e1e4d792a6075daa38fd06bf7ad043a8130d43ae1178d60"></a>eI2CGetMasterConfig&#160;</td><td class="fielddoc"><p>! Gets the I2C bus frequency and timeout set for the I2C master. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6c106295bcbda3469e1e4d792a6075da6a83e28f0cdf3e0146b1157ebf978133"></a>eI2CGetBusState&#160;</td><td class="fielddoc"><p>! Get the current I2C bus status. Returns eI2CBusIdle or eI2CBusy </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6c106295bcbda3469e1e4d792a6075da7337865bb3b2c53874446f372da02312"></a>eI2CBusReset&#160;</td><td class="fielddoc"><p>! Master resets the bus. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6c106295bcbda3469e1e4d792a6075da12b87e84b9702f09651e63ef77c8bf94"></a>eI2CGetTxNoOfbytes&#160;</td><td class="fielddoc"><p>! Get the number of bytes sent in write operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6c106295bcbda3469e1e4d792a6075daf8542407b24b649e862359ad11ca9abb"></a>eI2CGetRxNoOfbytes&#160;</td><td class="fielddoc"><p>! Get the number of bytes received in read operation. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf8f5f0ebea988cc69c1a475bd9de495c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8f5f0ebea988cc69c1a475bd9de495c">&#9670;&nbsp;</a></span>iot_i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> iot_i2c_open </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lI2CInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates and reserves an I2C instance as master. </p>
<p>One instance can communicate with one or more slave devices. Slave addresses need to be changed between actions to different slave devices.</p>
<dl class="section warning"><dt>Warning</dt><dd>Once opened, the same I2C instance must be closed before calling open again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lI2CInstance</td><td>The instance of I2C to initialize. This is between 0 and the number of I2C instances on board - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>'the handle to the I2C port (not NULL)', on success.</li>
<li>'NULL', if<ul>
<li>invalid instance number</li>
<li>open same instance more than once before closing it </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5e3b3385a789286583cdb6b3e403f43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e3b3385a789286583cdb6b3e403f43e">&#9670;&nbsp;</a></span>iot_i2c_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iot_i2c_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxI2CPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga9cfbdc6f340ac300bd82f5bbe37c1930">IotI2CCallback_t</a>&#160;</td>
          <td class="paramname"><em>xCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvUserContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the application callback to be called on completion of an operation. </p>
<p>The callback is guaranteed to be invoked when the current asynchronous operation completes, either successful or failed. This simply provides a notification mechanism to user's application. It has no impact if the callback is not set.</p>
<dl class="section note"><dt>Note</dt><dd>This callback will not be invoked when synchronous operation completes. </dd>
<dd>
This callback is per handle. Each instance has its own callback. </dd>
<dd>
Single callback is used for both read_async and write_async. Newly set callback overrides the one previously set. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the input handle is invalid, this function silently takes no action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxI2CPeripheral</td><td>The I2C peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCallback</td><td>The callback function to be called on completion of transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>The user context to be passed back when callback is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad80a773727ade2369c1c0f1d529ba280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad80a773727ade2369c1c0f1d529ba280">&#9670;&nbsp;</a></span>iot_i2c_read_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_i2c_read_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxI2CPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pucBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the I2C master read operation in synchronous mode. </p>
<p>This function attempts to read certain number of bytes from slave device to a pre-allocated buffer, in synchronous way. Partial read might happen, e.g. no more data is available. And the number of bytes that have been actually read can be obtained by calling iot_i2c_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>Usually, the address of register needs to be written before calling this function. </dd>
<dd>
If eI2CSendNoStopFlag is set and this function returns, whether the actual transaction has been started is undefined. This is board-specific behavior.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Prior to this function, slave address must be already configured. </dd>
<dd>
None of other read or write functions shall be called during this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxI2CPeripheral</td><td>The I2C handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucBuffer</td><td>The receive buffer to read the data into. It must stay allocated before this function returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_I2C_SUCCESS, on success (all the requested bytes have been read)</li>
<li>IOT_I2C_INVALID_VALUE, if<ul>
<li>pxI2CPeripheral is NULL</li>
<li>pxI2CPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_I2C_SLAVE_ADDRESS_NOT_SET, if slave address is not set yet</li>
<li>IOT_I2C_NACK or IOT_I2C_READ_FAILED, if<ul>
<li>no device correspond to the slave address</li>
<li>the slave is unable to receive or transmit</li>
<li>the slave gets data or commands that it does not understand</li>
<li>there is some unknown driver error</li>
</ul>
</li>
<li>IOT_I2C_BUS_TIMEOUT, if timeout is supported and slave device does not respond within configured timeout.</li>
<li>IOT_I2C_BUSY, if the bus is busy which means there is an ongoing transaction.</li>
</ul>
</dd></dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="comment">// Declare an I2C handle.</span></div><div class="line"><a class="code" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> xI2CHandle;</div><div class="line"></div><div class="line"><span class="comment">// Return value of I2C functions.</span></div><div class="line">int32_t lRetVal = <a class="code" href="group__iot__i2c.html#ga9f948585154dcb4c56ee3fe2de98b65f">IOT_I2C_SUCCESS</a>;</div><div class="line"></div><div class="line"><span class="comment">// Register address on I2C slave device.</span></div><div class="line">uint8_t xDeviceRegisterAddress = 0x73;</div><div class="line"></div><div class="line"><span class="comment">// Number of read/write bytes.</span></div><div class="line">uint16_t usReadBytes = 0;</div><div class="line">uint16_t usWriteBytes = 0;</div><div class="line"></div><div class="line">uint8_t ucReadBuffer[2] = {0};</div><div class="line"></div><div class="line"><span class="comment">// Configurations of I2C master device.</span></div><div class="line"><a class="code" href="struct_iot_i2_c_config__t.html">IotI2CConfig_t</a> xI2CConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="struct_iot_i2_c_config__t.html#adfff942ebb9ecbb75cac57ef2c2c710d">ulBusFreq</a>       = <a class="code" href="group__iot__i2c.html#ga66720ecc3ff5a93ac9d7cfa7f13de54c">IOT_I2C_FAST_MODE_BPS</a>,</div><div class="line">    .ulMasterTimeout = 500</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Open one of the I2C instance and get a handle.</span></div><div class="line">xI2CHandle = <a class="code" href="group__iot__i2c.html#gaf8f5f0ebea988cc69c1a475bd9de495c">iot_i2c_open</a>( 1 );</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( xI2CHandle != NULL )</div><div class="line">{</div><div class="line">    <span class="comment">// Set I2C configuration.</span></div><div class="line">    lRetVal = <a class="code" href="group__iot__i2c.html#gad1f7684f8555cf807339aa717733cca7">iot_i2c_ioctl</a>( xI2CHandle, <a class="code" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da296485174fb38af72af642364c366d82">eI2CSetMasterConfig</a>, &amp;xI2CConfig );</div><div class="line">    <span class="comment">// assert(lRetVal == IOT_I2C_SUCCESS);</span></div><div class="line"></div><div class="line">    <span class="comment">// Set slave address.</span></div><div class="line">    lRetVal = <a class="code" href="group__iot__i2c.html#gad1f7684f8555cf807339aa717733cca7">iot_i2c_ioctl</a>( xI2CHandle, <a class="code" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da1e1afe232ebb3c786387f6fb4fcb9f23">eI2CSetSlaveAddr</a>, &amp;uctestIotI2CSlaveAddr );</div><div class="line">    <span class="comment">// assert(lRetVal == IOT_I2C_SUCCESS);</span></div><div class="line"></div><div class="line">    <span class="comment">// Write the register address as single byte, in a transaction.</span></div><div class="line">    lRetVal = <a class="code" href="group__iot__i2c.html#ga3b7f8bf2ea30d68fac0d082ec21265f5">iot_i2c_write_sync</a>( xI2CHandle, &amp;xDeviceRegisterAddress, <span class="keyword">sizeof</span>( xDeviceRegisterAddress ) );</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( lRetVal == <a class="code" href="group__iot__i2c.html#ga9f948585154dcb4c56ee3fe2de98b65f">IOT_I2C_SUCCESS</a> )</div><div class="line">    {</div><div class="line">        <span class="comment">// Get the number of written bytes in last transaction.</span></div><div class="line">        lRetVal = <a class="code" href="group__iot__i2c.html#gad1f7684f8555cf807339aa717733cca7">iot_i2c_ioctl</a>( xI2CHandle, <a class="code" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075da12b87e84b9702f09651e63ef77c8bf94">eI2CGetTxNoOfbytes</a>, &amp;usWriteBytes );</div><div class="line">        <span class="comment">// assert(lRetVal == IOT_I2C_SUCCESS);</span></div><div class="line">        <span class="comment">// assert(usWriteBytes == 1);</span></div><div class="line"></div><div class="line">        <span class="comment">// Read two bytes of data to allocated buffer, in a transaction.</span></div><div class="line">        lRetVal = <a class="code" href="group__iot__i2c.html#gad80a773727ade2369c1c0f1d529ba280">iot_i2c_read_sync</a>( xI2CHandle, &amp;ucReadBuffer, <span class="keyword">sizeof</span>( ucReadBuffer ) );</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ( lRetVal == <a class="code" href="group__iot__i2c.html#ga9f948585154dcb4c56ee3fe2de98b65f">IOT_I2C_SUCCESS</a> )</div><div class="line">        {</div><div class="line">            <span class="comment">// Get the number of read bytes in last transaction.</span></div><div class="line">            lRetVal = <a class="code" href="group__iot__i2c.html#gad1f7684f8555cf807339aa717733cca7">iot_i2c_ioctl</a>( xI2CHandle, <a class="code" href="group__iot__i2c.html#ggaf6c106295bcbda3469e1e4d792a6075daf8542407b24b649e862359ad11ca9abb">eI2CGetRxNoOfbytes</a>, &amp;usReadBytes );</div><div class="line">            <span class="comment">// assert(lRetVal == IOT_I2C_SUCCESS);</span></div><div class="line">            <span class="comment">// assert(usReadBytes == 2);</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    lRetVal = <a class="code" href="group__iot__i2c.html#ga4c79a2c4038796eca1333ce1d964a139">iot_i2c_close</a>( xI2CHandle );</div><div class="line">    <span class="comment">// assert(lRetVal == IOT_I2C_SUCCESS);</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3b7f8bf2ea30d68fac0d082ec21265f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b7f8bf2ea30d68fac0d082ec21265f5">&#9670;&nbsp;</a></span>iot_i2c_write_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_i2c_write_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxI2CPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pucBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the I2C master write operation in synchronous mode. </p>
<p>This function attempts to write certain number of bytes from a pre-allocated buffer to a slave device, in synchronous way. Partial write might happen, e.g. slave device unable to receive more data. And the number of bytes that have been actually written can be obtained by calling iot_i2c_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>Usually, the first byte is treated as the register address and the following bytes are treated as data to be written. </dd>
<dd>
If eI2CSendNoStopFlag is set and this function returns, whether the actual transaction has been started is undefined. This is board-specific behavior.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Prior to this function, slave address must be already configured. </dd>
<dd>
None of other read or write functions shall be called during this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxI2CPeripheral</td><td>The I2C handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pucBuffer</td><td>The transmit buffer containing the data to be written. It must stay allocated before this function returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_I2C_SUCCESS, on success (all the requested bytes have been written)</li>
<li>IOT_I2C_INVALID_VALUE, if<ul>
<li>pxI2CPeripheral is NULL</li>
<li>pxI2CPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_I2C_SLAVE_ADDRESS_NOT_SET, if slave address is not set yet</li>
<li>IOT_I2C_NACK or IOT_I2C_WRITE_FAILED, if<ul>
<li>no device correspond to the slave address</li>
<li>the slave is unable to receive or transmit</li>
<li>the slave gets data or commands that it does not understand</li>
<li>there is some unknown driver error</li>
</ul>
</li>
<li>IOT_I2C_BUS_TIMEOUT, if timeout is supported and slave device does not respond within configured timeout.</li>
<li>IOT_I2C_BUSY, if the bus is busy which means there is an ongoing transaction. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4a2759a113c8be82ed14bc8059e09ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a2759a113c8be82ed14bc8059e09ff8">&#9670;&nbsp;</a></span>iot_i2c_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_i2c_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxI2CPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pucBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the I2C master read operation in asynchronous mode. </p>
<p>This function attempts to read certain number of bytes from a pre-allocated buffer, in asynchronous way. It returns immediately when the operation is started and the status can be check by calling iot_i2c_ioctl. Once the operation completes, successful or not, the user callback will be invoked.</p>
<p>Partial read might happen, e.g. slave device unable to receive more data. And the number of bytes that have been actually read can be obtained by calling iot_i2c_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>Usually, the address of register needs to be written before calling this function. </dd>
<dd>
If eI2CSendNoStopFlag is set and this function returns, whether the actual transaction has been started is undefined. This is board-specific behavior. </dd>
<dd>
In order to get notification when the asynchronous call is completed, iot_i2c_set_callback must be called prior to this.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Prior to this function, slave address must be already configured. </dd>
<dd>
pucBuffer must be valid before callback is invoked. </dd>
<dd>
None of other read or write functions shall be called during this function or before user callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxI2CPeripheral</td><td>The I2C handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucBuffer</td><td>The receive buffer to read the data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_I2C_SUCCESS, on success</li>
<li>IOT_I2C_INVALID_VALUE, if<ul>
<li>pxI2CPeripheral is NULL</li>
<li>pxI2CPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_I2C_SLAVE_ADDRESS_NOT_SET, if slave address is not set yet</li>
<li>IOT_I2C_NACK or IOT_I2C_READ_FAILED, if<ul>
<li>no device correspond to the slave address</li>
<li>the slave is unable to receive or transmit</li>
<li>the slave gets data or commands that it does not understand</li>
<li>there is some unknown driver error </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab86ebe47dc9c0cb0337f24cf4505f570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab86ebe47dc9c0cb0337f24cf4505f570">&#9670;&nbsp;</a></span>iot_i2c_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_i2c_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxI2CPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pucBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the I2C master write operation in asynchronous mode. </p>
<p>This function attempts to write certain number of bytes from a pre-allocated buffer to a slave device, in asynchronous way. It returns immediately when the operation is started and the status can be check by calling iot_i2c_ioctl. Once the operation completes, successful or not, the user callback will be invoked.</p>
<p>Partial write might happen, e.g. slave device unable to receive more data. And the number of bytes that have been actually written can be obtained by calling iot_i2c_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>Usually, the first byte is treated as the register address and the following bytes are treated as data to be written. </dd>
<dd>
If eI2CSendNoStopFlag is set and this function returns, whether the actual transaction has been started is undefined. This is board-specific behavior. </dd>
<dd>
In order to get notification when the asynchronous call is completed, iot_i2c_set_callback must be called prior to this.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Prior to this function, slave address must be already configured. </dd>
<dd>
None of other read or write functions shall be called during this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxI2CPeripheral</td><td>The I2C handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pucBuffer</td><td>The transmit buffer containing the data to be written. It must stay allocated before this function returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_I2C_SUCCESS, on success</li>
<li>IOT_I2C_INVALID_VALUE, if<ul>
<li>pxI2CPeripheral is NULL</li>
<li>pxI2CPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_I2C_SLAVE_ADDRESS_NOT_SET, if slave address is not set yet</li>
<li>IOT_I2C_NACK or IOT_I2C_WRITE_FAILED, if<ul>
<li>no device correspond to the slave address</li>
<li>the slave is unable to receive or transmit</li>
<li>the slave gets data or commands that it does not understand</li>
<li>there is some unknown driver error</li>
</ul>
</li>
<li>IOT_I2C_BUS_TIMEOUT, if timeout is supported and slave device does not respond within configured timeout.</li>
<li>IOT_I2C_BUSY, if the bus is busy which means there is an ongoing transaction. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad1f7684f8555cf807339aa717733cca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f7684f8555cf807339aa717733cca7">&#9670;&nbsp;</a></span>iot_i2c_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_i2c_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxI2CPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#gaf6c106295bcbda3469e1e4d792a6075d">IotI2CIoctlRequest_t</a>&#160;</td>
          <td class="paramname"><em>xI2CRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the I2C master with user configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxI2CPeripheral</td><td>The I2C handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xI2CRequest</td><td>Should be one of I2C_Ioctl_Request_t. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvBuffer</td><td>The configuration values for the IOCTL request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>SetMasterConfig is expected only called once at beginning. This request expects the buffer with size of <a class="el" href="struct_iot_i2_c_config__t.html" title="I2C bus configuration. ">IotI2CConfig_t</a>.</dd>
<dd>
eI2CGetMasterConfig gets the current configuration for I2C master. This request expects the buffer with size of <a class="el" href="struct_iot_i2_c_config__t.html" title="I2C bus configuration. ">IotI2CConfig_t</a>.</dd>
<dd>
eI2CGetBusState gets the current bus state. This request expects buffer with size of IotI2CBusStatus_t.</dd>
<dd>
eI2CSendNoStopFlag is called at every operation you want to not send stop condition.</dd>
<dd>
eI2CSetSlaveAddr sets either 7-bit address or 10-bit address, according to hardware's capability. This request expects 2 bytes buffer (uint16_t)</dd>
<dd>
eI2CGetTxNoOfbytes returns the number of written bytes in last transaction. This is supposed to be called in the caller task or application callback, right after last transaction completes. This request expects 2 bytes buffer (uint16_t).</dd></dl>
<ul>
<li>If the last transaction only did write, this returns the actual number of written bytes which might be smaller than the requested number (partial write).</li>
<li>If the last transaction only did read, this returns 0.</li>
<li>If the last transaction did both write and read, this returns the number of written bytes.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>eI2CGetRxNoOfbytes returns the number of read bytes in last transaction. This is supposed to be called in the caller task or application callback, right after last transaction completes. This request expects 2 bytes buffer (uint16_t).</dd></dl>
<ul>
<li>If the last transaction only did read, this returns the actual number of read bytes which might be smaller than the requested number (partial read).</li>
<li>If the last transaction only did write, this returns 0.</li>
<li>If the last transaction did both write and read, this returns the number of read bytes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_I2C_SUCCESS, on success</li>
<li>IOT_I2C_INVALID_VALUE, if<ul>
<li>pxI2CPeripheral is NULL</li>
<li>pxI2CPeripheral is not opened yet</li>
<li>pucBuffer is NULL with requests which needs buffer</li>
</ul>
</li>
<li>IOT_I2C_FUNCTION_NOT_SUPPORTED, if this board doesn't support this feature.<ul>
<li>eI2CSetSlaveAddr: 10-bit address is not supported</li>
<li>eI2CSendNoStopFlag: explicitly not sending stop condition is not supported</li>
<li>eI2CBusReset: reset bus is not supported </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4c79a2c4038796eca1333ce1d964a139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c79a2c4038796eca1333ce1d964a139">&#9670;&nbsp;</a></span>iot_i2c_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_i2c_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxI2CPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the ongoing operation and de-initializes the I2C peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxI2CPeripheral</td><td>The I2C handle returned in open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_I2C_SUCCESS, on success</li>
<li>IOT_I2C_INVALID_VALUE, if<ul>
<li>pxI2CPeripheral is NULL</li>
<li>pxI2CPeripheral is not opened yet </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3139a61ef95d7d7c4ee9137b5f78d9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3139a61ef95d7d7c4ee9137b5f78d9f7">&#9670;&nbsp;</a></span>iot_i2c_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_i2c_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__i2c.html#ga6b10b8bf106ac971adacb0ba2d55ce79">IotI2CHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxI2CPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to cancel the current operation in progress, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxI2CPeripheral</td><td>The I2C handle returned in open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_I2C_SUCCESS, on success</li>
<li>IOT_I2C_INVALID_VALUE, if<ul>
<li>pxI2CPeripheral is NULL</li>
<li>pxI2CPeripheral is not opened yet</li>
</ul>
</li>
<li>IOT_I2C_NOTHING_TO_CANCEL, if there is no on-going transaction.</li>
<li>IOT_I2C_FUNCTION_NOT_SUPPORTED, if this board doesn't support this operation. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- This file provides the custom footer for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Generated by
      <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14
    </li>
    <li class="footer">
      Last updated Mon Nov 25 2019
    </li>
    <li class="footer" style="float:left">
    </li>
  </ul>
</div>
</body>
</html>
