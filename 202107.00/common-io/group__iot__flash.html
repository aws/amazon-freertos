<!-- This file provides the custom header for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.14"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
        Common I/O: Flash HAL APIs
    </title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="foobar.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
    <tbody>
        <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">
                    <span id="afrprefix">FreeRTOS:</span>
                    Common I/O
                </div>
                <div id="projectbrief">
                    AWS IoT Common I/O library
                </div>
            </td>
        </tr>
        <tr>
            <td id="returntomain">
                <a href="../index.html">Return to main page &uarr;</a>
            </td>
        </tr>
    </tbody>
    </table>
    </div>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<!-- end header part --><!-- Generated by Doxygen 1.8.14 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__iot__flash.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash HAL APIs</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_flash_info__t.html">IotFlashInfo_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">flash information  <a href="struct_iot_flash_info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_flash_write_protect_config__t.html">IotFlashWriteProtectConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash protection configuration.  <a href="struct_iot_flash_write_protect_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1f9d15bbe1a4f9230f87cc970365fe99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga1f9d15bbe1a4f9230f87cc970365fe99">IOT_FLASH_SUCCESS</a>&#160;&#160;&#160;( 0 )</td></tr>
<tr class="memdesc:ga1f9d15bbe1a4f9230f87cc970365fe99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values used by this driver.  <a href="#ga1f9d15bbe1a4f9230f87cc970365fe99">More...</a><br /></td></tr>
<tr class="separator:ga1f9d15bbe1a4f9230f87cc970365fe99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81aaa62fed3d88f46ba94fe71e452dcd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga81aaa62fed3d88f46ba94fe71e452dcd">IOT_FLASH_INVALID_VALUE</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:ga81aaa62fed3d88f46ba94fe71e452dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c1332da8284618be132176cfadbaef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gab9c1332da8284618be132176cfadbaef">IOT_FLASH_WRITE_FAILED</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="separator:gab9c1332da8284618be132176cfadbaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f892f737ea29f1c2920be3fef8a878"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga77f892f737ea29f1c2920be3fef8a878">IOT_FLASH_READ_FAILED</a>&#160;&#160;&#160;( 3 )</td></tr>
<tr class="separator:ga77f892f737ea29f1c2920be3fef8a878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3cdc25a766663c38c0a08a82027e42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga0a3cdc25a766663c38c0a08a82027e42">IOT_FLASH_ERASE_FAILED</a>&#160;&#160;&#160;( 4 )</td></tr>
<tr class="separator:ga0a3cdc25a766663c38c0a08a82027e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c132308926c9acf1d1ebea1fa3e3c44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga6c132308926c9acf1d1ebea1fa3e3c44">IOT_FLASH_DEVICE_BUSY</a>&#160;&#160;&#160;( 5 )</td></tr>
<tr class="separator:ga6c132308926c9acf1d1ebea1fa3e3c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0240ee98196932a9cbc0e9d13278ac07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga0240ee98196932a9cbc0e9d13278ac07">IOT_FLASH_CTRL_OP_FAILED</a>&#160;&#160;&#160;( 6 )</td></tr>
<tr class="separator:ga0240ee98196932a9cbc0e9d13278ac07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2dc6e2d0eccf30a12a103286d67ad0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gade2dc6e2d0eccf30a12a103286d67ad0">IOT_FLASH_FUNCTION_NOT_SUPPORTED</a>&#160;&#160;&#160;( 7 )</td></tr>
<tr class="separator:gade2dc6e2d0eccf30a12a103286d67ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac4e989320abbbc6b48481f5b9cabe970"><td class="memItemLeft" align="right" valign="top"><a id="gac4e989320abbbc6b48481f5b9cabe970"></a>
typedef struct IotFlashDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a></td></tr>
<tr class="memdesc:gac4e989320abbbc6b48481f5b9cabe970"><td class="mdescLeft">&#160;</td><td class="mdescRight">IotFlashHandle_t type is the flash handle returned by calling <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a> this is initialized in open and returned to caller. Caller must pass this pointer to the rest of the APIs. <br /></td></tr>
<tr class="separator:gac4e989320abbbc6b48481f5b9cabe970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bffee5e74b79fd9446616c4987f0bd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gaf1bffee5e74b79fd9446616c4987f0bd">IotFlashCallback_t</a>) (<a class="el" href="group__iot__flash.html#gafa04f783e4395d3c43472372188964b1">IotFlashOperationStatus_t</a> xStatus, void *pvUserContext)</td></tr>
<tr class="memdesc:gaf1bffee5e74b79fd9446616c4987f0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash notification callback type. This callback can be passed to the driver by using iot_flash_set_callback API (the callback is used only if flash supports asynchronous operations, which can be checked from flashInfo.ucAsyncSupported value.  <a href="#gaf1bffee5e74b79fd9446616c4987f0bd">More...</a><br /></td></tr>
<tr class="separator:gaf1bffee5e74b79fd9446616c4987f0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gacd20e169bc34b6f5aae45d498573e4d1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gacd20e169bc34b6f5aae45d498573e4d1">IotFlashStatus_t</a> { <br />
&#160;&#160;<a class="el" href="group__iot__flash.html#ggacd20e169bc34b6f5aae45d498573e4d1a62b7d78d68e265f071a6c5c95226561a">eFlashIdle</a>, 
<a class="el" href="group__iot__flash.html#ggacd20e169bc34b6f5aae45d498573e4d1a4c9bcc17019b0841278e038a43587452">eFlashCmdInProgress</a>, 
<a class="el" href="group__iot__flash.html#ggacd20e169bc34b6f5aae45d498573e4d1afa12b0e28258c6b7289301cac8bab4dc">eFlashEraseFailed</a>, 
<a class="el" href="group__iot__flash.html#ggacd20e169bc34b6f5aae45d498573e4d1ad4ad35c9694b132084f7cdfceb44dce5">eFlashProgramSuspended</a>, 
<br />
&#160;&#160;<b>eFlashEraseSuspended</b>
<br />
 }</td></tr>
<tr class="memdesc:gacd20e169bc34b6f5aae45d498573e4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash current status.  <a href="group__iot__flash.html#gacd20e169bc34b6f5aae45d498573e4d1">More...</a><br /></td></tr>
<tr class="separator:gacd20e169bc34b6f5aae45d498573e4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa04f783e4395d3c43472372188964b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gafa04f783e4395d3c43472372188964b1">IotFlashOperationStatus_t</a> { <a class="el" href="group__iot__flash.html#ggafa04f783e4395d3c43472372188964b1a6fb157a2b448c1811fecf6e8eb5139a3">eFlashCompleted</a> = IOT_FLASH_SUCCESS, 
<a class="el" href="group__iot__flash.html#ggafa04f783e4395d3c43472372188964b1ad52da42f95bc036169ea507e30e0218f">eFlashLastEraseFailed</a> = IOT_FLASH_ERASE_FAILED, 
<a class="el" href="group__iot__flash.html#ggafa04f783e4395d3c43472372188964b1a8780a317ca838c0b684baf74b31b2cce">eFlashLastReadFailed</a> = IOT_FLASH_READ_FAILED, 
<a class="el" href="group__iot__flash.html#ggafa04f783e4395d3c43472372188964b1a173f89738a7648bb7b34fc854b099555">eFlashLastWriteFailed</a> = IOT_FLASH_WRITE_FAILED
 }</td></tr>
<tr class="memdesc:gafa04f783e4395d3c43472372188964b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash driver last operation status.  <a href="group__iot__flash.html#gafa04f783e4395d3c43472372188964b1">More...</a><br /></td></tr>
<tr class="separator:gafa04f783e4395d3c43472372188964b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb762b29a09b39cfc2ac6e4e46779f10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gafb762b29a09b39cfc2ac6e4e46779f10">IotFlashWriteProtect_t</a> { <a class="el" href="group__iot__flash.html#ggafb762b29a09b39cfc2ac6e4e46779f10a302b7cc744974e3d3a2590042a7d7302">eFlashReadWrite</a>, 
<a class="el" href="group__iot__flash.html#ggafb762b29a09b39cfc2ac6e4e46779f10a2599eb8a70c2210af2b7e04b9cd0c303">eFlashReadOnly</a>
 }</td></tr>
<tr class="memdesc:gafb762b29a09b39cfc2ac6e4e46779f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash sector protection type.  <a href="group__iot__flash.html#gafb762b29a09b39cfc2ac6e4e46779f10">More...</a><br /></td></tr>
<tr class="separator:gafb762b29a09b39cfc2ac6e4e46779f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f92d41621231a065fb29794517d936"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga28f92d41621231a065fb29794517d936">IotFlashIoctlRequest_t</a> { <br />
&#160;&#160;<a class="el" href="group__iot__flash.html#gga28f92d41621231a065fb29794517d936a2177aa2ad1e9c21acbc90d869e128809">eSetFlashBlockProtection</a>, 
<a class="el" href="group__iot__flash.html#gga28f92d41621231a065fb29794517d936a31d2d4bfb00991ecdefa291fee44002a">eGetFlashBlockProtection</a>, 
<a class="el" href="group__iot__flash.html#gga28f92d41621231a065fb29794517d936ae73b30fab7f134c109b25dbdabf64a5c">eSuspendFlashProgramErase</a>, 
<a class="el" href="group__iot__flash.html#gga28f92d41621231a065fb29794517d936a3324563885658a786878554a83407d00">eResumeFlashProgramErase</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__flash.html#gga28f92d41621231a065fb29794517d936a5771fb727bd1b645091e13d56dae30f2">eGetFlashStatus</a>, 
<a class="el" href="group__iot__flash.html#gga28f92d41621231a065fb29794517d936aab8c3c22b5faac2aab78858e45f51ae2">eGetFlashTxNoOfbytes</a>, 
<a class="el" href="group__iot__flash.html#gga28f92d41621231a065fb29794517d936a818aa05dce831a7fdb086f23aa564ac6">eGetFlashRxNoOfbytes</a>
<br />
 }</td></tr>
<tr class="memdesc:ga28f92d41621231a065fb29794517d936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ioctl request types.  <a href="group__iot__flash.html#ga28f92d41621231a065fb29794517d936">More...</a><br /></td></tr>
<tr class="separator:ga28f92d41621231a065fb29794517d936"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga50f778eca5447705287967eaab6e8ea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2">iot_flash_open</a> (int32_t lFlashInstance)</td></tr>
<tr class="memdesc:ga50f778eca5447705287967eaab6e8ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_open is used to initialize the flash device. This must be called before using any other flash APIs. This function Initializes the peripheral, configures buses etc.  <a href="#ga50f778eca5447705287967eaab6e8ea2">More...</a><br /></td></tr>
<tr class="separator:ga50f778eca5447705287967eaab6e8ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7159088510ab0dff69f490ce9a0c7757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_iot_flash_info__t.html">IotFlashInfo_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga7159088510ab0dff69f490ce9a0c7757">iot_flash_getinfo</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle)</td></tr>
<tr class="memdesc:ga7159088510ab0dff69f490ce9a0c7757"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_getinfo is used to get the information about the physical flash device.  <a href="#ga7159088510ab0dff69f490ce9a0c7757">More...</a><br /></td></tr>
<tr class="separator:ga7159088510ab0dff69f490ce9a0c7757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea612a702ba4dbd5b8fbe5b3d97eedfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gaea612a702ba4dbd5b8fbe5b3d97eedfb">iot_flash_set_callback</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle, <a class="el" href="group__iot__flash.html#gaf1bffee5e74b79fd9446616c4987f0bd">IotFlashCallback_t</a> xCallback, void *pvUserContext)</td></tr>
<tr class="memdesc:gaea612a702ba4dbd5b8fbe5b3d97eedfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_set_callback is used to set the callback to be called upon completion of erase/program/read. The callback is used only if the underlying HW supports asynchronous operations. Caller can check if asynchronous operations are supported by checking the "ucAsyncSupported" flag in <a class="el" href="struct_iot_flash_info__t.html" title="flash information ">IotFlashInfo_t</a> structure. If asynchronous operations are not supported, then erase/write/read operations are blocking operations, and this API has no affect, i.e even if a callback is set, it will never be called back.  <a href="#gaea612a702ba4dbd5b8fbe5b3d97eedfb">More...</a><br /></td></tr>
<tr class="separator:gaea612a702ba4dbd5b8fbe5b3d97eedfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76bf68f5f107e5b5f1b56793b102fd27"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga76bf68f5f107e5b5f1b56793b102fd27">iot_flash_ioctl</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle, <a class="el" href="group__iot__flash.html#ga28f92d41621231a065fb29794517d936">IotFlashIoctlRequest_t</a> xRequest, void *const pvBuffer)</td></tr>
<tr class="memdesc:ga76bf68f5f107e5b5f1b56793b102fd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_ioctl is used to configure the flash parameters and setup certain flash operations and also used to read flash info and configuration.  <a href="#ga76bf68f5f107e5b5f1b56793b102fd27">More...</a><br /></td></tr>
<tr class="separator:ga76bf68f5f107e5b5f1b56793b102fd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9617c1dc402696b6e4cc632eb32bf3a2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga9617c1dc402696b6e4cc632eb32bf3a2">iot_flash_erase_sectors</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle, uint32_t ulStartAddress, size_t xSize)</td></tr>
<tr class="memdesc:ga9617c1dc402696b6e4cc632eb32bf3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_erase_sectors is used to erase data in flash from the start of the address specified until the startAddress plus size passed. The address passed in 'ulAddress' must be aligned to ulSectorSize, and size must be a multiple of ulSectorSize. If there is another flash operation is in progress, the erase_sectors API will return an error and this usually happens if flash supports asynchronous erase/write/read operations.  <a href="#ga9617c1dc402696b6e4cc632eb32bf3a2">More...</a><br /></td></tr>
<tr class="separator:ga9617c1dc402696b6e4cc632eb32bf3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa933226a1ebceab85117dec49923cbc0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gaa933226a1ebceab85117dec49923cbc0">iot_flash_erase_chip</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle)</td></tr>
<tr class="memdesc:gaa933226a1ebceab85117dec49923cbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_erase_chip is used to erase the entire flash chip. If there is another flash operation is in progress, the erase_chip API will return an error.  <a href="#gaa933226a1ebceab85117dec49923cbc0">More...</a><br /></td></tr>
<tr class="separator:gaa933226a1ebceab85117dec49923cbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4202fbefdad0d9b0d327a88b9c4bd34a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga4202fbefdad0d9b0d327a88b9c4bd34a">iot_flash_write_sync</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle, uint32_t ulAddress, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga4202fbefdad0d9b0d327a88b9c4bd34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_write_sync is used to write data to flash starting at the address provided. The sector(s) being written to, must be erased first before any write can take place. This is a blocking operation and waits until the number of bytes are written before returning. If there is another flash operation is in progress, write will return an error.  <a href="#ga4202fbefdad0d9b0d327a88b9c4bd34a">More...</a><br /></td></tr>
<tr class="separator:ga4202fbefdad0d9b0d327a88b9c4bd34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28dd7397dc892977fb66de03c6bbc4ac"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga28dd7397dc892977fb66de03c6bbc4ac">iot_flash_read_sync</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle, uint32_t ulAddress, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga28dd7397dc892977fb66de03c6bbc4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_read_sync is used to read data from flash. This is a blocking operation and waits until the number of bytes are read before returning. If there is another flash operation is in progress, this will return an error.  <a href="#ga28dd7397dc892977fb66de03c6bbc4ac">More...</a><br /></td></tr>
<tr class="separator:ga28dd7397dc892977fb66de03c6bbc4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac741ec315ac0acdbd52324e87641da"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gaeac741ec315ac0acdbd52324e87641da">iot_flash_write_async</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle, uint32_t ulAddress, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gaeac741ec315ac0acdbd52324e87641da"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_write_async is used to write data to flash starting at the address provided. The sector(s) being written to, must be erased first before any write can take place. This is an asynchronous (non-blocking) operation and returns as soon as the write operation is started. When the write is completed, user callback is called to notify that the write is complete. The caller can check the status of the operation by using eGetStatus IOCTL. User must register for a callback when using the non-blocking operations to know when they are complete. If there is another flash operation is in progress, write will return an error.  <a href="#gaeac741ec315ac0acdbd52324e87641da">More...</a><br /></td></tr>
<tr class="separator:gaeac741ec315ac0acdbd52324e87641da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c0af22e3f736bc995d48f534d4c347"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#gaf9c0af22e3f736bc995d48f534d4c347">iot_flash_read_async</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle, uint32_t ulAddress, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gaf9c0af22e3f736bc995d48f534d4c347"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_read_async is used to read data from flash. This is an asynchronous (non-blocking) operation and returns as soon as the read operation is started. When the read is completed, user callback is called to notify that the read is complete. The caller can check the status of the operation by using eGetStatus IOCTL and use the buffer. User must register for a callback when using the non-blocking operations to know when they are complete. If there is another flash operation is in progress, this will return an error.  <a href="#gaf9c0af22e3f736bc995d48f534d4c347">More...</a><br /></td></tr>
<tr class="separator:gaf9c0af22e3f736bc995d48f534d4c347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb373990d8ab485ec2e395ce00c843c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__flash.html#ga4fb373990d8ab485ec2e395ce00c843c">iot_flash_close</a> (<a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const pxFlashHandle)</td></tr>
<tr class="memdesc:ga4fb373990d8ab485ec2e395ce00c843c"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_flash_close is used to close the flash device. If any operations are in progress when close is called, flash driver aborts those if possible.  <a href="#ga4fb373990d8ab485ec2e395ce00c843c">More...</a><br /></td></tr>
<tr class="separator:ga4fb373990d8ab485ec2e395ce00c843c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1f9d15bbe1a4f9230f87cc970365fe99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f9d15bbe1a4f9230f87cc970365fe99">&#9670;&nbsp;</a></span>IOT_FLASH_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_FLASH_SUCCESS&#160;&#160;&#160;( 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return values used by this driver. </p>
<p>Flash operation completed succesfully. </p>

</div>
</div>
<a id="ga81aaa62fed3d88f46ba94fe71e452dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81aaa62fed3d88f46ba94fe71e452dcd">&#9670;&nbsp;</a></span>IOT_FLASH_INVALID_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_FLASH_INVALID_VALUE&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>At least one parameter is invalid. </p>

</div>
</div>
<a id="gab9c1332da8284618be132176cfadbaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c1332da8284618be132176cfadbaef">&#9670;&nbsp;</a></span>IOT_FLASH_WRITE_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_FLASH_WRITE_FAILED&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash write operation failed. </p>

</div>
</div>
<a id="ga77f892f737ea29f1c2920be3fef8a878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f892f737ea29f1c2920be3fef8a878">&#9670;&nbsp;</a></span>IOT_FLASH_READ_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_FLASH_READ_FAILED&#160;&#160;&#160;( 3 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash read operation failed. </p>

</div>
</div>
<a id="ga0a3cdc25a766663c38c0a08a82027e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a3cdc25a766663c38c0a08a82027e42">&#9670;&nbsp;</a></span>IOT_FLASH_ERASE_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_FLASH_ERASE_FAILED&#160;&#160;&#160;( 4 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash erase operation failed. </p>

</div>
</div>
<a id="ga6c132308926c9acf1d1ebea1fa3e3c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c132308926c9acf1d1ebea1fa3e3c44">&#9670;&nbsp;</a></span>IOT_FLASH_DEVICE_BUSY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_FLASH_DEVICE_BUSY&#160;&#160;&#160;( 5 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Previous flash operation not complete yet. </p>

</div>
</div>
<a id="ga0240ee98196932a9cbc0e9d13278ac07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0240ee98196932a9cbc0e9d13278ac07">&#9670;&nbsp;</a></span>IOT_FLASH_CTRL_OP_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_FLASH_CTRL_OP_FAILED&#160;&#160;&#160;( 6 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash control operation failed. </p>

</div>
</div>
<a id="gade2dc6e2d0eccf30a12a103286d67ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade2dc6e2d0eccf30a12a103286d67ad0">&#9670;&nbsp;</a></span>IOT_FLASH_FUNCTION_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_FLASH_FUNCTION_NOT_SUPPORTED&#160;&#160;&#160;( 7 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash operation not supported. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf1bffee5e74b79fd9446616c4987f0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1bffee5e74b79fd9446616c4987f0bd">&#9670;&nbsp;</a></span>IotFlashCallback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( *  IotFlashCallback_t) (<a class="el" href="group__iot__flash.html#gafa04f783e4395d3c43472372188964b1">IotFlashOperationStatus_t</a> xStatus, void *pvUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash notification callback type. This callback can be passed to the driver by using iot_flash_set_callback API (the callback is used only if flash supports asynchronous operations, which can be checked from flashInfo.ucAsyncSupported value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">xStatus</td><td>Flash asynchronous operation status. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>User Context passed when setting the callback. This is not used or modified by the driver. The context is provided by the caller when setting the callback, and is passed back to the caller in the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gacd20e169bc34b6f5aae45d498573e4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd20e169bc34b6f5aae45d498573e4d1">&#9670;&nbsp;</a></span>IotFlashStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__flash.html#gacd20e169bc34b6f5aae45d498573e4d1">IotFlashStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash current status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacd20e169bc34b6f5aae45d498573e4d1a62b7d78d68e265f071a6c5c95226561a"></a>eFlashIdle&#160;</td><td class="fielddoc"><p>Flash is idle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd20e169bc34b6f5aae45d498573e4d1a4c9bcc17019b0841278e038a43587452"></a>eFlashCmdInProgress&#160;</td><td class="fielddoc"><p>Flash command in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd20e169bc34b6f5aae45d498573e4d1afa12b0e28258c6b7289301cac8bab4dc"></a>eFlashEraseFailed&#160;</td><td class="fielddoc"><p>Flash erase failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd20e169bc34b6f5aae45d498573e4d1ad4ad35c9694b132084f7cdfceb44dce5"></a>eFlashProgramSuspended&#160;</td><td class="fielddoc"><p>Flash program operation suspended. </p>
</td></tr>
</table>

</div>
</div>
<a id="gafa04f783e4395d3c43472372188964b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa04f783e4395d3c43472372188964b1">&#9670;&nbsp;</a></span>IotFlashOperationStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__flash.html#gafa04f783e4395d3c43472372188964b1">IotFlashOperationStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash driver last operation status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafa04f783e4395d3c43472372188964b1a6fb157a2b448c1811fecf6e8eb5139a3"></a>eFlashCompleted&#160;</td><td class="fielddoc"><p>Flash operation completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafa04f783e4395d3c43472372188964b1ad52da42f95bc036169ea507e30e0218f"></a>eFlashLastEraseFailed&#160;</td><td class="fielddoc"><p>Flash erase operation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafa04f783e4395d3c43472372188964b1a8780a317ca838c0b684baf74b31b2cce"></a>eFlashLastReadFailed&#160;</td><td class="fielddoc"><p>Flash read operation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafa04f783e4395d3c43472372188964b1a173f89738a7648bb7b34fc854b099555"></a>eFlashLastWriteFailed&#160;</td><td class="fielddoc"><p>Flash write operation failed. </p>
</td></tr>
</table>

</div>
</div>
<a id="gafb762b29a09b39cfc2ac6e4e46779f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb762b29a09b39cfc2ac6e4e46779f10">&#9670;&nbsp;</a></span>IotFlashWriteProtect_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__flash.html#gafb762b29a09b39cfc2ac6e4e46779f10">IotFlashWriteProtect_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash sector protection type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafb762b29a09b39cfc2ac6e4e46779f10a302b7cc744974e3d3a2590042a7d7302"></a>eFlashReadWrite&#160;</td><td class="fielddoc"><p>Flash write protect set to read/write </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafb762b29a09b39cfc2ac6e4e46779f10a2599eb8a70c2210af2b7e04b9cd0c303"></a>eFlashReadOnly&#160;</td><td class="fielddoc"><p>Flash write protect set to read only </p>
</td></tr>
</table>

</div>
</div>
<a id="ga28f92d41621231a065fb29794517d936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28f92d41621231a065fb29794517d936">&#9670;&nbsp;</a></span>IotFlashIoctlRequest_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__flash.html#ga28f92d41621231a065fb29794517d936">IotFlashIoctlRequest_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ioctl request types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga28f92d41621231a065fb29794517d936a2177aa2ad1e9c21acbc90d869e128809"></a>eSetFlashBlockProtection&#160;</td><td class="fielddoc"><p>Set block protection, takes the input of <a class="el" href="struct_iot_flash_write_protect_config__t.html" title="Flash protection configuration. ">IotFlashWriteProtectConfig_t</a> type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28f92d41621231a065fb29794517d936a31d2d4bfb00991ecdefa291fee44002a"></a>eGetFlashBlockProtection&#160;</td><td class="fielddoc"><p>Get block protection. takes the input of <a class="el" href="struct_iot_flash_write_protect_config__t.html" title="Flash protection configuration. ">IotFlashWriteProtectConfig_t</a> type and updates the xProtectionLevel for the address passed. ulSize in the input is ignored </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28f92d41621231a065fb29794517d936ae73b30fab7f134c109b25dbdabf64a5c"></a>eSuspendFlashProgramErase&#160;</td><td class="fielddoc"><p>Suspends any program or erase operations. This may be useful if there is an high priority read that needs to happen when program or erase may be in progress. Ex: XiP access </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28f92d41621231a065fb29794517d936a3324563885658a786878554a83407d00"></a>eResumeFlashProgramErase&#160;</td><td class="fielddoc"><p>Resumes any program or erase operation that was previously Suspended using eSuspendFlashProgramErase IOCTL </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28f92d41621231a065fb29794517d936a5771fb727bd1b645091e13d56dae30f2"></a>eGetFlashStatus&#160;</td><td class="fielddoc"><p>Get flash status. Return IotFlashStatus_t type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28f92d41621231a065fb29794517d936aab8c3c22b5faac2aab78858e45f51ae2"></a>eGetFlashTxNoOfbytes&#160;</td><td class="fielddoc"><p>Get the number of bytes sent in write operation. Returns uint32_t type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28f92d41621231a065fb29794517d936a818aa05dce831a7fdb086f23aa564ac6"></a>eGetFlashRxNoOfbytes&#160;</td><td class="fielddoc"><p>Get the number of bytes received in read operation. Returns uint32_t type. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga50f778eca5447705287967eaab6e8ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50f778eca5447705287967eaab6e8ea2">&#9670;&nbsp;</a></span>iot_flash_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> iot_flash_open </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lFlashInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_open is used to initialize the flash device. This must be called before using any other flash APIs. This function Initializes the peripheral, configures buses etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lFlashInstance</td><td>The instance of the flash to initialize. If there are more than one flash per device, the first flash is 0, the second flash is 1 etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>returns the handle IotFlashHandle_t on success</li>
<li>NULL if<ul>
<li>instance number is invalid</li>
<li>same instance is already open. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7159088510ab0dff69f490ce9a0c7757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7159088510ab0dff69f490ce9a0c7757">&#9670;&nbsp;</a></span>iot_flash_getinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_iot_flash_info__t.html">IotFlashInfo_t</a>* iot_flash_getinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_getinfo is used to get the information about the physical flash device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>the pointer to flash information structure <a class="el" href="struct_iot_flash_info__t.html" title="flash information ">IotFlashInfo_t</a></li>
<li>NULL if pxFlashHandle was invalid </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaea612a702ba4dbd5b8fbe5b3d97eedfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea612a702ba4dbd5b8fbe5b3d97eedfb">&#9670;&nbsp;</a></span>iot_flash_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iot_flash_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gaf1bffee5e74b79fd9446616c4987f0bd">IotFlashCallback_t</a>&#160;</td>
          <td class="paramname"><em>xCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvUserContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_set_callback is used to set the callback to be called upon completion of erase/program/read. The callback is used only if the underlying HW supports asynchronous operations. Caller can check if asynchronous operations are supported by checking the "ucAsyncSupported" flag in <a class="el" href="struct_iot_flash_info__t.html" title="flash information ">IotFlashInfo_t</a> structure. If asynchronous operations are not supported, then erase/write/read operations are blocking operations, and this API has no affect, i.e even if a callback is set, it will never be called back. </p>
<dl class="section note"><dt>Note</dt><dd>Single callback is used for asynchronous read / write / erase APIs. </dd>
<dd>
Newly set callback overrides the one previously set </dd>
<dd>
This callback will not be invoked when synchronous operation completes. </dd>
<dd>
This callback is per handle. Each instance has its own callback.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If input handle or if callback function is NULL, this function silently takes no action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCallback</td><td>callback function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>user context to be passed when callback is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga76bf68f5f107e5b5f1b56793b102fd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76bf68f5f107e5b5f1b56793b102fd27">&#9670;&nbsp;</a></span>iot_flash_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_flash_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#ga28f92d41621231a065fb29794517d936">IotFlashIoctlRequest_t</a>&#160;</td>
          <td class="paramname"><em>xRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_ioctl is used to configure the flash parameters and setup certain flash operations and also used to read flash info and configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xRequest</td><td>configuration request of type IotFlashIoctlRequest_t </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvBuffer</td><td>configuration values to be written to flash or to be read from flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_FLASH_SUCCESS on success</li>
<li>IOT_FLASH_INVALID_VALUE on NULL pxFlashHandle, invalid xRequest, or NULL pvBuffer when required.</li>
<li>IOT_FLASH_DEVICE_BUSY if previous flash command still in progress.</li>
<li>IOT_FLASH_CTRL_OP_FAILED if ioctl operation failed for any reason.</li>
<li>IOT_FLASH_FUNCTION_NOT_SUPPORTED valid only for the following if not supported<ul>
<li>eSetFlashBlockProtection / eGetFlashBlockProtection</li>
<li>eSuspendFlashProgramErase / eResumeFlashProgramErase </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9617c1dc402696b6e4cc632eb32bf3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9617c1dc402696b6e4cc632eb32bf3a2">&#9670;&nbsp;</a></span>iot_flash_erase_sectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_flash_erase_sectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulStartAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_erase_sectors is used to erase data in flash from the start of the address specified until the startAddress plus size passed. The address passed in 'ulAddress' must be aligned to ulSectorSize, and size must be a multiple of ulSectorSize. If there is another flash operation is in progress, the erase_sectors API will return an error and this usually happens if flash supports asynchronous erase/write/read operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulStartAddress</td><td>starting address(offset) in flash, from where erase starts. Aligned to ulSectorSize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSize</td><td>size of the flash range to be erased. multiple of ulSectorSize</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_FLASH_SUCCESS on success.</li>
<li>IOT_FLASH_INVALID_VALUE if any parameter is invalid.</li>
<li>IOT_FLASH_DEVICE_BUSY if another asynchronous operation is currently being executed.</li>
<li>IOT_FLASH_ERASE_FAILED on error.</li>
</ul>
</dd></dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><a class="code" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> xFlashHandle;</div><div class="line"><a class="code" href="struct_iot_flash_info__t.html">IotFlashInfo_t</a>* pxFlashInfo;</div><div class="line">int32_t lRetVal;</div><div class="line">uint32_t ulChunkOffset;</div><div class="line"></div><div class="line"><span class="comment">// Open flash to initialize hardware.</span></div><div class="line">xFlashHandle = <a class="code" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2">iot_flash_open</a>(0);</div><div class="line"><span class="comment">// assert(xFlashHandle == NULL );</span></div><div class="line"></div><div class="line"><span class="comment">// Get the flash information.</span></div><div class="line">pxFlashInfo = <a class="code" href="group__iot__flash.html#ga7159088510ab0dff69f490ce9a0c7757">iot_flash_getinfo</a>(xFlashHandle);</div><div class="line"><span class="comment">// assert(pxFlashInfo == NULL);</span></div><div class="line"></div><div class="line"><span class="comment">// If Erase asyc is supported, register a callback</span></div><div class="line"><span class="keywordflow">if</span> ( pxFlashInfo-&gt;<a class="code" href="struct_iot_flash_info__t.html#a0fa2cea90a19ae54851adc41e37928d5">ucAsyncSupported</a> )</div><div class="line">{</div><div class="line">    <a class="code" href="group__iot__flash.html#gaea612a702ba4dbd5b8fbe5b3d97eedfb">iot_flash_set_callback</a>(xFlashHandle,</div><div class="line">                           prvIotFlashEraseCallback,</div><div class="line">                           NULL);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Erase 2 sectors</span></div><div class="line">lRetVal = <a class="code" href="group__iot__flash.html#ga9617c1dc402696b6e4cc632eb32bf3a2">iot_flash_erase_sectors</a>(xFlashHandle,</div><div class="line">                                  ultestIotFlashStartOffset,</div><div class="line">                                  pxFlashInfo-&gt;<a class="code" href="struct_iot_flash_info__t.html#afada0bc019bb806b8233220fcb576321">ulSectorSize</a> * 2);</div><div class="line"><span class="comment">//assert(IOT_FLASH_SUCCESS != lRetVal);</span></div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ( pxFlashInfo-&gt;<a class="code" href="struct_iot_flash_info__t.html#a0fa2cea90a19ae54851adc41e37928d5">ucAsyncSupported</a> )</div><div class="line">{</div><div class="line">    <span class="comment">// Wait for the Erase to be completed and callback is called.</span></div><div class="line">    lRetVal = xSemaphoreTake(xtestIotFlashSemaphore, portMAX_DELAY);</div><div class="line">    <span class="comment">//assert(pdTRUE != lRetVal);</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Close the flash handle.</span></div><div class="line">lRetVal = <a class="code" href="group__iot__flash.html#ga4fb373990d8ab485ec2e395ce00c843c">iot_flash_close</a>(xFlashHandle);</div><div class="line"><span class="comment">//assert(IOT_FLASH_SUCCESS != lRetVal);</span></div></div><!-- fragment --> 
</div>
</div>
<a id="gaa933226a1ebceab85117dec49923cbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa933226a1ebceab85117dec49923cbc0">&#9670;&nbsp;</a></span>iot_flash_erase_chip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_flash_erase_chip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_erase_chip is used to erase the entire flash chip. If there is another flash operation is in progress, the erase_chip API will return an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_FLASH_SUCCESS on success.</li>
<li>IOT_FLASH_INVALID_VALUE if any parameter is invalid.</li>
<li>IOT_FLASH_DEVICE_BUSY if another asynchronous operation is currently being executed.</li>
<li>IOT_FLASH_ERASE_FAILED on error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4202fbefdad0d9b0d327a88b9c4bd34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4202fbefdad0d9b0d327a88b9c4bd34a">&#9670;&nbsp;</a></span>iot_flash_write_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_flash_write_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_write_sync is used to write data to flash starting at the address provided. The sector(s) being written to, must be erased first before any write can take place. This is a blocking operation and waits until the number of bytes are written before returning. If there is another flash operation is in progress, write will return an error. </p>
<dl class="section warning"><dt>Warning</dt><dd>writing to a sector that was not erased first, may result in incorrect data being written while the API returns IOT_FLASH_SUCCESS.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulAddress</td><td>starting address(offset) in flash to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>number of bytes to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>data buffer to write to flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_FLASH_SUCCESS on success.</li>
<li>IOT_FLASH_INVALID_VALUE if any parameter is invalid.</li>
<li>IOT_FLASH_DEVICE_BUSY if another asynchronous operation is currently being executed.</li>
<li>IOT_FLASH_WRITE_FAILED on error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga28dd7397dc892977fb66de03c6bbc4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28dd7397dc892977fb66de03c6bbc4ac">&#9670;&nbsp;</a></span>iot_flash_read_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_flash_read_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_read_sync is used to read data from flash. This is a blocking operation and waits until the number of bytes are read before returning. If there is another flash operation is in progress, this will return an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulAddress</td><td>starting address(offset) in flash to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>number of bytes to be read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>data buffer to hold the data read from flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_FLASH_SUCCESS on success.</li>
<li>IOT_FLASH_INVALID_VALUE if any parameter is invalid.</li>
<li>IOT_FLASH_DEVICE_BUSY if another asynchronous operation is currently being executed.</li>
<li>IOT_FLASH_READ_FAILED on error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaeac741ec315ac0acdbd52324e87641da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeac741ec315ac0acdbd52324e87641da">&#9670;&nbsp;</a></span>iot_flash_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_flash_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_write_async is used to write data to flash starting at the address provided. The sector(s) being written to, must be erased first before any write can take place. This is an asynchronous (non-blocking) operation and returns as soon as the write operation is started. When the write is completed, user callback is called to notify that the write is complete. The caller can check the status of the operation by using eGetStatus IOCTL. User must register for a callback when using the non-blocking operations to know when they are complete. If there is another flash operation is in progress, write will return an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulAddress</td><td>starting address(offset) in flash to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>number of bytes to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>data buffer to write to flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_FLASH_SUCCESS on success.</li>
<li>IOT_FLASH_INVALID_VALUE if any parameter is invalid.</li>
<li>IOT_FLASH_DEVICE_BUSY if another asynchronous operation is currently being executed.</li>
<li>IOT_FLASH_WRITE_FAILED on error.</li>
<li>IOT_FLASH_FUNCTION_NOT_SUPPORTED if asynchronous operation is not supported (i,e ucAsyncSupported is set to false) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf9c0af22e3f736bc995d48f534d4c347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c0af22e3f736bc995d48f534d4c347">&#9670;&nbsp;</a></span>iot_flash_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_flash_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_read_async is used to read data from flash. This is an asynchronous (non-blocking) operation and returns as soon as the read operation is started. When the read is completed, user callback is called to notify that the read is complete. The caller can check the status of the operation by using eGetStatus IOCTL and use the buffer. User must register for a callback when using the non-blocking operations to know when they are complete. If there is another flash operation is in progress, this will return an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulAddress</td><td>starting address(offset) in flash to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>number of bytes to be read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>data buffer to hold the data read from flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_FLASH_SUCCESS on success.</li>
<li>IOT_FLASH_INVALID_VALUE if any parameter is invalid.</li>
<li>IOT_FLASH_DEVICE_BUSY if another asynchronous operation is currently being executed.</li>
<li>IOT_FLASH_READ_FAILED on error.</li>
<li>IOT_FLASH_FUNCTION_NOT_SUPPORTED if asynchronous operation is not supported (i,e ucAsyncSupported is set to false) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4fb373990d8ab485ec2e395ce00c843c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb373990d8ab485ec2e395ce00c843c">&#9670;&nbsp;</a></span>iot_flash_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_flash_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__flash.html#gac4e989320abbbc6b48481f5b9cabe970">IotFlashHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxFlashHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_flash_close is used to close the flash device. If any operations are in progress when close is called, flash driver aborts those if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxFlashHandle</td><td>handle to flash driver returned in <a class="el" href="group__iot__flash.html#ga50f778eca5447705287967eaab6e8ea2" title="iot_flash_open is used to initialize the flash device. This must be called before using any other fla...">iot_flash_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_FLASH_SUCCESS on success close</li>
<li>IOT_FLASH_INVALID_VALUE on invalid pxFlashHandle. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- This file provides the custom footer for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Generated by
      <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14
    </li>
    <li class="footer">
      Last updated Mon Nov 25 2019
    </li>
    <li class="footer" style="float:left">
    </li>
  </ul>
</div>
</body>
</html>
