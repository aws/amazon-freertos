<!-- This file provides the custom header for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.14"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
        Common I/O: SPI Abstraction APIs.
    </title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="foobar.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
    <tbody>
        <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">
                    <span id="afrprefix">FreeRTOS:</span>
                    Common I/O
                </div>
                <div id="projectbrief">
                    AWS IoT Common I/O library
                </div>
            </td>
        </tr>
        <tr>
            <td id="returntomain">
                <a href="../index.html">Return to main page &uarr;</a>
            </td>
        </tr>
    </tbody>
    </table>
    </div>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<!-- end header part --><!-- Generated by Doxygen 1.8.14 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__iot__spi.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI Abstraction APIs.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_s_p_i_master_config__t.html">IotSPIMasterConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration parameters for SPI Master.  <a href="struct_iot_s_p_i_master_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf8e5c74974bb4be4a83756470a2f29c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gaf8e5c74974bb4be4a83756470a2f29c6">IOT_SPI_SUCCESS</a>&#160;&#160;&#160;( 0 )</td></tr>
<tr class="memdesc:gaf8e5c74974bb4be4a83756470a2f29c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return codes for the methods in SPI.  <a href="#gaf8e5c74974bb4be4a83756470a2f29c6">More...</a><br /></td></tr>
<tr class="separator:gaf8e5c74974bb4be4a83756470a2f29c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2743f419116f07a1f53a2bcc5dc5ddff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga2743f419116f07a1f53a2bcc5dc5ddff">IOT_SPI_INVALID_VALUE</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:ga2743f419116f07a1f53a2bcc5dc5ddff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa15e9b5c25675741bb3c6a246f5e749"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gaaa15e9b5c25675741bb3c6a246f5e749">IOT_SPI_WRITE_FAILED</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="separator:gaaa15e9b5c25675741bb3c6a246f5e749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b008ebef1158801cbfa50cc36b5569"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga27b008ebef1158801cbfa50cc36b5569">IOT_SPI_READ_FAILED</a>&#160;&#160;&#160;( 3 )</td></tr>
<tr class="separator:ga27b008ebef1158801cbfa50cc36b5569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91abb1c265ea4747d9d4c99519a150e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gac91abb1c265ea4747d9d4c99519a150e">IOT_SPI_TRANSFER_ERROR</a>&#160;&#160;&#160;( 4 )</td></tr>
<tr class="separator:gac91abb1c265ea4747d9d4c99519a150e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0b8709b1d464733760589a9688a820e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gaa0b8709b1d464733760589a9688a820e">IOT_SPI_BUS_BUSY</a>&#160;&#160;&#160;( 5 )</td></tr>
<tr class="separator:gaa0b8709b1d464733760589a9688a820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae91b6b57d2433c1454e0f89116bb119b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gae91b6b57d2433c1454e0f89116bb119b">IOT_SPI_NOTHING_TO_CANCEL</a>&#160;&#160;&#160;( 6 )</td></tr>
<tr class="separator:gae91b6b57d2433c1454e0f89116bb119b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd7ee0fcf77b6c645a0730cf1d36cf5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gafcd7ee0fcf77b6c645a0730cf1d36cf5">IOT_SPI_FUNCTION_NOT_SUPPORTED</a>&#160;&#160;&#160;( 7 )</td></tr>
<tr class="separator:gafcd7ee0fcf77b6c645a0730cf1d36cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga558e8feb8f9761f4c76dc3549ebbdf01"><td class="memItemLeft" align="right" valign="top"><a id="ga558e8feb8f9761f4c76dc3549ebbdf01"></a>
typedef struct IotSPIDescriptor_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a></td></tr>
<tr class="memdesc:ga558e8feb8f9761f4c76dc3549ebbdf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">IotSPIHandle_t is the handle type returned by calling <a class="el" href="group__iot__spi.html#gab04f5dae2e90600624c3a0d3f738c590" title="Initializes SPI peripheral with default configuration. ">iot_spi_open()</a>. This is initialized in open and returned to caller. The caller must pass this pointer to the rest of APIs. <br /></td></tr>
<tr class="separator:ga558e8feb8f9761f4c76dc3549ebbdf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c5c4ea2f114bb8375d857f09046434"><td class="memItemLeft" align="right" valign="top"><a id="ga09c5c4ea2f114bb8375d857f09046434"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga09c5c4ea2f114bb8375d857f09046434">IotSPICallback_t</a>) (<a class="el" href="group__iot__spi.html#ga2b57ad9fcdb6328a280b667443138f42">IotSPITransactionStatus_t</a> xStatus, void *pvSPIparam)</td></tr>
<tr class="memdesc:ga09c5c4ea2f114bb8375d857f09046434"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback function for completion of SPI operation. <br /></td></tr>
<tr class="separator:ga09c5c4ea2f114bb8375d857f09046434"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2b57ad9fcdb6328a280b667443138f42"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga2b57ad9fcdb6328a280b667443138f42">IotSPITransactionStatus_t</a> { <a class="el" href="group__iot__spi.html#gga2b57ad9fcdb6328a280b667443138f42a80729a2dc5d9376d5dde3d1b9bbce274">eSPISuccess</a> = IOT_SPI_SUCCESS, 
<a class="el" href="group__iot__spi.html#gga2b57ad9fcdb6328a280b667443138f42a8464586134e9c77d5a0b448b499da1c5">eSPIWriteError</a> = IOT_SPI_WRITE_FAILED, 
<a class="el" href="group__iot__spi.html#gga2b57ad9fcdb6328a280b667443138f42a0bc411f65807b3c4d7cc332e7226f027">eSPIReadError</a> = IOT_SPI_READ_FAILED, 
<a class="el" href="group__iot__spi.html#gga2b57ad9fcdb6328a280b667443138f42a25d1d9eb352aedf4bdf9d37c11296850">eSPITransferError</a> = IOT_SPI_TRANSFER_ERROR
 }</td></tr>
<tr class="memdesc:ga2b57ad9fcdb6328a280b667443138f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI return status from Async operations.  <a href="group__iot__spi.html#ga2b57ad9fcdb6328a280b667443138f42">More...</a><br /></td></tr>
<tr class="separator:ga2b57ad9fcdb6328a280b667443138f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1910d0b9a6f9f8e28f212de6b81f0691"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga1910d0b9a6f9f8e28f212de6b81f0691">IotSPIMode_t</a> { <a class="el" href="group__iot__spi.html#gga1910d0b9a6f9f8e28f212de6b81f0691a6f53eaf48f933f9ef9ccc2f96b6a63aa">eSPIMode0</a>, 
<a class="el" href="group__iot__spi.html#gga1910d0b9a6f9f8e28f212de6b81f0691a16a894ae8a26aca4dbcea400284f732b">eSPIMode1</a>, 
<a class="el" href="group__iot__spi.html#gga1910d0b9a6f9f8e28f212de6b81f0691a32123b99ced02cb96658284b9e81624e">eSPIMode2</a>, 
<a class="el" href="group__iot__spi.html#gga1910d0b9a6f9f8e28f212de6b81f0691a78ca1bb66052dd22bf69d554e2686a8d">eSPIMode3</a>
 }</td></tr>
<tr class="memdesc:ga1910d0b9a6f9f8e28f212de6b81f0691"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI Modes denoting the clock polarity and clock phase.  <a href="group__iot__spi.html#ga1910d0b9a6f9f8e28f212de6b81f0691">More...</a><br /></td></tr>
<tr class="separator:ga1910d0b9a6f9f8e28f212de6b81f0691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac715ca60c5007632e4ee57d79424653a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gac715ca60c5007632e4ee57d79424653a">IotSPIBitOrder_t</a> { <a class="el" href="group__iot__spi.html#ggac715ca60c5007632e4ee57d79424653aa78be21884d86087798e9738d1ca4f2d4">eSPIMSBFirst</a>, 
<a class="el" href="group__iot__spi.html#ggac715ca60c5007632e4ee57d79424653aaf83beda2374fda7b744ea54d06572980">eSPILSBFirst</a>
 }</td></tr>
<tr class="memdesc:gac715ca60c5007632e4ee57d79424653a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit order of the data transmission.  <a href="group__iot__spi.html#gac715ca60c5007632e4ee57d79424653a">More...</a><br /></td></tr>
<tr class="separator:gac715ca60c5007632e4ee57d79424653a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc986d7d46ce89ea3b005b4d8a01857"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gaefc986d7d46ce89ea3b005b4d8a01857">IotSPIIoctlRequest_t</a> { <a class="el" href="group__iot__spi.html#ggaefc986d7d46ce89ea3b005b4d8a01857a2520f41c9e68709b03a0d56cb3b95454">eSPISetMasterConfig</a>, 
<a class="el" href="group__iot__spi.html#ggaefc986d7d46ce89ea3b005b4d8a01857ad4f5e4e6085dc35391b4674b76e33109">eSPIGetMasterConfig</a>, 
<a class="el" href="group__iot__spi.html#ggaefc986d7d46ce89ea3b005b4d8a01857abb0c463c4d8d455806f15d5bc302c6e5">eSPIGetTxNoOfbytes</a>, 
<a class="el" href="group__iot__spi.html#ggaefc986d7d46ce89ea3b005b4d8a01857aa9a74341d544e455c5a95258c1dcc3f1">eSPIGetRxNoOfbytes</a>
 }</td></tr>
<tr class="memdesc:gaefc986d7d46ce89ea3b005b4d8a01857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ioctl request for SPI HAL.  <a href="group__iot__spi.html#gaefc986d7d46ce89ea3b005b4d8a01857">More...</a><br /></td></tr>
<tr class="separator:gaefc986d7d46ce89ea3b005b4d8a01857"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab04f5dae2e90600624c3a0d3f738c590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gab04f5dae2e90600624c3a0d3f738c590">iot_spi_open</a> (int32_t lSPIInstance)</td></tr>
<tr class="memdesc:gab04f5dae2e90600624c3a0d3f738c590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes SPI peripheral with default configuration.  <a href="#gab04f5dae2e90600624c3a0d3f738c590">More...</a><br /></td></tr>
<tr class="separator:gab04f5dae2e90600624c3a0d3f738c590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87f74190a187d41a8631f64c24626730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga87f74190a187d41a8631f64c24626730">iot_spi_set_callback</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral, <a class="el" href="group__iot__spi.html#ga09c5c4ea2f114bb8375d857f09046434">IotSPICallback_t</a> xCallback, void *pvUserContext)</td></tr>
<tr class="memdesc:ga87f74190a187d41a8631f64c24626730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application callback to be called on completion of an operation.  <a href="#ga87f74190a187d41a8631f64c24626730">More...</a><br /></td></tr>
<tr class="separator:ga87f74190a187d41a8631f64c24626730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1de8b34b828edf4cabaf6bcb1e0287b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gac1de8b34b828edf4cabaf6bcb1e0287b">iot_spi_ioctl</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral, <a class="el" href="group__iot__spi.html#gaefc986d7d46ce89ea3b005b4d8a01857">IotSPIIoctlRequest_t</a> xSPIRequest, void *const pvBuffer)</td></tr>
<tr class="memdesc:gac1de8b34b828edf4cabaf6bcb1e0287b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the SPI port with user configuration.  <a href="#gac1de8b34b828edf4cabaf6bcb1e0287b">More...</a><br /></td></tr>
<tr class="separator:gac1de8b34b828edf4cabaf6bcb1e0287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90efff448bdc5a14e9bac8a11f89a082"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga90efff448bdc5a14e9bac8a11f89a082">iot_spi_read_sync</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga90efff448bdc5a14e9bac8a11f89a082"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI master starts reading from the slave synchronously.  <a href="#ga90efff448bdc5a14e9bac8a11f89a082">More...</a><br /></td></tr>
<tr class="separator:ga90efff448bdc5a14e9bac8a11f89a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa87f9031947069508907e21265f7c8de"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gaa87f9031947069508907e21265f7c8de">iot_spi_read_async</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gaa87f9031947069508907e21265f7c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI master starts reading from the slave asynchronously.  <a href="#gaa87f9031947069508907e21265f7c8de">More...</a><br /></td></tr>
<tr class="separator:gaa87f9031947069508907e21265f7c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce5a0358181f3a0e05a0f361e21b740"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gabce5a0358181f3a0e05a0f361e21b740">iot_spi_write_sync</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gabce5a0358181f3a0e05a0f361e21b740"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI master starts transmission of data to the slave synchronously.  <a href="#gabce5a0358181f3a0e05a0f361e21b740">More...</a><br /></td></tr>
<tr class="separator:gabce5a0358181f3a0e05a0f361e21b740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9a643dff3318d2e1f33bf8a6743f58"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gabf9a643dff3318d2e1f33bf8a6743f58">iot_spi_write_async</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gabf9a643dff3318d2e1f33bf8a6743f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI master starts transmission of data to the slave asynchronously.  <a href="#gabf9a643dff3318d2e1f33bf8a6743f58">More...</a><br /></td></tr>
<tr class="separator:gabf9a643dff3318d2e1f33bf8a6743f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3974501d1e44671d667d55f17c5a98ba"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga3974501d1e44671d667d55f17c5a98ba">iot_spi_transfer_sync</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral, uint8_t *const pvTxBuffer, uint8_t *const pvRxBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga3974501d1e44671d667d55f17c5a98ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI master starts a synchronous transfer between master and the slave.  <a href="#ga3974501d1e44671d667d55f17c5a98ba">More...</a><br /></td></tr>
<tr class="separator:ga3974501d1e44671d667d55f17c5a98ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d47967ecbbbfa1aedba45b1802a75fb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga2d47967ecbbbfa1aedba45b1802a75fb">iot_spi_transfer_async</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral, uint8_t *const pvTxBuffer, uint8_t *const pvRxBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga2d47967ecbbbfa1aedba45b1802a75fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPI master starts a asynchronous transfer between master and the slave.  <a href="#ga2d47967ecbbbfa1aedba45b1802a75fb">More...</a><br /></td></tr>
<tr class="separator:ga2d47967ecbbbfa1aedba45b1802a75fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3232f9042566c846100e67136c941dc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#gac3232f9042566c846100e67136c941dc">iot_spi_close</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral)</td></tr>
<tr class="memdesc:gac3232f9042566c846100e67136c941dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the ongoing operation on SPI bus and de-initializes the SPI peripheral.  <a href="#gac3232f9042566c846100e67136c941dc">More...</a><br /></td></tr>
<tr class="separator:gac3232f9042566c846100e67136c941dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f5ca51599004f025d2be525d9490e5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga03f5ca51599004f025d2be525d9490e5">iot_spi_cancel</a> (<a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const pxSPIPeripheral)</td></tr>
<tr class="memdesc:ga03f5ca51599004f025d2be525d9490e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to cancel the current operation in progress, if the underlying driver allows the cancellation.  <a href="#ga03f5ca51599004f025d2be525d9490e5">More...</a><br /></td></tr>
<tr class="separator:ga03f5ca51599004f025d2be525d9490e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fdef7c80f7caced69f38d44e9f72a2a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__spi.html#ga0fdef7c80f7caced69f38d44e9f72a2a">iot_spi_select_slave</a> (int32_t lSPIInstance, int32_t lSPISlave)</td></tr>
<tr class="memdesc:ga0fdef7c80f7caced69f38d44e9f72a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to select spi slave.  <a href="#ga0fdef7c80f7caced69f38d44e9f72a2a">More...</a><br /></td></tr>
<tr class="separator:ga0fdef7c80f7caced69f38d44e9f72a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaf8e5c74974bb4be4a83756470a2f29c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e5c74974bb4be4a83756470a2f29c6">&#9670;&nbsp;</a></span>IOT_SPI_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_SPI_SUCCESS&#160;&#160;&#160;( 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The return codes for the methods in SPI. </p>
<p>SPI operation completed successfully. </p>

</div>
</div>
<a id="ga2743f419116f07a1f53a2bcc5dc5ddff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2743f419116f07a1f53a2bcc5dc5ddff">&#9670;&nbsp;</a></span>IOT_SPI_INVALID_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_SPI_INVALID_VALUE&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>At least one parameter is invalid. </p>

</div>
</div>
<a id="gaaa15e9b5c25675741bb3c6a246f5e749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa15e9b5c25675741bb3c6a246f5e749">&#9670;&nbsp;</a></span>IOT_SPI_WRITE_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_SPI_WRITE_FAILED&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI driver returns error when performing write operation. </p>

</div>
</div>
<a id="ga27b008ebef1158801cbfa50cc36b5569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27b008ebef1158801cbfa50cc36b5569">&#9670;&nbsp;</a></span>IOT_SPI_READ_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_SPI_READ_FAILED&#160;&#160;&#160;( 3 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI driver returns error when performing read operation. </p>

</div>
</div>
<a id="gac91abb1c265ea4747d9d4c99519a150e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac91abb1c265ea4747d9d4c99519a150e">&#9670;&nbsp;</a></span>IOT_SPI_TRANSFER_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_SPI_TRANSFER_ERROR&#160;&#160;&#160;( 4 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI driver returns error when performing transfer. </p>

</div>
</div>
<a id="gaa0b8709b1d464733760589a9688a820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0b8709b1d464733760589a9688a820e">&#9670;&nbsp;</a></span>IOT_SPI_BUS_BUSY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_SPI_BUS_BUSY&#160;&#160;&#160;( 5 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI bus is busy at current time. </p>

</div>
</div>
<a id="gae91b6b57d2433c1454e0f89116bb119b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae91b6b57d2433c1454e0f89116bb119b">&#9670;&nbsp;</a></span>IOT_SPI_NOTHING_TO_CANCEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_SPI_NOTHING_TO_CANCEL&#160;&#160;&#160;( 6 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No ongoing operation when cancel operation is performed. </p>

</div>
</div>
<a id="gafcd7ee0fcf77b6c645a0730cf1d36cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcd7ee0fcf77b6c645a0730cf1d36cf5">&#9670;&nbsp;</a></span>IOT_SPI_FUNCTION_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_SPI_FUNCTION_NOT_SUPPORTED&#160;&#160;&#160;( 7 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI operation is not supported. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2b57ad9fcdb6328a280b667443138f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b57ad9fcdb6328a280b667443138f42">&#9670;&nbsp;</a></span>IotSPITransactionStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__spi.html#ga2b57ad9fcdb6328a280b667443138f42">IotSPITransactionStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SPI return status from Async operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2b57ad9fcdb6328a280b667443138f42a80729a2dc5d9376d5dde3d1b9bbce274"></a>eSPISuccess&#160;</td><td class="fielddoc"><p>SPI operation completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2b57ad9fcdb6328a280b667443138f42a8464586134e9c77d5a0b448b499da1c5"></a>eSPIWriteError&#160;</td><td class="fielddoc"><p>SPI driver returns error when performing write operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2b57ad9fcdb6328a280b667443138f42a0bc411f65807b3c4d7cc332e7226f027"></a>eSPIReadError&#160;</td><td class="fielddoc"><p>SPI driver returns error when performing read operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2b57ad9fcdb6328a280b667443138f42a25d1d9eb352aedf4bdf9d37c11296850"></a>eSPITransferError&#160;</td><td class="fielddoc"><p>SPI driver returns error when performing transfer. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1910d0b9a6f9f8e28f212de6b81f0691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1910d0b9a6f9f8e28f212de6b81f0691">&#9670;&nbsp;</a></span>IotSPIMode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__spi.html#ga1910d0b9a6f9f8e28f212de6b81f0691">IotSPIMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SPI Modes denoting the clock polarity and clock phase. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1910d0b9a6f9f8e28f212de6b81f0691a6f53eaf48f933f9ef9ccc2f96b6a63aa"></a>eSPIMode0&#160;</td><td class="fielddoc"><p>CPOL = 0 and CPHA = 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1910d0b9a6f9f8e28f212de6b81f0691a16a894ae8a26aca4dbcea400284f732b"></a>eSPIMode1&#160;</td><td class="fielddoc"><p>CPOL = 0 and CPHA = 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1910d0b9a6f9f8e28f212de6b81f0691a32123b99ced02cb96658284b9e81624e"></a>eSPIMode2&#160;</td><td class="fielddoc"><p>CPOL = 1 and CPHA = 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1910d0b9a6f9f8e28f212de6b81f0691a78ca1bb66052dd22bf69d554e2686a8d"></a>eSPIMode3&#160;</td><td class="fielddoc"><p>CPOL = 1 and CPHA = 1 </p>
</td></tr>
</table>

</div>
</div>
<a id="gac715ca60c5007632e4ee57d79424653a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac715ca60c5007632e4ee57d79424653a">&#9670;&nbsp;</a></span>IotSPIBitOrder_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__spi.html#gac715ca60c5007632e4ee57d79424653a">IotSPIBitOrder_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bit order of the data transmission. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac715ca60c5007632e4ee57d79424653aa78be21884d86087798e9738d1ca4f2d4"></a>eSPIMSBFirst&#160;</td><td class="fielddoc"><p>The master sends the most-significant bit (MSB) first </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac715ca60c5007632e4ee57d79424653aaf83beda2374fda7b744ea54d06572980"></a>eSPILSBFirst&#160;</td><td class="fielddoc"><p>The master sends the least-significant bit (LSB) first </p>
</td></tr>
</table>

</div>
</div>
<a id="gaefc986d7d46ce89ea3b005b4d8a01857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefc986d7d46ce89ea3b005b4d8a01857">&#9670;&nbsp;</a></span>IotSPIIoctlRequest_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__spi.html#gaefc986d7d46ce89ea3b005b4d8a01857">IotSPIIoctlRequest_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ioctl request for SPI HAL. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaefc986d7d46ce89ea3b005b4d8a01857a2520f41c9e68709b03a0d56cb3b95454"></a>eSPISetMasterConfig&#160;</td><td class="fielddoc"><p>Sets the configuration of the SPI master and the data type is <a class="el" href="struct_iot_s_p_i_master_config__t.html" title="The configuration parameters for SPI Master. ">IotSPIMasterConfig_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaefc986d7d46ce89ea3b005b4d8a01857ad4f5e4e6085dc35391b4674b76e33109"></a>eSPIGetMasterConfig&#160;</td><td class="fielddoc"><p>Gets the configuration of the SPI master and the data type is <a class="el" href="struct_iot_s_p_i_master_config__t.html" title="The configuration parameters for SPI Master. ">IotSPIMasterConfig_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaefc986d7d46ce89ea3b005b4d8a01857abb0c463c4d8d455806f15d5bc302c6e5"></a>eSPIGetTxNoOfbytes&#160;</td><td class="fielddoc"><p>Get the number of bytes sent in write operation and the data type is uint16_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaefc986d7d46ce89ea3b005b4d8a01857aa9a74341d544e455c5a95258c1dcc3f1"></a>eSPIGetRxNoOfbytes&#160;</td><td class="fielddoc"><p>Get the number of bytes received in read operation and the data type is uint16_t. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab04f5dae2e90600624c3a0d3f738c590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab04f5dae2e90600624c3a0d3f738c590">&#9670;&nbsp;</a></span>iot_spi_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> iot_spi_open </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lSPIInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes SPI peripheral with default configuration. </p>
<dl class="section warning"><dt>Warning</dt><dd>Once opened, the same SPI instance must be closed before calling open again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lSPIInstance</td><td>The instance of the SPI driver to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>'the handle to the SPI port (not NULL)', on success.</li>
<li>'NULL', if<ul>
<li>invalid instance number</li>
<li>open same instance more than once before closing it </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga87f74190a187d41a8631f64c24626730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87f74190a187d41a8631f64c24626730">&#9670;&nbsp;</a></span>iot_spi_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iot_spi_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga09c5c4ea2f114bb8375d857f09046434">IotSPICallback_t</a>&#160;</td>
          <td class="paramname"><em>xCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvUserContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the application callback to be called on completion of an operation. </p>
<p>The callback is guaranteed to be invoked when the current asynchronous operation completes, either successful or failed. This simply provides a notification mechanism to user's application. It has no impact if the callback is not set.</p>
<dl class="section note"><dt>Note</dt><dd>This callback will not be invoked when synchronous operation completes. </dd>
<dd>
This callback is per handle. Each instance has its own callback. </dd>
<dd>
Single callback is used for both read_async and write_async. Newly set callback overrides the one previously set. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the input handle is invalid, this function silently takes no action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCallback</td><td>The callback function to be called on completion of operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>The user context to be passed back when callback is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1de8b34b828edf4cabaf6bcb1e0287b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1de8b34b828edf4cabaf6bcb1e0287b">&#9670;&nbsp;</a></span>iot_spi_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#gaefc986d7d46ce89ea3b005b4d8a01857">IotSPIIoctlRequest_t</a>&#160;</td>
          <td class="paramname"><em>xSPIRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the SPI port with user configuration. </p>
<dl class="section note"><dt>Note</dt><dd>eSPISetMasterConfig sets the configurations for master. This request expects the buffer with size of <a class="el" href="struct_iot_s_p_i_master_config__t.html" title="The configuration parameters for SPI Master. ">IotSPIMasterConfig_t</a>.</dd>
<dd>
eSPIGetMasterConfig gets the current configuration for SPI master. This request expects the buffer with size of <a class="el" href="struct_iot_s_p_i_master_config__t.html" title="The configuration parameters for SPI Master. ">IotSPIMasterConfig_t</a>.</dd>
<dd>
eSPIGetTxNoOfbytes returns the number of written bytes in last operation. This is supposed to be called in the caller task or application callback, right after last operation completes. This request expects 2 bytes buffer (uint16_t).</dd></dl>
<ul>
<li>If the last operation only did write, this returns the actual number of written bytes which might be smaller than the requested number (partial write).</li>
<li>If the last operation only did read, this returns 0.</li>
<li>If the last operation did both write and read, this returns the number of written bytes.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>eSPIGetRxNoOfbytes returns the number of read bytes in last operation. This is supposed to be called in the caller task or application callback, right after last operation completes. This request expects 2 bytes buffer (uint16_t).</dd></dl>
<ul>
<li>If the last operation only did read, this returns the actual number of read bytes which might be smaller than the requested number (partial read).</li>
<li>If the last operation only did write, this returns 0.</li>
<li>If the last operation did both write and read, this returns the number of read bytes.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSPIRequest</td><td>The configuration request from one of the IotSPIIoctlRequest_t. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvBuffer</td><td>The configuration values for the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet</li>
<li>pucBuffer is NULL with requests which needs buffer</li>
</ul>
</li>
<li>IOT_SPI_BUS_BUSY, if the bus is busy for only following requests:<ul>
<li>eSPISetMasterConfig </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga90efff448bdc5a14e9bac8a11f89a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90efff448bdc5a14e9bac8a11f89a082">&#9670;&nbsp;</a></span>iot_spi_read_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_read_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SPI master starts reading from the slave synchronously. </p>
<p>This function attempts to read certain number of bytes from slave device to a pre-allocated buffer, in synchronous way. This function does not return on paritial read, unless there is an error. And the number of bytes that have been actually read can be obtained by calling iot_spi_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>Dummy data will be written to slave while reading. The dummy data value can be configured with iot_spi_ioctl.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>None of other read or write functions shall be called during this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The buffer to store the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success (all the requested bytes have been read)</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_SPI_READ_ERROR, if there is some unknown driver error.</li>
<li>IOT_SPI_BUSY, if the bus is busy which means there is an ongoing operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa87f9031947069508907e21265f7c8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa87f9031947069508907e21265f7c8de">&#9670;&nbsp;</a></span>iot_spi_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SPI master starts reading from the slave asynchronously. </p>
<p>This function attempts to read certain number of bytes from a pre-allocated buffer, in asynchronous way. It returns immediately when the operation is started and the status can be check by calling iot_spi_ioctl.</p>
<p>Once the operation completes successfully, the user callback will be invoked. If the operation encounters an error, the user callback will be invoked. The callback is not invoked on paritial read, unless there is an error. And the number of bytes that have been actually read can be obtained by calling iot_spi_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>Dummy data will be written to slave while reading. The dummy data value can be configured with iot_spi_ioctl. </dd>
<dd>
In order to get notification when the asynchronous call is completed, iot_spi_set_callback must be called prior to this.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>pvBuffer must be valid before callback is invoked. </dd>
<dd>
None of other read or write functions shall be called during this function or before user callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The buffer to store the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success (all the requested bytes have been read)</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_SPI_READ_ERROR, if there is some unknown driver error.</li>
<li>IOT_SPI_BUSY, if the bus is busy which means there is an ongoing operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabce5a0358181f3a0e05a0f361e21b740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabce5a0358181f3a0e05a0f361e21b740">&#9670;&nbsp;</a></span>iot_spi_write_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_write_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SPI master starts transmission of data to the slave synchronously. </p>
<p>This function attempts to write certain number of bytes from a pre-allocated buffer to a slave device, in synchronous way. This function does not return on paritial write, unless there is an error. And the number of bytes that have been actually written can be obtained by calling iot_spi_ioctl.</p>
<dl class="section warning"><dt>Warning</dt><dd>None of other read or write functions shall be called during this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>The buffer with data to transmit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success (all the requested bytes have been read)</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_SPI_WRITE_ERROR, if there is some unknown driver error.</li>
<li>IOT_SPI_BUSY, if the bus is busy which means there is an ongoing operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabf9a643dff3318d2e1f33bf8a6743f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf9a643dff3318d2e1f33bf8a6743f58">&#9670;&nbsp;</a></span>iot_spi_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SPI master starts transmission of data to the slave asynchronously. </p>
<p>This function attempts to read certain number of bytes from a pre-allocated buffer, in asynchronous way. It returns immediately when the operation is started and the status can be check by calling iot_spi_ioctl.</p>
<p>Once the operation completes successfully, the user callback will be invoked. If the operation encounters an error, the user callback will be invoked. The callback is not invoked on paritial write, unless there is an error. And the number of bytes that have been actually written can be obtained by calling iot_spi_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>In order to get notification when the asynchronous call is completed, iot_spi_set_callback must be called prior to this.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>pvBuffer must be valid before callback is invoked. </dd>
<dd>
None of other read or write functions shall be called during this function or before user callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>The buffer with data to transmit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success (all the requested bytes have been read)</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_SPI_WRITE_ERROR, if there is some unknown driver error.</li>
<li>IOT_SPI_BUSY, if the bus is busy which means there is an ongoing operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3974501d1e44671d667d55f17c5a98ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3974501d1e44671d667d55f17c5a98ba">&#9670;&nbsp;</a></span>iot_spi_transfer_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_transfer_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvTxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvRxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SPI master starts a synchronous transfer between master and the slave. </p>
<p>This function attempts to read/write certain number of bytes from/to two pre-allocated buffers at the same time, in synchronous way. This function does not return on paritial read/write, unless there is an error. And the number of bytes that have been actually read or written can be obtained by calling iot_spi_ioctl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvTxBuffer</td><td>The buffer to store the received data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvRxBuffer</td><td>The buffer with data to transmit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success (all the requested bytes have been read/written)</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_SPI_TRANSFER_ERROR, if there is some unknown driver error.</li>
<li>IOT_SPI_BUSY, if the bus is busy which means there is an ongoing operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2d47967ecbbbfa1aedba45b1802a75fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d47967ecbbbfa1aedba45b1802a75fb">&#9670;&nbsp;</a></span>iot_spi_transfer_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_transfer_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvTxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvRxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SPI master starts a asynchronous transfer between master and the slave. </p>
<p>This function attempts to read/write certain number of bytes from/to two pre-allocated buffers at the same time, in asynchronous way. It returns immediately when the operation is started and the status can be check by calling iot_spi_ioctl.</p>
<p>Once the operation completes successfully, the user callback will be invoked. If the operation encounters an error, the user callback will be invoked. The callback is not invoked on paritial read/write, unless there is an error. And the number of bytes that have been actually read/write can be obtained by calling iot_spi_ioctl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvTxBuffer</td><td>The buffer to store the received data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvRxBuffer</td><td>The buffer with data to transmit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to transfer.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>IOT_SPI_SUCCESS, on success (all the requested bytes have been read/written)</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_SPI_TRANSFER_ERROR, if there is some unknown driver error.</li>
<li>IOT_SPI_BUSY, if the bus is busy which means there is an ongoing opeartion. </li>
</ul>

</div>
</div>
<a id="gac3232f9042566c846100e67136c941dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3232f9042566c846100e67136c941dc">&#9670;&nbsp;</a></span>iot_spi_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the ongoing operation on SPI bus and de-initializes the SPI peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga03f5ca51599004f025d2be525d9490e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03f5ca51599004f025d2be525d9490e5">&#9670;&nbsp;</a></span>iot_spi_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__spi.html#ga558e8feb8f9761f4c76dc3549ebbdf01">IotSPIHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxSPIPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to cancel the current operation in progress, if the underlying driver allows the cancellation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSPIPeripheral</td><td>The SPI peripheral handle returned in open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>pxSPIPeripheral is NULL</li>
<li>pxSPIPeripheral is not opened yet</li>
</ul>
</li>
<li>IOT_SPI_NOTHING_TO_CANCEL, if there is no on-going operation.</li>
<li>IOT_SPI_FUNCTION_NOT_SUPPORTED, if this board doesn't support this operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0fdef7c80f7caced69f38d44e9f72a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fdef7c80f7caced69f38d44e9f72a2a">&#9670;&nbsp;</a></span>iot_spi_select_slave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_spi_select_slave </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lSPIInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lSPISlave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to select spi slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lSPIInstance</td><td>The instance of the SPI driver to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lSPISlave</td><td>Slave select number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_SPI_SUCCESS, on success</li>
<li>IOT_SPI_INVALID_VALUE, if<ul>
<li>lSPISlave is invalid </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- This file provides the custom footer for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Generated by
      <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14
    </li>
    <li class="footer">
      Last updated Mon Nov 25 2019
    </li>
    <li class="footer" style="float:left">
    </li>
  </ul>
</div>
</body>
</html>
