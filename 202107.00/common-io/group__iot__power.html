<!-- This file provides the custom header for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.14"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
        Common I/O: Power HAL APIs
    </title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="foobar.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
    <tbody>
        <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">
                    <span id="afrprefix">FreeRTOS:</span>
                    Common I/O
                </div>
                <div id="projectbrief">
                    AWS IoT Common I/O library
                </div>
            </td>
        </tr>
        <tr>
            <td id="returntomain">
                <a href="../index.html">Return to main page &uarr;</a>
            </td>
        </tr>
    </tbody>
    </table>
    </div>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<!-- end header part --><!-- Generated by Doxygen 1.8.14 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__iot__power.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Power HAL APIs</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_power_wakeup_sources__t.html">IotPowerWakeupSources_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup source information.  <a href="struct_iot_power_wakeup_sources__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga073f0548fec06dc28c8e99dd6925a04c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga073f0548fec06dc28c8e99dd6925a04c">IOT_POWER_SUCCESS</a>&#160;&#160;&#160;( 0 )</td></tr>
<tr class="memdesc:ga073f0548fec06dc28c8e99dd6925a04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values used by the driver.  <a href="#ga073f0548fec06dc28c8e99dd6925a04c">More...</a><br /></td></tr>
<tr class="separator:ga073f0548fec06dc28c8e99dd6925a04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86da222302ac7bcf241472567957d3f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga86da222302ac7bcf241472567957d3f9">IOT_POWER_INVALID_VALUE</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:ga86da222302ac7bcf241472567957d3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef49328ef17d00712c71c1defdd5d772"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#gaef49328ef17d00712c71c1defdd5d772">IOT_POWER_NOT_INITIALIZED</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="separator:gaef49328ef17d00712c71c1defdd5d772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164dd2088e8b69ac4a8818ffb10e0ac9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga164dd2088e8b69ac4a8818ffb10e0ac9">IOT_POWER_GET_FAILED</a>&#160;&#160;&#160;( 3 )</td></tr>
<tr class="separator:ga164dd2088e8b69ac4a8818ffb10e0ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dea30a052cdfed0f5de592f443865cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga9dea30a052cdfed0f5de592f443865cd">IOT_POWER_SET_FAILED</a>&#160;&#160;&#160;( 4 )</td></tr>
<tr class="separator:ga9dea30a052cdfed0f5de592f443865cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa87df195ca018031012c066086ed8100"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#gaa87df195ca018031012c066086ed8100">IOT_POWER_FUNCTION_NOT_SUPPORTED</a>&#160;&#160;&#160;( 5 )</td></tr>
<tr class="separator:gaa87df195ca018031012c066086ed8100"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9c962b7bc78d9761e6eea4b6bc16a5a8"><td class="memItemLeft" align="right" valign="top"><a id="ga9c962b7bc78d9761e6eea4b6bc16a5a8"></a>
typedef struct IotPowerDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a></td></tr>
<tr class="memdesc:ga9c962b7bc78d9761e6eea4b6bc16a5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">IotPowerHandle_t type is the power handle returned by calling <a class="el" href="group__iot__power.html#gae029ebaf20f96e32e5e38c41d6b6f097" title="iot_power_open is used to Initialize the CPU power management driver. power_open sets up the default ...">iot_power_open()</a> this is initialized in open and returned to caller. Caller must pass this pointer to the rest of the APIs. <br /></td></tr>
<tr class="separator:ga9c962b7bc78d9761e6eea4b6bc16a5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fbfd9722dadaf11437948892e52d71"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga37fbfd9722dadaf11437948892e52d71">IotPowerCallback_t</a>) (bool bIdleState, void *pvUserContext)</td></tr>
<tr class="memdesc:ga37fbfd9722dadaf11437948892e52d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback type is used to set a callback for idle enter and exit notification callback type. This callback is used for notifying the registered caller(s) before entering and after coming out of target low power state (i,e:idle/sleep). bIdleState is used to let the caller know if the callback is called when entering or exiting the low power mode. "true" indicates that target is entering idle and "false" indicates that its exiting. The callback is not used for any other mode transitions which are synchronous and blocking. For example when the caller calls a set_mode to eHighPerfMode, the mode is set in the same context and the call is blocking.  <a href="#ga37fbfd9722dadaf11437948892e52d71">More...</a><br /></td></tr>
<tr class="separator:ga37fbfd9722dadaf11437948892e52d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga56e09b75c6dff00aa546ddbcf36d3e24"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga56e09b75c6dff00aa546ddbcf36d3e24">IotPowerMode_t</a> { <a class="el" href="group__iot__power.html#gga56e09b75c6dff00aa546ddbcf36d3e24a8dbf38598a0c8833271f09bc48f9327f">eHighPowerPerfMode</a>, 
<a class="el" href="group__iot__power.html#gga56e09b75c6dff00aa546ddbcf36d3e24a1bedc47c4109202eee9b81c91431bf1f">eNormalPowerPerfMode</a>, 
<a class="el" href="group__iot__power.html#gga56e09b75c6dff00aa546ddbcf36d3e24aff9c9fe47803a46bdadd0bcb5fffd590">eLowPowerPerfMode</a>, 
<a class="el" href="group__iot__power.html#gga56e09b75c6dff00aa546ddbcf36d3e24affd195044b991ce246ebababde913d31">eUnknownPowerMode</a> = 0xFFFF
 }</td></tr>
<tr class="memdesc:ga56e09b75c6dff00aa546ddbcf36d3e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power modes supported by the driver. These power modes may perform different actions on different platforms based on the underlying HW support.  <a href="group__iot__power.html#ga56e09b75c6dff00aa546ddbcf36d3e24">More...</a><br /></td></tr>
<tr class="separator:ga56e09b75c6dff00aa546ddbcf36d3e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224aad48f367b30004b2cfd25fdb3d72"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga224aad48f367b30004b2cfd25fdb3d72">IotPowerIdleMode_t</a> { <a class="el" href="group__iot__power.html#gga224aad48f367b30004b2cfd25fdb3d72affa0c878ae2438f4e5b9e94fac6d3e53">eIdleNoneMode</a>, 
<a class="el" href="group__iot__power.html#gga224aad48f367b30004b2cfd25fdb3d72a83cadf4581d95162f8b4098f98211ffc">eIdlePCMode</a>, 
<a class="el" href="group__iot__power.html#gga224aad48f367b30004b2cfd25fdb3d72a0e6b1199539e6573fb80b836a2c1f3c1">eIdleClkSrcOffModeMode</a>, 
<a class="el" href="group__iot__power.html#gga224aad48f367b30004b2cfd25fdb3d72af6700a6c59ec996af51240fbdb3c09dc">eIdleVddOffMode</a>
 }</td></tr>
<tr class="memdesc:ga224aad48f367b30004b2cfd25fdb3d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different Idle mode mappings to the threshold values set using the IOCTLs.  <a href="group__iot__power.html#ga224aad48f367b30004b2cfd25fdb3d72">More...</a><br /></td></tr>
<tr class="separator:ga224aad48f367b30004b2cfd25fdb3d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75d3829597be038216e288e74e8c95d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#gaf75d3829597be038216e288e74e8c95d">IotPowerIoctlRequest_t</a> { <br />
&#160;&#160;<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95da058a052f5249abc1cfd23bf4a15a6b1a">eSetPCWakeThreshold</a>, 
<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95da9e7084edb6efade0c4770e27c10d1640">eGetPCWakeThreshold</a>, 
<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95dab79e0de4e54a3082a7faa73a8655f43c">eSetClkSrcOffWakeThreshold</a>, 
<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95da6197a93b974bcf94c7d468ef9c399bc8">eGetClkSrcOffWakeThreshold</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95da55bbb237d2403f57f9a131641f714b5d">eSetVddOfffWakeThreshold</a>, 
<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95dab3acb9cbd894ca3b9ac32bdc9750aeb9">eGetVddOfffWakeThreshold</a>, 
<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95dacaf867cb0697a90ff7f304d4499abff6">eSetWakeupSources</a>, 
<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95dac4998f1eaab5a35a7bddd278f467e51f">eGetWakeupSources</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__power.html#ggaf75d3829597be038216e288e74e8c95da0e66439501c2bf3eeb40337a6bd245ea">eGetLastIdleMode</a>
<br />
 }</td></tr>
<tr class="memdesc:gaf75d3829597be038216e288e74e8c95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ioctl request types.  <a href="group__iot__power.html#gaf75d3829597be038216e288e74e8c95d">More...</a><br /></td></tr>
<tr class="separator:gaf75d3829597be038216e288e74e8c95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae029ebaf20f96e32e5e38c41d6b6f097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#gae029ebaf20f96e32e5e38c41d6b6f097">iot_power_open</a> (void)</td></tr>
<tr class="memdesc:gae029ebaf20f96e32e5e38c41d6b6f097"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_power_open is used to Initialize the CPU power management driver. power_open sets up the default mode to eNomralMode, so when the power_open is called, the caller must set the mode using set_mode to a specific mode of interest.  <a href="#gae029ebaf20f96e32e5e38c41d6b6f097">More...</a><br /></td></tr>
<tr class="separator:gae029ebaf20f96e32e5e38c41d6b6f097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42630cef3fe685829f7e9b7415ba6bbc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga42630cef3fe685829f7e9b7415ba6bbc">iot_power_set_mode</a> (<a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const pxPowerHandle, <a class="el" href="group__iot__power.html#ga56e09b75c6dff00aa546ddbcf36d3e24">IotPowerMode_t</a> xMode)</td></tr>
<tr class="memdesc:ga42630cef3fe685829f7e9b7415ba6bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_power_set_mode is used to set or change the power mode to a specific mode. The actual changes made as part of switching to a specific power mode are platform specific. When set_mode is called to switch from high mode to low mode, the target may go through several steps to enter low performance mode. The aggregation of switching to a particular mode must be made prior to calling this, as a call to this API may change the CPU frequency and voltage which may affect the software execution. This API is blocking and the mode switched in the same context as the caller and is a blocking call.  <a href="#ga42630cef3fe685829f7e9b7415ba6bbc">More...</a><br /></td></tr>
<tr class="separator:ga42630cef3fe685829f7e9b7415ba6bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92624c6af6a1e48fa9f0bafb03fa052b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga92624c6af6a1e48fa9f0bafb03fa052b">iot_power_reset_mode</a> (<a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const pxPowerHandle)</td></tr>
<tr class="memdesc:ga92624c6af6a1e48fa9f0bafb03fa052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_power_reset_mode is used to reset the mode (i,e remove the vote to set mode). When reset mode is called, its implicitly notifying the OS to enter deepest low power mode possible in idle state based on existing timers. If a set_mode is called with any of the performance modes with out calling reset_mode, then when target enters idle state, it will not be able to enter deep power states since there is an existing vote for a performance mode from the caller. The target will still do clock gating of the core by doing a WFI and WFE. Additionally, if a reset_mode is called, followed by a get_mode, eUnKnownMode will be returned to the caller. But if reset_mode is called, and then target enters idle state, when coming out of the idle_state it will resume to a known previous state. For example, if we take the following flow:  <a href="#ga92624c6af6a1e48fa9f0bafb03fa052b">More...</a><br /></td></tr>
<tr class="separator:ga92624c6af6a1e48fa9f0bafb03fa052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9403194b6354385ba42e9cab67de6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#gaec9403194b6354385ba42e9cab67de6e">iot_power_set_callback</a> (<a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const pxPowerHandle, <a class="el" href="group__iot__power.html#ga37fbfd9722dadaf11437948892e52d71">IotPowerCallback_t</a> xCallback, void *pvUserContext)</td></tr>
<tr class="memdesc:gaec9403194b6354385ba42e9cab67de6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_power_set_callback is used to set the callback to be called when the target is entering low power mode, and when target is coming out of low power mode. Callback must not use any HW resources when this callback is called with out first requesting for a performance mode.  <a href="#gaec9403194b6354385ba42e9cab67de6e">More...</a><br /></td></tr>
<tr class="separator:gaec9403194b6354385ba42e9cab67de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206f95fdbc8a6bb71017d9c699e0aefc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#ga206f95fdbc8a6bb71017d9c699e0aefc">iot_power_ioctl</a> (<a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const pxPowerHandle, <a class="el" href="group__iot__power.html#gaf75d3829597be038216e288e74e8c95d">IotPowerIoctlRequest_t</a> xRequest, void *const pvBuffer)</td></tr>
<tr class="memdesc:ga206f95fdbc8a6bb71017d9c699e0aefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_power_ioctl is used to set power configuration and power properties like Wakeup time thresholds. Supported IOCTL requests are defined in iot_PowerIoctlRequest_t  <a href="#ga206f95fdbc8a6bb71017d9c699e0aefc">More...</a><br /></td></tr>
<tr class="separator:ga206f95fdbc8a6bb71017d9c699e0aefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc06f80aba7d01ca8b844afa5c1ffd18"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#gabc06f80aba7d01ca8b844afa5c1ffd18">iot_power_get_mode</a> (<a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const pxPowerHandle, <a class="el" href="group__iot__power.html#ga56e09b75c6dff00aa546ddbcf36d3e24">IotPowerMode_t</a> *xMode)</td></tr>
<tr class="memdesc:gabc06f80aba7d01ca8b844afa5c1ffd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_power_get_mode is used to get the current power mode the target is in.  <a href="#gabc06f80aba7d01ca8b844afa5c1ffd18">More...</a><br /></td></tr>
<tr class="separator:gabc06f80aba7d01ca8b844afa5c1ffd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9f9a4c9ea5c99b1d5074f4e9cefdea9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__power.html#gaa9f9a4c9ea5c99b1d5074f4e9cefdea9">iot_power_close</a> (<a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const pxPowerHandle)</td></tr>
<tr class="memdesc:gaa9f9a4c9ea5c99b1d5074f4e9cefdea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">iot_power_close is used to de-initialize power driver.  <a href="#gaa9f9a4c9ea5c99b1d5074f4e9cefdea9">More...</a><br /></td></tr>
<tr class="separator:gaa9f9a4c9ea5c99b1d5074f4e9cefdea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga073f0548fec06dc28c8e99dd6925a04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073f0548fec06dc28c8e99dd6925a04c">&#9670;&nbsp;</a></span>IOT_POWER_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_POWER_SUCCESS&#160;&#160;&#160;( 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return values used by the driver. </p>
<p>Power operation completed successfully. </p>

</div>
</div>
<a id="ga86da222302ac7bcf241472567957d3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86da222302ac7bcf241472567957d3f9">&#9670;&nbsp;</a></span>IOT_POWER_INVALID_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_POWER_INVALID_VALUE&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>At least one parameter is invalid. </p>

</div>
</div>
<a id="gaef49328ef17d00712c71c1defdd5d772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef49328ef17d00712c71c1defdd5d772">&#9670;&nbsp;</a></span>IOT_POWER_NOT_INITIALIZED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_POWER_NOT_INITIALIZED&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Power operation completed successfully. </p>

</div>
</div>
<a id="ga164dd2088e8b69ac4a8818ffb10e0ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164dd2088e8b69ac4a8818ffb10e0ac9">&#9670;&nbsp;</a></span>IOT_POWER_GET_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_POWER_GET_FAILED&#160;&#160;&#160;( 3 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Power get operation failed. </p>

</div>
</div>
<a id="ga9dea30a052cdfed0f5de592f443865cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dea30a052cdfed0f5de592f443865cd">&#9670;&nbsp;</a></span>IOT_POWER_SET_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_POWER_SET_FAILED&#160;&#160;&#160;( 4 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Power set operation failed. </p>

</div>
</div>
<a id="gaa87df195ca018031012c066086ed8100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa87df195ca018031012c066086ed8100">&#9670;&nbsp;</a></span>IOT_POWER_FUNCTION_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_POWER_FUNCTION_NOT_SUPPORTED&#160;&#160;&#160;( 5 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Power operation not supported. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga37fbfd9722dadaf11437948892e52d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fbfd9722dadaf11437948892e52d71">&#9670;&nbsp;</a></span>IotPowerCallback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( *  IotPowerCallback_t) (bool bIdleState, void *pvUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback type is used to set a callback for idle enter and exit notification callback type. This callback is used for notifying the registered caller(s) before entering and after coming out of target low power state (i,e:idle/sleep). bIdleState is used to let the caller know if the callback is called when entering or exiting the low power mode. "true" indicates that target is entering idle and "false" indicates that its exiting. The callback is not used for any other mode transitions which are synchronous and blocking. For example when the caller calls a set_mode to eHighPerfMode, the mode is set in the same context and the call is blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bIdleState</td><td>IdleState set to "true" when entering idle and "false" when exiting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>User Context passed when setting the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga56e09b75c6dff00aa546ddbcf36d3e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e09b75c6dff00aa546ddbcf36d3e24">&#9670;&nbsp;</a></span>IotPowerMode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__power.html#ga56e09b75c6dff00aa546ddbcf36d3e24">IotPowerMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power modes supported by the driver. These power modes may perform different actions on different platforms based on the underlying HW support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga56e09b75c6dff00aa546ddbcf36d3e24a8dbf38598a0c8833271f09bc48f9327f"></a>eHighPowerPerfMode&#160;</td><td class="fielddoc"><p>Set the high performance mode at the SoC level </p>
</td></tr>
<tr><td class="fieldname"><a id="gga56e09b75c6dff00aa546ddbcf36d3e24a1bedc47c4109202eee9b81c91431bf1f"></a>eNormalPowerPerfMode&#160;</td><td class="fielddoc"><p>Set the Normal mode. power_open sets the system to this mode by default </p>
</td></tr>
<tr><td class="fieldname"><a id="gga56e09b75c6dff00aa546ddbcf36d3e24aff9c9fe47803a46bdadd0bcb5fffd590"></a>eLowPowerPerfMode&#160;</td><td class="fielddoc"><p>Set the lower performance mode at the Soc level </p>
</td></tr>
<tr><td class="fieldname"><a id="gga56e09b75c6dff00aa546ddbcf36d3e24affd195044b991ce246ebababde913d31"></a>eUnknownPowerMode&#160;</td><td class="fielddoc"><p>This mode cannot be set, and when a reset_mode is called currentMode will be set to eUnknown </p>
</td></tr>
</table>

</div>
</div>
<a id="ga224aad48f367b30004b2cfd25fdb3d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga224aad48f367b30004b2cfd25fdb3d72">&#9670;&nbsp;</a></span>IotPowerIdleMode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__power.html#ga224aad48f367b30004b2cfd25fdb3d72">IotPowerIdleMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different Idle mode mappings to the threshold values set using the IOCTLs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga224aad48f367b30004b2cfd25fdb3d72affa0c878ae2438f4e5b9e94fac6d3e53"></a>eIdleNoneMode&#160;</td><td class="fielddoc"><p>No Idle mode entered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga224aad48f367b30004b2cfd25fdb3d72a83cadf4581d95162f8b4098f98211ffc"></a>eIdlePCMode&#160;</td><td class="fielddoc"><p>Normal Idle mode with core collapsed or clock gated. Actual mode implementation may differ based on the underlying SoC support. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga224aad48f367b30004b2cfd25fdb3d72a0e6b1199539e6573fb80b836a2c1f3c1"></a>eIdleClkSrcOffModeMode&#160;</td><td class="fielddoc"><p>Source clock off in addition to core collapse. Actual mode implementation may differ based on the underlying SoC support. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga224aad48f367b30004b2cfd25fdb3d72af6700a6c59ec996af51240fbdb3c09dc"></a>eIdleVddOffMode&#160;</td><td class="fielddoc"><p>Vddcore off in addition to clock source and core collapse. Actual mode implementation may differ based on the underlying SoC support. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf75d3829597be038216e288e74e8c95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf75d3829597be038216e288e74e8c95d">&#9670;&nbsp;</a></span>IotPowerIoctlRequest_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__power.html#gaf75d3829597be038216e288e74e8c95d">IotPowerIoctlRequest_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ioctl request types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95da058a052f5249abc1cfd23bf4a15a6b1a"></a>eSetPCWakeThreshold&#160;</td><td class="fielddoc"><p>IdlePCMode is entered when expected idle time provided by RTOS is greater or equal to the PCWakeThreshold. For example - when IdleTask runs, all the other tasks are delayed by a time at least PCWakeThreshold and less than ClkSrcOffWakeThreshold then the device would enter PCMode. Threshold values are uint32_t in millisecond units. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95da9e7084edb6efade0c4770e27c10d1640"></a>eGetPCWakeThreshold&#160;</td><td class="fielddoc"><p>Get Wakeup threshold time. Threshold values are uint32_t in millisecond units. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95dab79e0de4e54a3082a7faa73a8655f43c"></a>eSetClkSrcOffWakeThreshold&#160;</td><td class="fielddoc"><p>ClkSrcOffModeMode is entered when expected idle time provided by RTOS is greater or equal to the ClkSrcOffWakeThreshold. For example - when IdleTask runs, SOC clock sources will be gated for the time you set to ClkSrcOffWakeThreshold then the device would enter ClkSrcOffModeMode. Threshold values are uint32_t in millisecond units. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95da6197a93b974bcf94c7d468ef9c399bc8"></a>eGetClkSrcOffWakeThreshold&#160;</td><td class="fielddoc"><p>Get Clock off threshold time. Threshold values are uint32_t in millisecond units. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95da55bbb237d2403f57f9a131641f714b5d"></a>eSetVddOfffWakeThreshold&#160;</td><td class="fielddoc"><p>VddOffMode is entered when expected idle time provided by RTOS is greater or equal to the VddOfffWakeThreshold. If all idleTask meet this condition, core will shut off to enter VddOffMode. Threshold values are uint32_t in millisecond units. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95dab3acb9cbd894ca3b9ac32bdc9750aeb9"></a>eGetVddOfffWakeThreshold&#160;</td><td class="fielddoc"><p>Get power off (vdd rails off - or lower input voltage etc..) threshold time. Threshold values are uint32_t in millisecond units. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95dacaf867cb0697a90ff7f304d4499abff6"></a>eSetWakeupSources&#160;</td><td class="fielddoc"><p>Set wakeup sources that can wake-up the target from idle modes. Wakeup sources may only be needed for specific idle modes based on the thresholds set above and may are platform/SoC dependent. Takes input of type <a class="el" href="struct_iot_power_wakeup_sources__t.html" title="Wakeup source information. ">IotPowerWakeupSources_t</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95dac4998f1eaab5a35a7bddd278f467e51f"></a>eGetWakeupSources&#160;</td><td class="fielddoc"><p>Get the current wakeup sources set to wakeup the target from idle mode. Returns the wake-up sources as <a class="el" href="struct_iot_power_wakeup_sources__t.html" title="Wakeup source information. ">IotPowerWakeupSources_t</a> type </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf75d3829597be038216e288e74e8c95da0e66439501c2bf3eeb40337a6bd245ea"></a>eGetLastIdleMode&#160;</td><td class="fielddoc"><p>Get the last Idle mode entered when the target was idle. Returns one of the modes defined in IotPowerIdleMode_t </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae029ebaf20f96e32e5e38c41d6b6f097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae029ebaf20f96e32e5e38c41d6b6f097">&#9670;&nbsp;</a></span>iot_power_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> iot_power_open </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_power_open is used to Initialize the CPU power management driver. power_open sets up the default mode to eNomralMode, so when the power_open is called, the caller must set the mode using set_mode to a specific mode of interest. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>handle to power interface on success</li>
<li>NULL if already open </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga42630cef3fe685829f7e9b7415ba6bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42630cef3fe685829f7e9b7415ba6bbc">&#9670;&nbsp;</a></span>iot_power_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_power_set_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxPowerHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga56e09b75c6dff00aa546ddbcf36d3e24">IotPowerMode_t</a>&#160;</td>
          <td class="paramname"><em>xMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_power_set_mode is used to set or change the power mode to a specific mode. The actual changes made as part of switching to a specific power mode are platform specific. When set_mode is called to switch from high mode to low mode, the target may go through several steps to enter low performance mode. The aggregation of switching to a particular mode must be made prior to calling this, as a call to this API may change the CPU frequency and voltage which may affect the software execution. This API is blocking and the mode switched in the same context as the caller and is a blocking call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxPowerHandle</td><td>handle to power driver returned in iot_power_open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xMode</td><td>power mode to be switched to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_POWER_SUCCESS on success</li>
<li>IOT_POWER_INVALID_VALUE if any parameter is invalid</li>
<li>IOT_POWER_SET_FAILED if unable to set to the desired mode</li>
<li>IOT_POWER_FUNCTION_NOT_SUPPORTED if specified mode is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga92624c6af6a1e48fa9f0bafb03fa052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92624c6af6a1e48fa9f0bafb03fa052b">&#9670;&nbsp;</a></span>iot_power_reset_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_power_reset_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxPowerHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_power_reset_mode is used to reset the mode (i,e remove the vote to set mode). When reset mode is called, its implicitly notifying the OS to enter deepest low power mode possible in idle state based on existing timers. If a set_mode is called with any of the performance modes with out calling reset_mode, then when target enters idle state, it will not be able to enter deep power states since there is an existing vote for a performance mode from the caller. The target will still do clock gating of the core by doing a WFI and WFE. Additionally, if a reset_mode is called, followed by a get_mode, eUnKnownMode will be returned to the caller. But if reset_mode is called, and then target enters idle state, when coming out of the idle_state it will resume to a known previous state. For example, if we take the following flow: </p>
<ol type="1">
<li>set_mode(eHighPerformanceMode)   2. reset_modqe() -&gt; At this point the current mode is set to eUnKnownMode   3. Idle checks to see if it can enter a deep power state based on existing timers.   4. If a callback is registered, the callback is called with bIdle set to "true" 4a. The callback can request a mode change causing idle to abort.   5. Target enters Idle state and goes to 'some' deep power state   6. Target wakes up due to external interrupt or scheduled timer interrupt.   7. If a callback is registered, the callback is called with bIdle set to "false"   8. At this point the caller can set the desired performance state.   9. Target is set to eHighPerformanceMode as this was the known mode before entering idle. (optional if mode was not set at #6)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxPowerHandle</td><td>handle to power driver returned in iot_power_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_POWER_SUCCESS on success</li>
<li>IOT_POWER_INVALID_VALUE on pxPowerHandle == NULL</li>
<li>IOT_POWER_FUNCTION_NOT_SUPPORTED if power reset not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaec9403194b6354385ba42e9cab67de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec9403194b6354385ba42e9cab67de6e">&#9670;&nbsp;</a></span>iot_power_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iot_power_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxPowerHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga37fbfd9722dadaf11437948892e52d71">IotPowerCallback_t</a>&#160;</td>
          <td class="paramname"><em>xCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvUserContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_power_set_callback is used to set the callback to be called when the target is entering low power mode, and when target is coming out of low power mode. Callback must not use any HW resources when this callback is called with out first requesting for a performance mode. </p>
<dl class="section note"><dt>Note</dt><dd>Single callback is used for both entering and exiting low power mode. </dd>
<dd>
Newly set callback overrides the one previously set</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If input handle or if callback function is NULL, this function silently takes no action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxPowerHandle</td><td>handle to power driver returned in iot_power_open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCallback</td><td>The callback function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>The user context to be passed when callback is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga206f95fdbc8a6bb71017d9c699e0aefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206f95fdbc8a6bb71017d9c699e0aefc">&#9670;&nbsp;</a></span>iot_power_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_power_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxPowerHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#gaf75d3829597be038216e288e74e8c95d">IotPowerIoctlRequest_t</a>&#160;</td>
          <td class="paramname"><em>xRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_power_ioctl is used to set power configuration and power properties like Wakeup time thresholds. Supported IOCTL requests are defined in iot_PowerIoctlRequest_t </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxPowerHandle</td><td>handle to power driver returned in <a class="el" href="group__iot__power.html#gae029ebaf20f96e32e5e38c41d6b6f097" title="iot_power_open is used to Initialize the CPU power management driver. power_open sets up the default ...">iot_power_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xRequest</td><td>configuration request of type IotPowerIoctlRequest_t </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvBuffer</td><td>buffer holding Power set and get values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_POWER_SUCCESS on success</li>
<li>IOT_POWER_INVALID_VALUE on any invalid parameter</li>
<li>IOT_POWER_FUNCTION_NOT_SUPPORTED for any IotPowerIoctlRequest_t not supported.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: For any Set ioctl that is supported, the corresponding Get ioctl must also be supported. </dd></dl>

</div>
</div>
<a id="gabc06f80aba7d01ca8b844afa5c1ffd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc06f80aba7d01ca8b844afa5c1ffd18">&#9670;&nbsp;</a></span>iot_power_get_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_power_get_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxPowerHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga56e09b75c6dff00aa546ddbcf36d3e24">IotPowerMode_t</a> *&#160;</td>
          <td class="paramname"><em>xMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_power_get_mode is used to get the current power mode the target is in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxPowerHandle</td><td>handle to power driver returned in iot_power_open </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xMode</td><td>current power mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_POWER_SUCCESS on success</li>
<li>IOT_POWER_INVALID_VALUE on pxPowerHandle or xMode being NULL</li>
<li>IOT_POWER_GET_FAILED on error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa9f9a4c9ea5c99b1d5074f4e9cefdea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9f9a4c9ea5c99b1d5074f4e9cefdea9">&#9670;&nbsp;</a></span>iot_power_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_power_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__power.html#ga9c962b7bc78d9761e6eea4b6bc16a5a8">IotPowerHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxPowerHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iot_power_close is used to de-initialize power driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxPowerHandle</td><td>handle to power driver returned in iot_power_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_POWER_SUCCESS on success</li>
<li>IOT_POWER_INVALID_VALUE if<ul>
<li>pxPowerHandle == NULL</li>
<li>not in open state (already closed). </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- This file provides the custom footer for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Generated by
      <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14
    </li>
    <li class="footer">
      Last updated Mon Nov 25 2019
    </li>
    <li class="footer" style="float:left">
    </li>
  </ul>
</div>
</body>
</html>
