<!-- This file provides the custom header for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.14"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
        Common I/O: UART Abstraction APIs.
    </title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="foobar.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
    <tbody>
        <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">
                    <span id="afrprefix">FreeRTOS:</span>
                    Common I/O
                </div>
                <div id="projectbrief">
                    AWS IoT Common I/O library
                </div>
            </td>
        </tr>
        <tr>
            <td id="returntomain">
                <a href="../index.html">Return to main page &uarr;</a>
            </td>
        </tr>
    </tbody>
    </table>
    </div>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<!-- end header part --><!-- Generated by Doxygen 1.8.14 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___i_o_t___u_a_r_t.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART Abstraction APIs.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_u_a_r_t_config__t.html">IotUARTConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration parameters for the UART.  <a href="struct_iot_u_a_r_t_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga118d2e35b63def19ed9a3978c3129dd2"><td class="memItemLeft" align="right" valign="top"><a id="ga118d2e35b63def19ed9a3978c3129dd2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga118d2e35b63def19ed9a3978c3129dd2">IOT_UART_BAUD_RATE_DEFAULT</a>&#160;&#160;&#160;( 115200 )</td></tr>
<tr class="memdesc:ga118d2e35b63def19ed9a3978c3129dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default baud rate for a given UART port. <br /></td></tr>
<tr class="separator:ga118d2e35b63def19ed9a3978c3129dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ea0768c3a6aa784490aaf117118471"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga53ea0768c3a6aa784490aaf117118471">IOT_UART_SUCCESS</a>&#160;&#160;&#160;( 0 )</td></tr>
<tr class="memdesc:ga53ea0768c3a6aa784490aaf117118471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes returned by every function module in UART HAL.  <a href="#ga53ea0768c3a6aa784490aaf117118471">More...</a><br /></td></tr>
<tr class="separator:ga53ea0768c3a6aa784490aaf117118471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed523cc0e9e837c0dd9fb40832a9b7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gaeed523cc0e9e837c0dd9fb40832a9b7b">IOT_UART_INVALID_VALUE</a>&#160;&#160;&#160;( 1 )</td></tr>
<tr class="separator:gaeed523cc0e9e837c0dd9fb40832a9b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa4e1f241385530d9474d3ab17f62e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga7aa4e1f241385530d9474d3ab17f62e3">IOT_UART_WRITE_FAILED</a>&#160;&#160;&#160;( 2 )</td></tr>
<tr class="separator:ga7aa4e1f241385530d9474d3ab17f62e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949a6ddebbdcb11fa000b754a029fe93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga949a6ddebbdcb11fa000b754a029fe93">IOT_UART_READ_FAILED</a>&#160;&#160;&#160;( 3 )</td></tr>
<tr class="separator:ga949a6ddebbdcb11fa000b754a029fe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49703ad4014576ce59505560fb1c836"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gae49703ad4014576ce59505560fb1c836">IOT_UART_BUSY</a>&#160;&#160;&#160;( 4 )</td></tr>
<tr class="separator:gae49703ad4014576ce59505560fb1c836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7c215f920ce006c49e2140d953eb37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga7d7c215f920ce006c49e2140d953eb37">IOT_UART_NOTHING_TO_CANCEL</a>&#160;&#160;&#160;( 5 )</td></tr>
<tr class="separator:ga7d7c215f920ce006c49e2140d953eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf0155ab88aad5a4c1fb5668b02e8dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gaaf0155ab88aad5a4c1fb5668b02e8dc2">IOT_UART_FUNCTION_NOT_SUPPORTED</a>&#160;&#160;&#160;( 6 )</td></tr>
<tr class="separator:gaaf0155ab88aad5a4c1fb5668b02e8dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab4f45c3cd119723cc23fc621deacfa26"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gab4f45c3cd119723cc23fc621deacfa26">IotUARTCallback_t</a>) (<a class="el" href="group___i_o_t___u_a_r_t.html#ga2e6b64e194639b86e2ccb06faf53054c">IotUARTOperationStatus_t</a> xStatus, void *pvUserContext)</td></tr>
<tr class="memdesc:gab4f45c3cd119723cc23fc621deacfa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback function for completion of UART operation.  <a href="#gab4f45c3cd119723cc23fc621deacfa26">More...</a><br /></td></tr>
<tr class="separator:gab4f45c3cd119723cc23fc621deacfa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ccfe155fcf5c7ae44b6956d1c6963b4"><td class="memItemLeft" align="right" valign="top"><a id="ga9ccfe155fcf5c7ae44b6956d1c6963b4"></a>
typedef struct IotUARTDescriptor_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a></td></tr>
<tr class="memdesc:ga9ccfe155fcf5c7ae44b6956d1c6963b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">IotUARTHandle_t is the handle type returned by calling <a class="el" href="group___i_o_t___u_a_r_t.html#ga32ac04310af91b401f583e1440bea904" title="Initializes the UART peripheral of the board. ">iot_uart_open()</a>. This is initialized in open and returned to caller. The caller must pass this pointer to the rest of APIs. <br /></td></tr>
<tr class="separator:ga9ccfe155fcf5c7ae44b6956d1c6963b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2e6b64e194639b86e2ccb06faf53054c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga2e6b64e194639b86e2ccb06faf53054c">IotUARTOperationStatus_t</a> { <a class="el" href="group___i_o_t___u_a_r_t.html#gga2e6b64e194639b86e2ccb06faf53054ca6846be1e11c014e73befe8205e4e40bb">eUartCompleted</a> = IOT_UART_SUCCESS, 
<a class="el" href="group___i_o_t___u_a_r_t.html#gga2e6b64e194639b86e2ccb06faf53054ca312f862e4527c32e66e972529bafdae8">eUartLastWriteFailed</a> = IOT_UART_WRITE_FAILED, 
<a class="el" href="group___i_o_t___u_a_r_t.html#gga2e6b64e194639b86e2ccb06faf53054ca1f994469aec2e0d325b61b6705033b2b">eUartLastReadFailed</a> = IOT_UART_READ_FAILED
 }</td></tr>
<tr class="memdesc:ga2e6b64e194639b86e2ccb06faf53054c"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART read/write operation status values.  <a href="group___i_o_t___u_a_r_t.html#ga2e6b64e194639b86e2ccb06faf53054c">More...</a><br /></td></tr>
<tr class="separator:ga2e6b64e194639b86e2ccb06faf53054c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2527ef08ac87f7b4beccce9d76bf36"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gacd2527ef08ac87f7b4beccce9d76bf36">IotUARTParity_t</a> { <a class="el" href="group___i_o_t___u_a_r_t.html#ggacd2527ef08ac87f7b4beccce9d76bf36ab775b5a669654de41fb3a0d29262f109">eUartParityNone</a>, 
<a class="el" href="group___i_o_t___u_a_r_t.html#ggacd2527ef08ac87f7b4beccce9d76bf36ac311c14849777d24950fa3e4227d460b">eUartParityOdd</a>, 
<a class="el" href="group___i_o_t___u_a_r_t.html#ggacd2527ef08ac87f7b4beccce9d76bf36a6217d48351fc7c0340c77a7e362d990a">eUartParityEven</a>
 }</td></tr>
<tr class="memdesc:gacd2527ef08ac87f7b4beccce9d76bf36"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity mode.  <a href="group___i_o_t___u_a_r_t.html#gacd2527ef08ac87f7b4beccce9d76bf36">More...</a><br /></td></tr>
<tr class="separator:gacd2527ef08ac87f7b4beccce9d76bf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6219589764722b2414fdc326b2303748"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga6219589764722b2414fdc326b2303748">IotUARTStopBits_t</a> { <a class="el" href="group___i_o_t___u_a_r_t.html#gga6219589764722b2414fdc326b2303748ac9b870e5897bed379b900e6da9033701">eUartStopBitsOne</a>, 
<a class="el" href="group___i_o_t___u_a_r_t.html#gga6219589764722b2414fdc326b2303748a167d08edaf63925c1d10096dd7ece6c0">eUartStopBitsTwo</a>
 }</td></tr>
<tr class="memdesc:ga6219589764722b2414fdc326b2303748"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bits.  <a href="group___i_o_t___u_a_r_t.html#ga6219589764722b2414fdc326b2303748">More...</a><br /></td></tr>
<tr class="separator:ga6219589764722b2414fdc326b2303748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b317dec5ae5243cae470e5937cca8d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga5b317dec5ae5243cae470e5937cca8d4">IotUARTIoctlRequest_t</a> { <b>eUartSetConfig</b>, 
<a class="el" href="group___i_o_t___u_a_r_t.html#gga5b317dec5ae5243cae470e5937cca8d4a235ccec5622b37c722f3b0986f7b3361">eUartGetConfig</a>, 
<a class="el" href="group___i_o_t___u_a_r_t.html#gga5b317dec5ae5243cae470e5937cca8d4a9b31bf166ade81ce5e1b8e9c13e82380">eGetTxNoOfbytes</a>, 
<a class="el" href="group___i_o_t___u_a_r_t.html#gga5b317dec5ae5243cae470e5937cca8d4a1ec6346ff4cfdd0022a474323c36c0ff">eGetRxNoOfbytes</a>
 }</td></tr>
<tr class="memdesc:ga5b317dec5ae5243cae470e5937cca8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ioctl requests for UART HAL.  <a href="group___i_o_t___u_a_r_t.html#ga5b317dec5ae5243cae470e5937cca8d4">More...</a><br /></td></tr>
<tr class="separator:ga5b317dec5ae5243cae470e5937cca8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga32ac04310af91b401f583e1440bea904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga32ac04310af91b401f583e1440bea904">iot_uart_open</a> (int32_t lUartInstance)</td></tr>
<tr class="memdesc:ga32ac04310af91b401f583e1440bea904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the UART peripheral of the board.  <a href="#ga32ac04310af91b401f583e1440bea904">More...</a><br /></td></tr>
<tr class="separator:ga32ac04310af91b401f583e1440bea904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad38a1e10c4f2fdd516eca43ebd8e1a12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gad38a1e10c4f2fdd516eca43ebd8e1a12">iot_uart_set_callback</a> (<a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const pxUartPeripheral, <a class="el" href="group___i_o_t___u_a_r_t.html#gab4f45c3cd119723cc23fc621deacfa26">IotUARTCallback_t</a> xCallback, void *pvUserContext)</td></tr>
<tr class="memdesc:gad38a1e10c4f2fdd516eca43ebd8e1a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application callback to be called on completion of an operation.  <a href="#gad38a1e10c4f2fdd516eca43ebd8e1a12">More...</a><br /></td></tr>
<tr class="separator:gad38a1e10c4f2fdd516eca43ebd8e1a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07377025aa5e05cea4872863a254ea6f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga07377025aa5e05cea4872863a254ea6f">iot_uart_read_sync</a> (<a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const pxUartPeripheral, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga07377025aa5e05cea4872863a254ea6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts receiving the data from UART synchronously.  <a href="#ga07377025aa5e05cea4872863a254ea6f">More...</a><br /></td></tr>
<tr class="separator:ga07377025aa5e05cea4872863a254ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d16e738164fbc77527ef6545ebf163"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gab0d16e738164fbc77527ef6545ebf163">iot_uart_write_sync</a> (<a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const pxUartPeripheral, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gab0d16e738164fbc77527ef6545ebf163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the transmission of data from UART synchronously.  <a href="#gab0d16e738164fbc77527ef6545ebf163">More...</a><br /></td></tr>
<tr class="separator:gab0d16e738164fbc77527ef6545ebf163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d3f03f5474aa51d284dc4aefc2da96"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga41d3f03f5474aa51d284dc4aefc2da96">iot_uart_read_async</a> (<a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const pxUartPeripheral, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:ga41d3f03f5474aa51d284dc4aefc2da96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts receiving the data from UART asynchronously.  <a href="#ga41d3f03f5474aa51d284dc4aefc2da96">More...</a><br /></td></tr>
<tr class="separator:ga41d3f03f5474aa51d284dc4aefc2da96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8b837be623972c4fbd67abd6d203d4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gaaa8b837be623972c4fbd67abd6d203d4">iot_uart_write_async</a> (<a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const pxUartPeripheral, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gaaa8b837be623972c4fbd67abd6d203d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the transmission of data from UART asynchronously.  <a href="#gaaa8b837be623972c4fbd67abd6d203d4">More...</a><br /></td></tr>
<tr class="separator:gaaa8b837be623972c4fbd67abd6d203d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea1568e527ac8db1b9ce6a175131228"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gaeea1568e527ac8db1b9ce6a175131228">iot_uart_ioctl</a> (<a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const pxUartPeripheral, <a class="el" href="group___i_o_t___u_a_r_t.html#ga5b317dec5ae5243cae470e5937cca8d4">IotUARTIoctlRequest_t</a> xUartRequest, void *const pvBuffer)</td></tr>
<tr class="memdesc:gaeea1568e527ac8db1b9ce6a175131228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the UART port with user configuration.  <a href="#gaeea1568e527ac8db1b9ce6a175131228">More...</a><br /></td></tr>
<tr class="separator:gaeea1568e527ac8db1b9ce6a175131228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878adb5a8035d55a51d350f7f8ea30bc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#ga878adb5a8035d55a51d350f7f8ea30bc">iot_uart_cancel</a> (<a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const pxUartPeripheral)</td></tr>
<tr class="memdesc:ga878adb5a8035d55a51d350f7f8ea30bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the operation on the UART port if any underlying driver allows cancellation of the operation.  <a href="#ga878adb5a8035d55a51d350f7f8ea30bc">More...</a><br /></td></tr>
<tr class="separator:ga878adb5a8035d55a51d350f7f8ea30bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ce6c614325fa1bae6004bfcdafeafd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_o_t___u_a_r_t.html#gaf5ce6c614325fa1bae6004bfcdafeafd">iot_uart_close</a> (<a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const pxUartPeripheral)</td></tr>
<tr class="memdesc:gaf5ce6c614325fa1bae6004bfcdafeafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the operation and de-initializes the UART peripheral.  <a href="#gaf5ce6c614325fa1bae6004bfcdafeafd">More...</a><br /></td></tr>
<tr class="separator:gaf5ce6c614325fa1bae6004bfcdafeafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga53ea0768c3a6aa784490aaf117118471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ea0768c3a6aa784490aaf117118471">&#9670;&nbsp;</a></span>IOT_UART_SUCCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_UART_SUCCESS&#160;&#160;&#160;( 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes returned by every function module in UART HAL. </p>
<p>UART operation completed successfully. </p>

</div>
</div>
<a id="gaeed523cc0e9e837c0dd9fb40832a9b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeed523cc0e9e837c0dd9fb40832a9b7b">&#9670;&nbsp;</a></span>IOT_UART_INVALID_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_UART_INVALID_VALUE&#160;&#160;&#160;( 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>At least one parameter is invalid. </p>

</div>
</div>
<a id="ga7aa4e1f241385530d9474d3ab17f62e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aa4e1f241385530d9474d3ab17f62e3">&#9670;&nbsp;</a></span>IOT_UART_WRITE_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_UART_WRITE_FAILED&#160;&#160;&#160;( 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART driver returns error when performing write operation. </p>

</div>
</div>
<a id="ga949a6ddebbdcb11fa000b754a029fe93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga949a6ddebbdcb11fa000b754a029fe93">&#9670;&nbsp;</a></span>IOT_UART_READ_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_UART_READ_FAILED&#160;&#160;&#160;( 3 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART driver returns error when performing read operation. </p>

</div>
</div>
<a id="gae49703ad4014576ce59505560fb1c836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae49703ad4014576ce59505560fb1c836">&#9670;&nbsp;</a></span>IOT_UART_BUSY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_UART_BUSY&#160;&#160;&#160;( 4 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART bus is busy at current time. </p>

</div>
</div>
<a id="ga7d7c215f920ce006c49e2140d953eb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7c215f920ce006c49e2140d953eb37">&#9670;&nbsp;</a></span>IOT_UART_NOTHING_TO_CANCEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_UART_NOTHING_TO_CANCEL&#160;&#160;&#160;( 5 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No ongoing operation when cancel is performed. </p>

</div>
</div>
<a id="gaaf0155ab88aad5a4c1fb5668b02e8dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf0155ab88aad5a4c1fb5668b02e8dc2">&#9670;&nbsp;</a></span>IOT_UART_FUNCTION_NOT_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOT_UART_FUNCTION_NOT_SUPPORTED&#160;&#160;&#160;( 6 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART operation is not supported. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab4f45c3cd119723cc23fc621deacfa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4f45c3cd119723cc23fc621deacfa26">&#9670;&nbsp;</a></span>IotUARTCallback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( *  IotUARTCallback_t) (<a class="el" href="group___i_o_t___u_a_r_t.html#ga2e6b64e194639b86e2ccb06faf53054c">IotUARTOperationStatus_t</a> xStatus, void *pvUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback function for completion of UART operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">xStatus</td><td>UART asynchronous operation status. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>User Context passed when setting the callback. This is not used or modified by the driver. The context is provided by the caller when setting the callback, and is passed back to the caller in the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2e6b64e194639b86e2ccb06faf53054c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e6b64e194639b86e2ccb06faf53054c">&#9670;&nbsp;</a></span>IotUARTOperationStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i_o_t___u_a_r_t.html#ga2e6b64e194639b86e2ccb06faf53054c">IotUARTOperationStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART read/write operation status values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2e6b64e194639b86e2ccb06faf53054ca6846be1e11c014e73befe8205e4e40bb"></a>eUartCompleted&#160;</td><td class="fielddoc"><p>UART operation completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e6b64e194639b86e2ccb06faf53054ca312f862e4527c32e66e972529bafdae8"></a>eUartLastWriteFailed&#160;</td><td class="fielddoc"><p>UART driver returns error when performing write operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e6b64e194639b86e2ccb06faf53054ca1f994469aec2e0d325b61b6705033b2b"></a>eUartLastReadFailed&#160;</td><td class="fielddoc"><p>UART driver returns error when performing read operation. </p>
</td></tr>
</table>

</div>
</div>
<a id="gacd2527ef08ac87f7b4beccce9d76bf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd2527ef08ac87f7b4beccce9d76bf36">&#9670;&nbsp;</a></span>IotUARTParity_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i_o_t___u_a_r_t.html#gacd2527ef08ac87f7b4beccce9d76bf36">IotUARTParity_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacd2527ef08ac87f7b4beccce9d76bf36ab775b5a669654de41fb3a0d29262f109"></a>eUartParityNone&#160;</td><td class="fielddoc"><p>UART parity as none. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd2527ef08ac87f7b4beccce9d76bf36ac311c14849777d24950fa3e4227d460b"></a>eUartParityOdd&#160;</td><td class="fielddoc"><p>UART parity as odd. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd2527ef08ac87f7b4beccce9d76bf36a6217d48351fc7c0340c77a7e362d990a"></a>eUartParityEven&#160;</td><td class="fielddoc"><p>UART parity as even. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6219589764722b2414fdc326b2303748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6219589764722b2414fdc326b2303748">&#9670;&nbsp;</a></span>IotUARTStopBits_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i_o_t___u_a_r_t.html#ga6219589764722b2414fdc326b2303748">IotUARTStopBits_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6219589764722b2414fdc326b2303748ac9b870e5897bed379b900e6da9033701"></a>eUartStopBitsOne&#160;</td><td class="fielddoc"><p>UART stop bits is 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6219589764722b2414fdc326b2303748a167d08edaf63925c1d10096dd7ece6c0"></a>eUartStopBitsTwo&#160;</td><td class="fielddoc"><p>UART stop bits is 2. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5b317dec5ae5243cae470e5937cca8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b317dec5ae5243cae470e5937cca8d4">&#9670;&nbsp;</a></span>IotUARTIoctlRequest_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i_o_t___u_a_r_t.html#ga5b317dec5ae5243cae470e5937cca8d4">IotUARTIoctlRequest_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ioctl requests for UART HAL. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5b317dec5ae5243cae470e5937cca8d4a235ccec5622b37c722f3b0986f7b3361"></a>eUartGetConfig&#160;</td><td class="fielddoc"><p>Sets the UART configuration according to . </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5b317dec5ae5243cae470e5937cca8d4a9b31bf166ade81ce5e1b8e9c13e82380"></a>eGetTxNoOfbytes&#160;</td><td class="fielddoc"><p>Gets the UART configuration according to . </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5b317dec5ae5243cae470e5937cca8d4a1ec6346ff4cfdd0022a474323c36c0ff"></a>eGetRxNoOfbytes&#160;</td><td class="fielddoc"><p>Get the number of bytes sent in write operation. Get the number of bytes received in read operation. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga32ac04310af91b401f583e1440bea904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32ac04310af91b401f583e1440bea904">&#9670;&nbsp;</a></span>iot_uart_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> iot_uart_open </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lUartInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the UART peripheral of the board. </p>
<p>The application should call this function to initialize the desired UART port.</p>
<dl class="section warning"><dt>Warning</dt><dd>Once opened, the same UART instance must be closed before calling open again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lUartInstance</td><td>The instance of the UART port to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>'the handle to the UART port (not NULL)', on success.</li>
<li>'NULL', if<ul>
<li>invalid instance number</li>
<li>open same instance more than once before closing it</li>
</ul>
</li>
</ul>
</dd></dl>
<p><b>Example</b> </p><div class="fragment"><div class="line">   <span class="comment">// These two buffers can contain 32 bytes for reading and writing.</span></div><div class="line">   uint8_t cpBuffer[ 32 ] = { 0 };</div><div class="line">   uint8_t cpBufferRead[ 32 ] = { 0 };</div><div class="line"> </div><div class="line">   <a class="code" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> xOpen;</div><div class="line">   int32_t lRead, lWrite, lClose;</div><div class="line">   BaseType_t xCallbackReturn;</div><div class="line">   uint8_t ucPort = 1; <span class="comment">/* Each UART peripheral will be assigned an integer.</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">*  xOpen = iot_uart_open( ucPort );</span></div><div class="line"><span class="comment">*  if( xOpen != NULL )</span></div><div class="line"><span class="comment">*  {</span></div><div class="line"><span class="comment">*      iot_uart_set_callback( xOpen, prvReadWriteCallback, NULL );</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">*      lWrite = iot_uart_write_async( xOpen, cpBuffer, testIotUART_READ_BUFFER_LENGTH );</span></div><div class="line"><span class="comment">*      // assert(IOT_UART_SUCCESS, lWrite)</span></div><div class="line"><span class="comment">*      // Wait for asynchronous write to complete</span></div><div class="line"><span class="comment">*      xCallbackReturn = xSemaphoreTake( ( SemaphoreHandle_t ) &amp;xUartSemaphore, IotUART_DEFAULT_SEMPAHORE_DELAY );</span></div><div class="line"><span class="comment">*      // assert(xCallbackReturn, pdTrue)</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">*      lRead = iot_uart_read_async( xOpen, cpBufferRead, testIotUART_READ_BUFFER_LENGTH );</span></div><div class="line"><span class="comment">*      // assert(IOT_UART_SUCCESS, lRead)</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">*      // Wait for asynchronous read to complete</span></div><div class="line"><span class="comment">*      xCallbackReturn = xSemaphoreTake( ( SemaphoreHandle_t ) &amp;xUartSemaphore, IotUART_DEFAULT_SEMPAHORE_DELAY );</span></div><div class="line"><span class="comment">*      // assert(xCallbackReturn, pdTrue)</span></div><div class="line"><span class="comment">*  }</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">*  lClose = iot_uart_close( xOpen );</span></div><div class="line"><span class="comment">*  // assert(IOT_UART_SUCCESS, lClose)</span></div><div class="line"><span class="comment">*  </span></div></div><!-- fragment --> 
</div>
</div>
<a id="gad38a1e10c4f2fdd516eca43ebd8e1a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad38a1e10c4f2fdd516eca43ebd8e1a12">&#9670;&nbsp;</a></span>iot_uart_set_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iot_uart_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUartPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#gab4f45c3cd119723cc23fc621deacfa26">IotUARTCallback_t</a>&#160;</td>
          <td class="paramname"><em>xCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvUserContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the application callback to be called on completion of an operation. </p>
<p>The callback is guaranteed to be invoked when the current asynchronous operation completes, either successful or failed. This simply provides a notification mechanism to user's application. It has no impact if the callback is not set.</p>
<dl class="section note"><dt>Note</dt><dd>This callback will not be invoked when synchronous operation completes. </dd>
<dd>
This callback is per handle. Each instance has its own callback. </dd>
<dd>
Single callback is used for both read_async and write_async. Newly set callback overrides the one previously set. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the input handle is invalid, this function silently takes no action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUartPeripheral</td><td>The peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCallback</td><td>The callback function to be called on completion of transaction (This can be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>The user context to be passed back when callback is called (This can be NULL). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07377025aa5e05cea4872863a254ea6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07377025aa5e05cea4872863a254ea6f">&#9670;&nbsp;</a></span>iot_uart_read_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_uart_read_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUartPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts receiving the data from UART synchronously. </p>
<p>This function attempts to read certain number of bytes from transmitter device to a pre-allocated buffer, in synchronous way. Partial read might happen, e.g. no more data is available. And the number of bytes that have been actually read can be obtained by calling iot_uart_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>If the number of bytes is not known, it is recommended that the application reads one byte at a time.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>None of other read or write functions shall be called during this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUartPeripheral</td><td>The peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The buffer to store the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IOT_UART_SUCCESS on successful completion of synchronous read, else one of the IOT_UART_INVALID_VALUE, IOT_UART_BUSY, IOT_UART_READ_FAILED on error. </dd>
<dd>
<ul>
<li>IOT_UART_SUCCESS, on success (all the requested bytes have been read)</li>
<li>IOT_UART_INVALID_VALUE, if<ul>
<li>pxUartPeripheral is NULL</li>
<li>pxUartPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_UART_READ_FAILED, if there is unknown driver error</li>
<li>IOT_UART_BUSY, if the bus is busy which means there is an ongoing operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab0d16e738164fbc77527ef6545ebf163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d16e738164fbc77527ef6545ebf163">&#9670;&nbsp;</a></span>iot_uart_write_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_uart_write_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUartPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the transmission of data from UART synchronously. </p>
<p>This function attempts to write certain number of bytes from a pre-allocated buffer to a receiver device, in synchronous way. Partial write might happen, e.g. receiver device unable to receive more data. And the number of bytes that have been actually written can be obtained by calling iot_uart_ioctl.</p>
<dl class="section warning"><dt>Warning</dt><dd>None of other read or write functions shall be called during this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUartPeripheral</td><td>The peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>The buffer with data to transmit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_UART_SUCCESS, on success (all the requested bytes have been write)</li>
<li>IOT_UART_INVALID_VALUE, if<ul>
<li>pxUartPeripheral is NULL</li>
<li>pxUartPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_UART_WRITE_FAILED, if there is unknown driver error</li>
<li>IOT_UART_BUSY, if the bus is busy which means there is an ongoing operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga41d3f03f5474aa51d284dc4aefc2da96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41d3f03f5474aa51d284dc4aefc2da96">&#9670;&nbsp;</a></span>iot_uart_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_uart_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUartPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts receiving the data from UART asynchronously. </p>
<p>This function attempts to read certain number of bytes from a pre-allocated buffer, in asynchronous way. It returns immediately when the operation is started and the status can be check by calling iot_uart_ioctl. Once the operation completes, successful or not, the user callback will be invoked.</p>
<p>Partial read might happen. And the number of bytes that have been actually read can be obtained by calling iot_uart_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>In order to get notification when the asynchronous call is completed, iot_uart_set_callback must be called prior to this. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>pucBuffer must be valid before callback is invoked. </dd>
<dd>
None of other read or write functions shall be called during this function or before user callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUartPeripheral</td><td>The peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The buffer to store the received data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_UART_SUCCESS, on success</li>
<li>IOT_UART_INVALID_VALUE, if<ul>
<li>pxUartPeripheral is NULL</li>
<li>pxUartPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_UART_READ_FAILED, if there is unknown driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaa8b837be623972c4fbd67abd6d203d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8b837be623972c4fbd67abd6d203d4">&#9670;&nbsp;</a></span>iot_uart_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_uart_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUartPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the transmission of data from UART asynchronously. </p>
<p>This function attempts to write certain number of bytes from a pre-allocated buffer to a receiver device, in asynchronous way. It returns immediately when the operation is started and the status can be check by calling iot_uart_ioctl. Once the operation completes, successful or not, the user callback will be invoked.</p>
<p>Partial write might happen. And the number of bytes that have been actually written can be obtained by calling iot_uart_ioctl.</p>
<dl class="section note"><dt>Note</dt><dd>In order to get notification when the asynchronous call is completed, iot_uart_set_callback must be called prior to this.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>None of other read or write functions shall be called during this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUartPeripheral</td><td>The peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>The buffer with data to transmit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_UART_SUCCESS, on success</li>
<li>IOT_UART_INVALID_VALUE, if<ul>
<li>pxUartPeripheral is NULL</li>
<li>pxUartPeripheral is not opened yet</li>
<li>pucBuffer is NULL</li>
<li>xBytes is 0</li>
</ul>
</li>
<li>IOT_UART_WRITE_FAILED, if there is unknown driver error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaeea1568e527ac8db1b9ce6a175131228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeea1568e527ac8db1b9ce6a175131228">&#9670;&nbsp;</a></span>iot_uart_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_uart_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUartPeripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga5b317dec5ae5243cae470e5937cca8d4">IotUARTIoctlRequest_t</a>&#160;</td>
          <td class="paramname"><em>xUartRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the UART port with user configuration. </p>
<dl class="section note"><dt>Note</dt><dd>eUartSetConfig sets the UART configuration. This request expects the buffer with size of <a class="el" href="struct_iot_u_a_r_t_config__t.html" title="Configuration parameters for the UART. ">IotUARTConfig_t</a>.</dd>
<dd>
eUartGetConfig gets the current UART configuration. This request expects the buffer with size of <a class="el" href="struct_iot_u_a_r_t_config__t.html" title="Configuration parameters for the UART. ">IotUARTConfig_t</a>.</dd>
<dd>
eGetTxNoOfbytes returns the number of written bytes in last operation. This is supposed to be called in the caller task or application callback, right after last operation completes. This request expects 2 bytes buffer (uint16_t).</dd></dl>
<ul>
<li>If the last operation was write, this returns the actual number of written bytes which might be smaller than the requested number (partial write).</li>
<li>If the last operation was read, this returns 0.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>eGetRxNoOfbytes returns the number of read bytes in last operation. This is supposed to be called in the caller task or application callback, right after last operation completes. This request expects 2 bytes buffer (uint16_t).</dd></dl>
<ul>
<li>If the last operation was read, this returns the actual number of read bytes which might be smaller than the requested number (partial read).</li>
<li>If the last operation was write, this returns 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUartPeripheral</td><td>The peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUartRequest</td><td>The configuration request. Should be one of the values from IotUARTIoctlRequest_t. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvBuffer</td><td>The configuration values for the UART port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IOT_UART_SUCCESS on successful configuartion of UART port, else one of the IOT_UART_INVALID_VALUE, IOT_UART_BUSY, IOT_UART_FUNCTION_NOT_SUPPORTED on error. </dd>
<dd>
<ul>
<li>IOT_UART_SUCCESS, on success</li>
<li>IOT_UART_INVALID_VALUE, if<ul>
<li>pxUartPeripheral is NULL</li>
<li>pxUartPeripheral is not opened yet</li>
<li>pucBuffer is NULL with requests which needs buffer</li>
</ul>
</li>
<li>IOT_UART_FUNCTION_NOT_SUPPORTED, if this board doesn't support this feature.<ul>
<li>eUartSetConfig: specific configuration is not supported </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga878adb5a8035d55a51d350f7f8ea30bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga878adb5a8035d55a51d350f7f8ea30bc">&#9670;&nbsp;</a></span>iot_uart_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_uart_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUartPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the operation on the UART port if any underlying driver allows cancellation of the operation. </p>
<p>The application should call this function to stop the ongoing operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUartPeripheral</td><td>The peripheral handle returned in the open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_UART_SUCCESS, on success</li>
<li>IOT_UART_INVALID_VALUE, if<ul>
<li>pxUartPeripheral is NULL</li>
<li>pxUartPeripheral is not opened yet</li>
</ul>
</li>
<li>IOT_UART_NOTHING_TO_CANCEL, if there is no on-going transaction.</li>
<li>IOT_UART_FUNCTION_NOT_SUPPORTED, if this board doesn't support this operation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf5ce6c614325fa1bae6004bfcdafeafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5ce6c614325fa1bae6004bfcdafeafd">&#9670;&nbsp;</a></span>iot_uart_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_uart_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i_o_t___u_a_r_t.html#ga9ccfe155fcf5c7ae44b6956d1c6963b4">IotUARTHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUartPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the operation and de-initializes the UART peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUartPeripheral</td><td>The peripheral handle returned in the open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_UART_SUCCESS, on success</li>
<li>IOT_UART_INVALID_VALUE, if<ul>
<li>pxUartPeripheral is NULL</li>
<li>pxUartPeripheral is not opened yet </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- This file provides the custom footer for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Generated by
      <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14
    </li>
    <li class="footer">
      Last updated Mon Nov 25 2019
    </li>
    <li class="footer" style="float:left">
    </li>
  </ul>
</div>
</body>
</html>
