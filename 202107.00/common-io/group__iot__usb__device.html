<!-- This file provides the custom header for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.14"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
        Common I/O: usb device Abstraction APIs.
    </title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="foobar.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
    <table cellspacing="0" cellpadding="0">
    <tbody>
        <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">
                    <span id="afrprefix">FreeRTOS:</span>
                    Common I/O
                </div>
                <div id="projectbrief">
                    AWS IoT Common I/O library
                </div>
            </td>
        </tr>
        <tr>
            <td id="returntomain">
                <a href="../index.html">Return to main page &uarr;</a>
            </td>
        </tr>
    </tbody>
    </table>
    </div>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<!-- end header part --><!-- Generated by Doxygen 1.8.14 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__iot__usb__device.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">usb device Abstraction APIs.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_usb_device_endpoint_config__t.html">IotUsbDeviceEndpointConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint configuration structure.  <a href="struct_iot_usb_device_endpoint_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_iot_usb_device_endpoint_info__t.html">IotUsbDeviceEndpointInfo_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint status structure.  <a href="struct_iot_usb_device_endpoint_info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafef9b113ed9ec0661dad02268665ddde"><td class="memItemLeft" align="right" valign="top"><a id="gafef9b113ed9ec0661dad02268665ddde"></a>
typedef struct IotUsbDevice *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a></td></tr>
<tr class="memdesc:gafef9b113ed9ec0661dad02268665ddde"><td class="mdescLeft">&#160;</td><td class="mdescRight">IotUsbDeviceHandle_t is the handle type returned by calling <a class="el" href="group__iot__usb__device.html#ga6698a89549fa2b3af760362fddac3c0a" title="Initiates the usb device controller interface. ">iot_usb_device_open()</a>. This is initialized in open and returned to caller. The caller must pass this pointer to the rest of APIs. <br /></td></tr>
<tr class="separator:gafef9b113ed9ec0661dad02268665ddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437a049730541ce250069e732c73e657"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga437a049730541ce250069e732c73e657">IotUsbDeviceCallback_t</a>) (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint32_t ulDeviceEvent, void *pvUserContext)</td></tr>
<tr class="memdesc:ga437a049730541ce250069e732c73e657"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback function for USB device event operation. This callback is passed to driver by using iot_usb_device_set_callback API. It's called when one of the events (IotUsbDeviceEvent_t) happen. This callback is used by upper layer to set up upper layer callback by calling iot_usb_device_set_device_callback. It is used when the bus state changes and an event is generated, e.g. an bus reset event happened, usb class layer needs to know such event and react accordingly.  <a href="#ga437a049730541ce250069e732c73e657">More...</a><br /></td></tr>
<tr class="separator:ga437a049730541ce250069e732c73e657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf64a63710a5a8033d845818044c60fd"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gaaf64a63710a5a8033d845818044c60fd">IotUsbDeviceEndpointCallbackFn_t</a>) (<a class="el" href="group__iot__usb__device.html#gac768a7b998f729ec407dcab8252186bf">IotUsbDeviceOperationStatus_t</a> xStatus, void *pvUserContext)</td></tr>
<tr class="memdesc:gaaf64a63710a5a8033d845818044c60fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback typedef for USB device endpoint. For each endpoint, it's passed when user set endpoint callback by iot_usb_device_set_endpoint_callback API. This callback is used to notify the upper layer about the endpoint tranafer result.  <a href="#gaaf64a63710a5a8033d845818044c60fd">More...</a><br /></td></tr>
<tr class="separator:gaaf64a63710a5a8033d845818044c60fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa9fdde19e4564cd6b01aa1a8468a9055"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gaa9fdde19e4564cd6b01aa1a8468a9055">IotUsbDeviceEvent_t</a> { <br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055ad65b106705e0f9120484dde7de12accc">eUSBDeviceBusResetEvent</a>, 
<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055a9d28b253d2d8a296a5e08018ebaf39a2">eUSBDeviceLPMState1Event</a>, 
<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055a08437527442a446ca1e78ab37ded0eee">eUSBDeviceLPMState2Event</a>, 
<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055a0f7ef73ab4282c1f9a83daf8a0f2441e">eUSBDeviceLPMState3Event</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055aa4ec844d3094ec7743eac8dc3ebf4c6a">eUSBDeviceLPMState1ResumeEvent</a>, 
<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055a6844b06d50c73c1b55e5299ec34cdc59">eUSBDeviceLPMState2ResumeEvent</a>, 
<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055ae538d4e891b43c6ead52df1ced05d609">eUSBDeviceLPMState3ResumeEvent</a>, 
<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055aacff1058e6a7726725b97635baad1fd5">eUSBDeviceErrorEvent</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055a8e09cdcf6152457ed088cf2ab163f99d">eUSBDeviceDetachEvent</a>, 
<a class="el" href="group__iot__usb__device.html#ggaa9fdde19e4564cd6b01aa1a8468a9055a663a3b5a26057883cdc1ebc0e5c546cf">eUSBDeviceAttachEvent</a>
<br />
 }</td></tr>
<tr class="memdesc:gaa9fdde19e4564cd6b01aa1a8468a9055"><td class="mdescLeft">&#160;</td><td class="mdescRight">common notify event types in device callback.  <a href="group__iot__usb__device.html#gaa9fdde19e4564cd6b01aa1a8468a9055">More...</a><br /></td></tr>
<tr class="separator:gaa9fdde19e4564cd6b01aa1a8468a9055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f1397e05c95d52de786262d04ae9f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga34f1397e05c95d52de786262d04ae9f6">IotUsbDeviceIoctlRequest_t</a> { <br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a23f12407318123e9c62f237000d7b435">eUSBDeviceGetSpeed</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a6820c49b295bef9d7f7a31504e0c1cdd">eUSBDeviceGetAddress</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6aa22fa0d10e8e6e1cb434ce4d73748006">eUSBDeviceSetAddress</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a2ad1cf70a51f28b730b1e76b09d8cac1">eUSBDeviceGetEndpointStatus</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6afb17fc0bd7778af9736174db724bf0ac">eUSBDeviceGetState</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a869be5f7e969dd2aaf89be61d8b1c8b4">eUSBDeviceGetStatus</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6ad01a775e5fc0b722fe4afed4e4b8c321">eUSBDeviceGetSyncFrame</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a83e8bbffcbffa50c8ea2951ac197d00c">eUSBDeviceSetTestMode</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a6ce0a867e790fe9ecdf8926a45c0c407">eUSBDeviceSetState</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a8478a49ac8cfbe6ae877e914baefe752">eUSBDeviceLPMState1Suspend</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a91525aabaa49c7ec8b48d09426f48469">eUSBDeviceLPMState1Resume</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6af028596a084313d81ee06fff3be6831a">eUSBDeviceLPMState2Suspend</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a67cdf86203ad2877be23e208862dff80">eUSBDeviceLPMState2Resume</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a0cc555bf76fb5dbad07f6a0ad022c961">eUSBDeviceLPMState3Suspend</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6a4751ec41cda30671c829a75abc083f18">eUSBDeviceLPMState3Resume</a>, 
<a class="el" href="group__iot__usb__device.html#gga34f1397e05c95d52de786262d04ae9f6afd7a008e098c835ae1be1db2e84082f7">eUSBDeviceRemoteWakeup</a>
<br />
 }</td></tr>
<tr class="memdesc:ga34f1397e05c95d52de786262d04ae9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ioctl request types.  <a href="group__iot__usb__device.html#ga34f1397e05c95d52de786262d04ae9f6">More...</a><br /></td></tr>
<tr class="separator:ga34f1397e05c95d52de786262d04ae9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe647831f6bbcb1a0e57d79dd17b6540"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gabe647831f6bbcb1a0e57d79dd17b6540">IotUsbDeviceState_t</a> { <br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#ggabe647831f6bbcb1a0e57d79dd17b6540a8d42ab931c780bfa2667272a7c2772d3">eUsbDeviceStateConfigured</a>, 
<a class="el" href="group__iot__usb__device.html#ggabe647831f6bbcb1a0e57d79dd17b6540afe6e254ebf34234957ad32f786d02b50">eUsbDeviceStateAddress</a>, 
<a class="el" href="group__iot__usb__device.html#ggabe647831f6bbcb1a0e57d79dd17b6540a5f62fe36e0657f6f328fda75f8738225">eUsbDeviceStateDefault</a>, 
<a class="el" href="group__iot__usb__device.html#ggabe647831f6bbcb1a0e57d79dd17b6540a5c356a18c9e773195a4456be402b9709">eUsbDeviceStateAddressing</a>, 
<br />
&#160;&#160;<a class="el" href="group__iot__usb__device.html#ggabe647831f6bbcb1a0e57d79dd17b6540ae5463617abb9039e150ee439bb30b6c6">eUsbDeviceStateTestMode</a>
<br />
 }</td></tr>
<tr class="memdesc:gabe647831f6bbcb1a0e57d79dd17b6540"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB device state.  <a href="group__iot__usb__device.html#gabe647831f6bbcb1a0e57d79dd17b6540">More...</a><br /></td></tr>
<tr class="separator:gabe647831f6bbcb1a0e57d79dd17b6540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5f3572fdcf39e2fbddcdc9df62205d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga7b5f3572fdcf39e2fbddcdc9df62205d">IotUsbDeviceEndpointStatus_t</a> { <a class="el" href="group__iot__usb__device.html#gga7b5f3572fdcf39e2fbddcdc9df62205daddf48a6367af7fd3818210fd0b2e71ec">eUsbDeviceEndpointStateIdle</a>, 
<a class="el" href="group__iot__usb__device.html#gga7b5f3572fdcf39e2fbddcdc9df62205daaaf477de657b5e5d4b2b2129fc8efa09">eUsbDeviceEndpointStateStalled</a>, 
<a class="el" href="group__iot__usb__device.html#gga7b5f3572fdcf39e2fbddcdc9df62205da4abe64211c786303018b66e6aefb0ccc">eUsbDeviceEndpointStateBusy</a>, 
<a class="el" href="group__iot__usb__device.html#gga7b5f3572fdcf39e2fbddcdc9df62205da67abd30de4001c1e6219d50d5e7f7cb3">eUsbDeviceEndpointStateClosed</a>
 }</td></tr>
<tr class="memdesc:ga7b5f3572fdcf39e2fbddcdc9df62205d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines endpoint state.  <a href="group__iot__usb__device.html#ga7b5f3572fdcf39e2fbddcdc9df62205d">More...</a><br /></td></tr>
<tr class="separator:ga7b5f3572fdcf39e2fbddcdc9df62205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb9cdd5422fd2a245e8ad60af70ef1b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gaabb9cdd5422fd2a245e8ad60af70ef1b">IotUsbHostController_t</a> { <a class="el" href="group__iot__usb__device.html#ggaabb9cdd5422fd2a245e8ad60af70ef1ba33ed19a9cabfc23211954990f1629a23">eUsbDeviceControllerOHCI</a>, 
<a class="el" href="group__iot__usb__device.html#ggaabb9cdd5422fd2a245e8ad60af70ef1ba96c02678d011e0156199120fc5341b68">eUsbDeviceControllerUHCI</a>, 
<a class="el" href="group__iot__usb__device.html#ggaabb9cdd5422fd2a245e8ad60af70ef1ba96b8c602f74e325ce7b5ded1bda8089f">eUsbDeviceControllerEHCI</a>, 
<a class="el" href="group__iot__usb__device.html#ggaabb9cdd5422fd2a245e8ad60af70ef1baa421b0b8554d361f2f4d2097669d213c">eUsbDeviceControllerXHCI</a>
 }</td></tr>
<tr class="memdesc:gaabb9cdd5422fd2a245e8ad60af70ef1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define device controller ID.  <a href="group__iot__usb__device.html#gaabb9cdd5422fd2a245e8ad60af70ef1b">More...</a><br /></td></tr>
<tr class="separator:gaabb9cdd5422fd2a245e8ad60af70ef1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac768a7b998f729ec407dcab8252186bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gac768a7b998f729ec407dcab8252186bf">IotUsbDeviceOperationStatus_t</a> { <a class="el" href="group__iot__usb__device.html#ggac768a7b998f729ec407dcab8252186bfa945a2e6b3219190ab822462408e61953">eUsbDeviceCompleted</a> = IOT_USB_DEVICE_SUCCESS, 
<a class="el" href="group__iot__usb__device.html#ggac768a7b998f729ec407dcab8252186bfa9da39379c0bee58b06a0bdc287cf6eb9">eUsbDeviceReadFailed</a> = IOT_USB_DEVICE_READ_FAILED, 
<a class="el" href="group__iot__usb__device.html#ggac768a7b998f729ec407dcab8252186bfaef115e29e2f8a8e4af0088ecd1393056">eUsbDeviceWriteFailed</a> = IOT_USB_DEVICE_WRITE_FAILED
 }</td></tr>
<tr class="memdesc:gac768a7b998f729ec407dcab8252186bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB device driver operation status.  <a href="group__iot__usb__device.html#gac768a7b998f729ec407dcab8252186bf">More...</a><br /></td></tr>
<tr class="separator:gac768a7b998f729ec407dcab8252186bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6698a89549fa2b3af760362fddac3c0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga6698a89549fa2b3af760362fddac3c0a">iot_usb_device_open</a> (int32_t lUsbDeviceControllerInstance)</td></tr>
<tr class="memdesc:ga6698a89549fa2b3af760362fddac3c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the usb device controller interface.  <a href="#ga6698a89549fa2b3af760362fddac3c0a">More...</a><br /></td></tr>
<tr class="separator:ga6698a89549fa2b3af760362fddac3c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea81f3ce35499f570426ad71ff6100b1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gaea81f3ce35499f570426ad71ff6100b1">iot_usb_device_connect</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice)</td></tr>
<tr class="memdesc:gaea81f3ce35499f570426ad71ff6100b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the USB device.  <a href="#gaea81f3ce35499f570426ad71ff6100b1">More...</a><br /></td></tr>
<tr class="separator:gaea81f3ce35499f570426ad71ff6100b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ac3f31f7acc9200a5cb2ce25248b787"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga3ac3f31f7acc9200a5cb2ce25248b787">iot_usb_device_disconnect</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice)</td></tr>
<tr class="memdesc:ga3ac3f31f7acc9200a5cb2ce25248b787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the USB device.  <a href="#ga3ac3f31f7acc9200a5cb2ce25248b787">More...</a><br /></td></tr>
<tr class="separator:ga3ac3f31f7acc9200a5cb2ce25248b787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1e229cb9f2a4d2195b8c9bf5f8077e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga8c1e229cb9f2a4d2195b8c9bf5f8077e">iot_usb_device_set_device_callback</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, <a class="el" href="group__iot__usb__device.html#ga437a049730541ce250069e732c73e657">IotUsbDeviceCallback_t</a> xCallback, void *pvUserContext)</td></tr>
<tr class="memdesc:ga8c1e229cb9f2a4d2195b8c9bf5f8077e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the application callback to be called on device event.  <a href="#ga8c1e229cb9f2a4d2195b8c9bf5f8077e">More...</a><br /></td></tr>
<tr class="separator:ga8c1e229cb9f2a4d2195b8c9bf5f8077e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04cbbe6477e5c53172cb694c8c79690"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gae04cbbe6477e5c53172cb694c8c79690">iot_usb_device_endpoint_open</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, <a class="el" href="struct_iot_usb_device_endpoint_config__t.html">IotUsbDeviceEndpointConfig_t</a> *pxEpConfig)</td></tr>
<tr class="memdesc:gae04cbbe6477e5c53172cb694c8c79690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the usb device specific endpoint.  <a href="#gae04cbbe6477e5c53172cb694c8c79690">More...</a><br /></td></tr>
<tr class="separator:gae04cbbe6477e5c53172cb694c8c79690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012fc7a5f494aab22340de099b89de58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga012fc7a5f494aab22340de099b89de58">iot_usb_device_set_endpoint_callback</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress, <a class="el" href="group__iot__usb__device.html#gaaf64a63710a5a8033d845818044c60fd">IotUsbDeviceEndpointCallbackFn_t</a> xCallback, void *pvUserContext)</td></tr>
<tr class="memdesc:ga012fc7a5f494aab22340de099b89de58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the endpoint callback to be called on endpoint transfer.  <a href="#ga012fc7a5f494aab22340de099b89de58">More...</a><br /></td></tr>
<tr class="separator:ga012fc7a5f494aab22340de099b89de58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5c7d08d9b747ddb093295670d648d9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gacd5c7d08d9b747ddb093295670d648d9">iot_usb_device_endpoint_close</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress)</td></tr>
<tr class="memdesc:gacd5c7d08d9b747ddb093295670d648d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the usb device specific endpoint.  <a href="#gacd5c7d08d9b747ddb093295670d648d9">More...</a><br /></td></tr>
<tr class="separator:gacd5c7d08d9b747ddb093295670d648d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bfa047c2b3bf6d5737c0a7fb76a5086"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga0bfa047c2b3bf6d5737c0a7fb76a5086">iot_usb_device_endpoint_stall</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress)</td></tr>
<tr class="memdesc:ga0bfa047c2b3bf6d5737c0a7fb76a5086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stall the usb device specific endpoint. This function is to set stall conditions for the specific endpoint. The STALL packet indicates that the endpoint has halted, or a control pipe does not support a certain request. A function uses the STALL handshake packet to indicate that it is unable to transmit or receive data. Besides the default control pipe, all of a function's endpoints are in an undefined state after the device issues a STALL handshake packet. The host must never issue a STALL handshake packet. Typically, the STALL handshake indicates a functional stall. A functional stall occurs when the halt feature of an endpoint is set. In this circumstance, host intervention is required via the default control pipe to clear the halt feature of the halted endpoint. Less often, the function returns a STALL handshake during a SETUP or DATA stage of a control transfer. This is called a protocol stall and is resolved when the host issues the next SETUP transaction.  <a href="#ga0bfa047c2b3bf6d5737c0a7fb76a5086">More...</a><br /></td></tr>
<tr class="separator:ga0bfa047c2b3bf6d5737c0a7fb76a5086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e78156384ad3239af107d7f7a1fae76"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga6e78156384ad3239af107d7f7a1fae76">iot_usb_device_endpoint_unstall</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress)</td></tr>
<tr class="memdesc:ga6e78156384ad3239af107d7f7a1fae76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unstall the usb device specific endpoint.  <a href="#ga6e78156384ad3239af107d7f7a1fae76">More...</a><br /></td></tr>
<tr class="separator:ga6e78156384ad3239af107d7f7a1fae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae79115cc930cea3e0dacdbde5e97c1af"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gae79115cc930cea3e0dacdbde5e97c1af">iot_usb_device_read_sync</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gae79115cc930cea3e0dacdbde5e97c1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the USB device read operation in blocking mode.  <a href="#gae79115cc930cea3e0dacdbde5e97c1af">More...</a><br /></td></tr>
<tr class="separator:gae79115cc930cea3e0dacdbde5e97c1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa276a34583e966ad28c4c93be6e79d3d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gaa276a34583e966ad28c4c93be6e79d3d">iot_usb_device_write_sync</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gaa276a34583e966ad28c4c93be6e79d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the USB device write operation in blocking mode.  <a href="#gaa276a34583e966ad28c4c93be6e79d3d">More...</a><br /></td></tr>
<tr class="separator:gaa276a34583e966ad28c4c93be6e79d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37c5c0ffacd82bb2027cf860d69277f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gaf37c5c0ffacd82bb2027cf860d69277f">iot_usb_device_read_async</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gaf37c5c0ffacd82bb2027cf860d69277f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the USB device read operation in non-blocking mode.  <a href="#gaf37c5c0ffacd82bb2027cf860d69277f">More...</a><br /></td></tr>
<tr class="separator:gaf37c5c0ffacd82bb2027cf860d69277f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3592d13791e2840b816488044b2427f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gaf3592d13791e2840b816488044b2427f">iot_usb_device_write_async</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress, uint8_t *const pvBuffer, size_t xBytes)</td></tr>
<tr class="memdesc:gaf3592d13791e2840b816488044b2427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the USB device write operation in non-blocking mode.  <a href="#gaf3592d13791e2840b816488044b2427f">More...</a><br /></td></tr>
<tr class="separator:gaf3592d13791e2840b816488044b2427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc324960d6b47de7c113c6794347bf9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#ga8dc324960d6b47de7c113c6794347bf9">iot_usb_device_ioctl</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, <a class="el" href="group__iot__usb__device.html#ga34f1397e05c95d52de786262d04ae9f6">IotUsbDeviceIoctlRequest_t</a> xUsbDeviceRequest, void *const pvBuffer)</td></tr>
<tr class="memdesc:ga8dc324960d6b47de7c113c6794347bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for various USB device control function.  <a href="#ga8dc324960d6b47de7c113c6794347bf9">More...</a><br /></td></tr>
<tr class="separator:ga8dc324960d6b47de7c113c6794347bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad05f172afa3dfff087456db69688cb5b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gad05f172afa3dfff087456db69688cb5b">iot_usb_device_endpoint_cancel_transfer</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint8_t ucEndpointAddress)</td></tr>
<tr class="memdesc:gad05f172afa3dfff087456db69688cb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to cancel the pending transfer for given endpoint.  <a href="#gad05f172afa3dfff087456db69688cb5b">More...</a><br /></td></tr>
<tr class="separator:gad05f172afa3dfff087456db69688cb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a25b1ca7330ec54af4b13487230258"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iot__usb__device.html#gac2a25b1ca7330ec54af4b13487230258">iot_usb_device_close</a> (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice)</td></tr>
<tr class="memdesc:gac2a25b1ca7330ec54af4b13487230258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the USB device peripheral.  <a href="#gac2a25b1ca7330ec54af4b13487230258">More...</a><br /></td></tr>
<tr class="separator:gac2a25b1ca7330ec54af4b13487230258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga437a049730541ce250069e732c73e657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga437a049730541ce250069e732c73e657">&#9670;&nbsp;</a></span>IotUsbDeviceCallback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* IotUsbDeviceCallback_t) (<a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const pxUsbDevice, uint32_t ulDeviceEvent, void *pvUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback function for USB device event operation. This callback is passed to driver by using iot_usb_device_set_callback API. It's called when one of the events (IotUsbDeviceEvent_t) happen. This callback is used by upper layer to set up upper layer callback by calling iot_usb_device_set_device_callback. It is used when the bus state changes and an event is generated, e.g. an bus reset event happened, usb class layer needs to know such event and react accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The usb device peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulDeviceEvent</td><td>USB device asynchronous event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>User Context passed when setting the callback. This is not used or modified by the driver. The context is provided by the caller when setting the callback, and is passed back to the caller in the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf64a63710a5a8033d845818044c60fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf64a63710a5a8033d845818044c60fd">&#9670;&nbsp;</a></span>IotUsbDeviceEndpointCallbackFn_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(*  IotUsbDeviceEndpointCallbackFn_t) (<a class="el" href="group__iot__usb__device.html#gac768a7b998f729ec407dcab8252186bf">IotUsbDeviceOperationStatus_t</a> xStatus, void *pvUserContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback typedef for USB device endpoint. For each endpoint, it's passed when user set endpoint callback by iot_usb_device_set_endpoint_callback API. This callback is used to notify the upper layer about the endpoint tranafer result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">xStatus</td><td>Usb device asynchronous operation status. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>User Context passed when setting the callback. This is not used or modified by the driver. The context is provided by the caller when setting the callback, and is passed back to the caller in the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa9fdde19e4564cd6b01aa1a8468a9055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9fdde19e4564cd6b01aa1a8468a9055">&#9670;&nbsp;</a></span>IotUsbDeviceEvent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__usb__device.html#gaa9fdde19e4564cd6b01aa1a8468a9055">IotUsbDeviceEvent_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>common notify event types in device callback. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055ad65b106705e0f9120484dde7de12accc"></a>eUSBDeviceBusResetEvent&#160;</td><td class="fielddoc"><p>USB bus reset signal detected. Signal is initiated from USB Host. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055a9d28b253d2d8a296a5e08018ebaf39a2"></a>eUSBDeviceLPMState1Event&#160;</td><td class="fielddoc"><p>USB LPM (link power management) state 1 event: for usb 2.0, correspond to L1 sleep, host initialize LPM extended transaction; for usb 3.0, correspond to U1 standby, both device and host can initialize. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055a08437527442a446ca1e78ab37ded0eee"></a>eUSBDeviceLPMState2Event&#160;</td><td class="fielddoc"><p>USB LPM state 2 event: for usb 2.0, correspond to L2 suspend, host nees to support to trigger it after 3ms of inactivity; for usb 3.0, correspond to U2 standby, both device and host can initialize. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055a0f7ef73ab4282c1f9a83daf8a0f2441e"></a>eUSBDeviceLPMState3Event&#160;</td><td class="fielddoc"><p>USB LPM state 3 event: for usb 2.0, correspond to L3 off, disconnect or power off will trigger it; for usb 3.0, correspond to U3 suspend, it can only be initialized by host. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055aa4ec844d3094ec7743eac8dc3ebf4c6a"></a>eUSBDeviceLPMState1ResumeEvent&#160;</td><td class="fielddoc"><p>USB resume event from LPM state 1: for usb 2.0 and 3.0, both device and host can initialize resume signaling. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055a6844b06d50c73c1b55e5299ec34cdc59"></a>eUSBDeviceLPMState2ResumeEvent&#160;</td><td class="fielddoc"><p>USB resume event from LPM state 2: for usb 2.0 and 3.0, both device and host can initialize resume signaling. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055ae538d4e891b43c6ead52df1ced05d609"></a>eUSBDeviceLPMState3ResumeEvent&#160;</td><td class="fielddoc"><p>USB resume event from LPM state 3: for usb 2.0, L3 is off state, port needs reset or power on; for usb 3.0, both device and host can initialize resume signaling. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055aacff1058e6a7726725b97635baad1fd5"></a>eUSBDeviceErrorEvent&#160;</td><td class="fielddoc"><p>An error is happened in the bus. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055a8e09cdcf6152457ed088cf2ab163f99d"></a>eUSBDeviceDetachEvent&#160;</td><td class="fielddoc"><p>USB device is disconnected from a host. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa9fdde19e4564cd6b01aa1a8468a9055a663a3b5a26057883cdc1ebc0e5c546cf"></a>eUSBDeviceAttachEvent&#160;</td><td class="fielddoc"><p>USB device is connected to a host. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga34f1397e05c95d52de786262d04ae9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f1397e05c95d52de786262d04ae9f6">&#9670;&nbsp;</a></span>IotUsbDeviceIoctlRequest_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__usb__device.html#ga34f1397e05c95d52de786262d04ae9f6">IotUsbDeviceIoctlRequest_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ioctl request types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a23f12407318123e9c62f237000d7b435"></a>eUSBDeviceGetSpeed&#160;</td><td class="fielddoc"><p>Get device speed. Return uint8_t integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a6820c49b295bef9d7f7a31504e0c1cdd"></a>eUSBDeviceGetAddress&#160;</td><td class="fielddoc"><p>Get device address. Return an uint8_t integer range from 1~127. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6aa22fa0d10e8e6e1cb434ce4d73748006"></a>eUSBDeviceSetAddress&#160;</td><td class="fielddoc"><p>Set device address. Take an uint8_t integer to set it as address. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a2ad1cf70a51f28b730b1e76b09d8cac1"></a>eUSBDeviceGetEndpointStatus&#160;</td><td class="fielddoc"><p>Get endpoint status. Return IotUsbDeviceEndpointStatus_t type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6afb17fc0bd7778af9736174db724bf0ac"></a>eUSBDeviceGetState&#160;</td><td class="fielddoc"><p>Get device state. Return IotUsbDeviceState_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a869be5f7e969dd2aaf89be61d8b1c8b4"></a>eUSBDeviceGetStatus&#160;</td><td class="fielddoc"><p>Get device status. Return uint16_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6ad01a775e5fc0b722fe4afed4e4b8c321"></a>eUSBDeviceGetSyncFrame&#160;</td><td class="fielddoc"><p>Get Sync frame. Returns the frame number of synchronization frame as uint16_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a83e8bbffcbffa50c8ea2951ac197d00c"></a>eUSBDeviceSetTestMode&#160;</td><td class="fielddoc"><p>Set device in test mode. For compliance testing defined in usb protocol. </p><dl class="section warning"><dt>Warning</dt><dd>Device needs to power cycle to exit test mode. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a6ce0a867e790fe9ecdf8926a45c0c407"></a>eUSBDeviceSetState&#160;</td><td class="fielddoc"><p>Set device state. Take IotUsbDeviceState_t and set it </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a8478a49ac8cfbe6ae877e914baefe752"></a>eUSBDeviceLPMState1Suspend&#160;</td><td class="fielddoc"><p>Suspend usb to LPM state 1: for usb 2.0, it is L1 state; for usb 3.0, it is U1 state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a91525aabaa49c7ec8b48d09426f48469"></a>eUSBDeviceLPMState1Resume&#160;</td><td class="fielddoc"><p>Resume usb from LPM state 1: for usb 2.0, it is exit L1 state; for usb 3.0, it is exit U1 state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6af028596a084313d81ee06fff3be6831a"></a>eUSBDeviceLPMState2Suspend&#160;</td><td class="fielddoc"><p>Suspend usb to LPM state 2: for usb 2.0, it is L2 state; for usb 3.0, it is U2 state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a67cdf86203ad2877be23e208862dff80"></a>eUSBDeviceLPMState2Resume&#160;</td><td class="fielddoc"><p>Resume usb from LPM state 2: for usb 2.0, it is exit L2 state; for usb 3.0, it is exit U2 state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a0cc555bf76fb5dbad07f6a0ad022c961"></a>eUSBDeviceLPMState3Suspend&#160;</td><td class="fielddoc"><p>Suspend usb to LPM state 3: for usb 2.0, it is L3 state; for usb 3.0, it is U3 state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6a4751ec41cda30671c829a75abc083f18"></a>eUSBDeviceLPMState3Resume&#160;</td><td class="fielddoc"><p>Resume usb from LPM state 3: for usb 2.0, it is exit L3 state; for usb 3.0, it is exit U3 state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga34f1397e05c95d52de786262d04ae9f6afd7a008e098c835ae1be1db2e84082f7"></a>eUSBDeviceRemoteWakeup&#160;</td><td class="fielddoc"><p>Remote wakeup host. </p>
</td></tr>
</table>

</div>
</div>
<a id="gabe647831f6bbcb1a0e57d79dd17b6540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe647831f6bbcb1a0e57d79dd17b6540">&#9670;&nbsp;</a></span>IotUsbDeviceState_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__usb__device.html#gabe647831f6bbcb1a0e57d79dd17b6540">IotUsbDeviceState_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB device state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabe647831f6bbcb1a0e57d79dd17b6540a8d42ab931c780bfa2667272a7c2772d3"></a>eUsbDeviceStateConfigured&#160;</td><td class="fielddoc"><p>Device state, usb device is configured and ready for use by host </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe647831f6bbcb1a0e57d79dd17b6540afe6e254ebf34234957ad32f786d02b50"></a>eUsbDeviceStateAddress&#160;</td><td class="fielddoc"><p>Device state, usb device Address assigned </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe647831f6bbcb1a0e57d79dd17b6540a5f62fe36e0657f6f328fda75f8738225"></a>eUsbDeviceStateDefault&#160;</td><td class="fielddoc"><p>Device state, usb device is reset, but address not assigned yet </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe647831f6bbcb1a0e57d79dd17b6540a5c356a18c9e773195a4456be402b9709"></a>eUsbDeviceStateAddressing&#160;</td><td class="fielddoc"><p>Device state, usb device is undergoing assigning address </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabe647831f6bbcb1a0e57d79dd17b6540ae5463617abb9039e150ee439bb30b6c6"></a>eUsbDeviceStateTestMode&#160;</td><td class="fielddoc"><p>Device state, usb device is in test mode </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7b5f3572fdcf39e2fbddcdc9df62205d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b5f3572fdcf39e2fbddcdc9df62205d">&#9670;&nbsp;</a></span>IotUsbDeviceEndpointStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__usb__device.html#ga7b5f3572fdcf39e2fbddcdc9df62205d">IotUsbDeviceEndpointStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines endpoint state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7b5f3572fdcf39e2fbddcdc9df62205daddf48a6367af7fd3818210fd0b2e71ec"></a>eUsbDeviceEndpointStateIdle&#160;</td><td class="fielddoc"><p>Endpoint state, idle </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b5f3572fdcf39e2fbddcdc9df62205daaaf477de657b5e5d4b2b2129fc8efa09"></a>eUsbDeviceEndpointStateStalled&#160;</td><td class="fielddoc"><p>Endpoint state, stalled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b5f3572fdcf39e2fbddcdc9df62205da4abe64211c786303018b66e6aefb0ccc"></a>eUsbDeviceEndpointStateBusy&#160;</td><td class="fielddoc"><p>Endpoint state, busy </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7b5f3572fdcf39e2fbddcdc9df62205da67abd30de4001c1e6219d50d5e7f7cb3"></a>eUsbDeviceEndpointStateClosed&#160;</td><td class="fielddoc"><p>Endpoint state, Closed, not configured </p>
</td></tr>
</table>

</div>
</div>
<a id="gaabb9cdd5422fd2a245e8ad60af70ef1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabb9cdd5422fd2a245e8ad60af70ef1b">&#9670;&nbsp;</a></span>IotUsbHostController_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__usb__device.html#gaabb9cdd5422fd2a245e8ad60af70ef1b">IotUsbHostController_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define device controller ID. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaabb9cdd5422fd2a245e8ad60af70ef1ba33ed19a9cabfc23211954990f1629a23"></a>eUsbDeviceControllerOHCI&#160;</td><td class="fielddoc"><p>Open Device Controller Interface </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabb9cdd5422fd2a245e8ad60af70ef1ba96c02678d011e0156199120fc5341b68"></a>eUsbDeviceControllerUHCI&#160;</td><td class="fielddoc"><p>Universal Device Controller Interface </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabb9cdd5422fd2a245e8ad60af70ef1ba96b8c602f74e325ce7b5ded1bda8089f"></a>eUsbDeviceControllerEHCI&#160;</td><td class="fielddoc"><p>Enhanced Device Controller Interface </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaabb9cdd5422fd2a245e8ad60af70ef1baa421b0b8554d361f2f4d2097669d213c"></a>eUsbDeviceControllerXHCI&#160;</td><td class="fielddoc"><p>Extensible Device Controller Interface </p>
</td></tr>
</table>

</div>
</div>
<a id="gac768a7b998f729ec407dcab8252186bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac768a7b998f729ec407dcab8252186bf">&#9670;&nbsp;</a></span>IotUsbDeviceOperationStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__iot__usb__device.html#gac768a7b998f729ec407dcab8252186bf">IotUsbDeviceOperationStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB device driver operation status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac768a7b998f729ec407dcab8252186bfa945a2e6b3219190ab822462408e61953"></a>eUsbDeviceCompleted&#160;</td><td class="fielddoc"><p>Device operation completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac768a7b998f729ec407dcab8252186bfa9da39379c0bee58b06a0bdc287cf6eb9"></a>eUsbDeviceReadFailed&#160;</td><td class="fielddoc"><p>Device read operation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac768a7b998f729ec407dcab8252186bfaef115e29e2f8a8e4af0088ecd1393056"></a>eUsbDeviceWriteFailed&#160;</td><td class="fielddoc"><p>Device write operation failed. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6698a89549fa2b3af760362fddac3c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6698a89549fa2b3af760362fddac3c0a">&#9670;&nbsp;</a></span>iot_usb_device_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> iot_usb_device_open </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lUsbDeviceControllerInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the usb device controller interface. </p>
<p>The instance of USB device controller to initialize.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The handle to the USB device if SUCCESS</li>
<li>NULL if<ul>
<li>invalid lUsbDeviceControllerInstance</li>
<li>already open </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaea81f3ce35499f570426ad71ff6100b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea81f3ce35499f570426ad71ff6100b1">&#9670;&nbsp;</a></span>iot_usb_device_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the USB device. </p>
<p>The function enables the device functionality, so that the device can be recognized by the host when the device detects that it has been connected to a host.</p>
<dl class="section warning"><dt>Warning</dt><dd>this function must be called in order for USB to be recognized but not necessarily enumerated which requires the class to exchange control packets.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The usb device peripheral handle returned in the open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if pxUsbDevice is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3ac3f31f7acc9200a5cb2ce25248b787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ac3f31f7acc9200a5cb2ce25248b787">&#9670;&nbsp;</a></span>iot_usb_device_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the USB device. </p>
<p>The function disables the device functionality, after this function called, even the device is attached to the host, and the device can't work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The usb device peripheral handle returned in the open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if pxUsbDevice is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8c1e229cb9f2a4d2195b8c9bf5f8077e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1e229cb9f2a4d2195b8c9bf5f8077e">&#9670;&nbsp;</a></span>iot_usb_device_set_device_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iot_usb_device_set_device_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#ga437a049730541ce250069e732c73e657">IotUsbDeviceCallback_t</a>&#160;</td>
          <td class="paramname"><em>xCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvUserContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the application callback to be called on device event. </p>
<dl class="section note"><dt>Note</dt><dd>Single callback is used, per instance. </dd>
<dd>
Newly set callback overrides the one previously set</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If input handle or if callback function is NULL, this function silently takes no action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The usb device peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCallback</td><td>The callback function to be called on device event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>The user context to be passed back when callback is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae04cbbe6477e5c53172cb694c8c79690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae04cbbe6477e5c53172cb694c8c79690">&#9670;&nbsp;</a></span>iot_usb_device_endpoint_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_endpoint_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_iot_usb_device_endpoint_config__t.html">IotUsbDeviceEndpointConfig_t</a> *&#160;</td>
          <td class="paramname"><em>pxEpConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the usb device specific endpoint. </p>
<dl class="section warning"><dt>Warning</dt><dd>: Its the class codes responsibility to make sure the endpoint address is only opened once.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEpConfig</td><td>Endpoint configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>pxEpConfig is NULL.</li>
<li>endpoint address is already open</li>
<li>endpoint config parameter is not supported</li>
<li>endpoint address is invalid</li>
</ul>
</li>
<li>IOT_USB_DEVICE_ERROR if an error occurred with the device </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga012fc7a5f494aab22340de099b89de58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga012fc7a5f494aab22340de099b89de58">&#9670;&nbsp;</a></span>iot_usb_device_set_endpoint_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iot_usb_device_set_endpoint_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gaaf64a63710a5a8033d845818044c60fd">IotUsbDeviceEndpointCallbackFn_t</a>&#160;</td>
          <td class="paramname"><em>xCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvUserContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the endpoint callback to be called on endpoint transfer. </p>
<dl class="section note"><dt>Note</dt><dd>Single callback is used, per instance. </dd>
<dd>
Newly set callback overrides the one previously set</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If input handle or if callback function is NULL, or invalid EndpointAddress issued, this function silently takes no action.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The usb device peripheral handle returned in the open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint Address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xCallback</td><td>The callback function to be called on endpoint transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvUserContext</td><td>The user context to be passed back when callback is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd5c7d08d9b747ddb093295670d648d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5c7d08d9b747ddb093295670d648d9">&#9670;&nbsp;</a></span>iot_usb_device_endpoint_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_endpoint_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the usb device specific endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid ucEndpointAddress </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0bfa047c2b3bf6d5737c0a7fb76a5086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bfa047c2b3bf6d5737c0a7fb76a5086">&#9670;&nbsp;</a></span>iot_usb_device_endpoint_stall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_endpoint_stall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stall the usb device specific endpoint. This function is to set stall conditions for the specific endpoint. The STALL packet indicates that the endpoint has halted, or a control pipe does not support a certain request. A function uses the STALL handshake packet to indicate that it is unable to transmit or receive data. Besides the default control pipe, all of a function's endpoints are in an undefined state after the device issues a STALL handshake packet. The host must never issue a STALL handshake packet. Typically, the STALL handshake indicates a functional stall. A functional stall occurs when the halt feature of an endpoint is set. In this circumstance, host intervention is required via the default control pipe to clear the halt feature of the halted endpoint. Less often, the function returns a STALL handshake during a SETUP or DATA stage of a control transfer. This is called a protocol stall and is resolved when the host issues the next SETUP transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid ucEndpointAddress </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6e78156384ad3239af107d7f7a1fae76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e78156384ad3239af107d7f7a1fae76">&#9670;&nbsp;</a></span>iot_usb_device_endpoint_unstall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_endpoint_unstall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unstall the usb device specific endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid ucEndpointAddress </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae79115cc930cea3e0dacdbde5e97c1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae79115cc930cea3e0dacdbde5e97c1af">&#9670;&nbsp;</a></span>iot_usb_device_read_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_read_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the USB device read operation in blocking mode. </p>
<dl class="section note"><dt>Note</dt><dd>This function will block until all xBytes have been read.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The receive buffer to read the data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid ucEndpointAddress</li>
<li>pvBuffer is NULL</li>
<li>xBytes == 0</li>
</ul>
</li>
<li>IOT_USB_DEVICE_BUSY if another operation is in progress on the same endpoint.</li>
<li>IOT_USB_DEVICE_READ_FAILED if unable to complete the read operation </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa276a34583e966ad28c4c93be6e79d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa276a34583e966ad28c4c93be6e79d3d">&#9670;&nbsp;</a></span>iot_usb_device_write_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_write_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the USB device write operation in blocking mode. </p>
<p>note: this function will block until all xBytes have been written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The receive buffer to read the data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid ucEndpointAddress</li>
<li>pvBuffer is NULL</li>
<li>xBytes == 0</li>
</ul>
</li>
<li>IOT_USB_DEVICE_BUSY if another operation is in progress on the same endpoint.</li>
<li>IOT_USB_DEVICE_WRITE_FAILED if unable to complete the write operation </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf37c5c0ffacd82bb2027cf860d69277f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf37c5c0ffacd82bb2027cf860d69277f">&#9670;&nbsp;</a></span>iot_usb_device_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the USB device read operation in non-blocking mode. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__iot__usb__device.html#ga8c1e229cb9f2a4d2195b8c9bf5f8077e" title="Sets the application callback to be called on device event. ">iot_usb_device_set_device_callback()</a> must be called first in order for the callback function to be called to signal when the read is complete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The receive buffer to read the data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid ucEndpointAddress</li>
<li>pvBuffer is NULL</li>
<li>xBytes == 0</li>
</ul>
</li>
<li>IOT_USB_DEVICE_BUSY if another operation is in progress on the same endpoint.</li>
<li>IOT_USB_DEVICE_READ_FAILED if unable to complete the read operation </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf3592d13791e2840b816488044b2427f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3592d13791e2840b816488044b2427f">&#9670;&nbsp;</a></span>iot_usb_device_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the USB device write operation in non-blocking mode. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__iot__usb__device.html#ga8c1e229cb9f2a4d2195b8c9bf5f8077e" title="Sets the application callback to be called on device event. ">iot_usb_device_set_device_callback()</a> must be called first in order for the callback function to be called to signal when the write is complete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The receive buffer to read the data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBytes</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid ucEndpointAddress</li>
<li>pvBuffer is NULL</li>
<li>xBytes == 0</li>
</ul>
</li>
<li>IOT_USB_DEVICE_BUSY if another operation is in progress on the same endpoint.</li>
<li>IOT_USB_DEVICE_WRITE_FAILED if unable to complete the write operation </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8dc324960d6b47de7c113c6794347bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc324960d6b47de7c113c6794347bf9">&#9670;&nbsp;</a></span>iot_usb_device_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_ioctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#ga34f1397e05c95d52de786262d04ae9f6">IotUsbDeviceIoctlRequest_t</a>&#160;</td>
          <td class="paramname"><em>xUsbDeviceRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pvBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for various USB device control function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xUsbDeviceRequest</td><td>Should be one of IotUsbDeviceIoctlRequest_t. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvBuffer</td><td>The configuration values for the IOCTL request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid xUsbDeviceRequest</li>
</ul>
</li>
<li>IOT_USB_DEVICE_FUNCTION_NOT_SUPPORTED if ioctl request not suported.<ul>
<li>Only valid for</li>
<li>eUSBDeviceSleepBus</li>
<li>eUSBDeviceSuspendBus</li>
<li>eUSBDeviceResumeBus</li>
<li>eUSBDeviceRemoteWakeup</li>
<li>eUSBDeviceGetSyncFrame</li>
</ul>
</li>
<li>or other USB Error. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad05f172afa3dfff087456db69688cb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad05f172afa3dfff087456db69688cb5b">&#9670;&nbsp;</a></span>iot_usb_device_endpoint_cancel_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_endpoint_cancel_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEndpointAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to cancel the pending transfer for given endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEndpointAddress</td><td>Endpoint Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>invalid ucEndpointAddress</li>
</ul>
</li>
<li>IOT_USB_DEVICE_FUNCTION_NOT_SUPPORTED if cancel transfer opertion not supported</li>
<li>IOT_USB_DEVICE_NOTHING_TO_CANCEL if nothing to cancel </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac2a25b1ca7330ec54af4b13487230258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a25b1ca7330ec54af4b13487230258">&#9670;&nbsp;</a></span>iot_usb_device_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t iot_usb_device_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iot__usb__device.html#gafef9b113ed9ec0661dad02268665ddde">IotUsbDeviceHandle_t</a> const&#160;</td>
          <td class="paramname"><em>pxUsbDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the USB device peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxUsbDevice</td><td>The USB device handle returned in open() call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>IOT_USB_DEVICE_SUCCESS on success</li>
<li>IOT_USB_DEVICE_INVALID_VALUE if<ul>
<li>pxUsbDevice is NULL.</li>
<li>pxUsbDevice not open (already closed). </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- This file provides the custom footer for Doxygen-generated HTML. Per the
Doxygen documentation, this file may need to be regenerated when Doxygen is
updated. -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Generated by
      <a href="http://www.doxygen.org/index.html">
      <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14
    </li>
    <li class="footer">
      Last updated Mon Nov 25 2019
    </li>
    <li class="footer" style="float:left">
    </li>
  </ul>
</div>
</body>
</html>
