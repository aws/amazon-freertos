diff --git a/libraries/freertos_plus/standard/freertos_plus_tcp/source/FreeRTOS_TCP_IP.c b/libraries/freertos_plus/standard/freertos_plus_tcp/source/FreeRTOS_TCP_IP.c
index 8eeabe33f..ba80de506 100644
--- a/libraries/freertos_plus/standard/freertos_plus_tcp/source/FreeRTOS_TCP_IP.c
+++ b/libraries/freertos_plus/standard/freertos_plus_tcp/source/FreeRTOS_TCP_IP.c
@@ -230,14 +230,22 @@ static BaseType_t prvTCPPrepareConnect( FreeRTOS_Socket_t *pxSocket );
 /*
  * Parse the TCP option(s) received, if present.
  */
+#ifdef CBMC
+void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer );
+#else
 static void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer );
+#endif
 
 /*
  * Identify and deal with a single TCP header option, advancing the pointer to
  * the header. This function returns pdTRUE or pdFALSE depending on whether the
  * caller should continue to parse more header options or break the loop.
  */
+#ifdef CBMC
+size_t prvSingleStepTCPHeaderOptions( const uint8_t * const pucPtr,
+#else
 static size_t prvSingleStepTCPHeaderOptions( const uint8_t * const pucPtr,
+#endif
 											 size_t uxTotalLength,
 											 FreeRTOS_Socket_t * const pxSocket,
 											 BaseType_t xHasSYNFlag );
@@ -246,7 +254,11 @@ static size_t prvSingleStepTCPHeaderOptions( const uint8_t * const pucPtr,
  * Skip past TCP header options when doing Selective ACK, until there are no
  * more options left.
  */
+#ifdef CBMC
+void prvReadSackOption( const uint8_t * const pucPtr,
+#else
 static void prvReadSackOption( const uint8_t * const pucPtr,
+#endif
 							   size_t uxIndex,
 							   FreeRTOS_Socket_t * const pxSocket );
 
@@ -1163,7 +1175,11 @@ uint32_t ulInitialSequenceNumber = 0;
  * that: ((pxTCPHeader->ucTCPOffset & 0xf0) > 0x50), meaning that the TP header
  * is longer than the usual 20 (5 x 4) bytes.
  */
+#ifdef CBMC
+void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer )
+#else
 static void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer )
+#endif
 {
 size_t uxTCPHeaderOffset = ipSIZE_OF_ETH_HEADER + xIPHeaderSize( pxNetworkBuffer );
 ProtocolHeaders_t *pxProtocolHeaders = ipPOINTER_CAST( ProtocolHeaders_t *,
@@ -1215,7 +1231,11 @@ uint8_t ucLength;
 }
 /*-----------------------------------------------------------*/
 
+#ifdef CBMC
+size_t prvSingleStepTCPHeaderOptions( const uint8_t * const pucPtr,
+#else
 static size_t prvSingleStepTCPHeaderOptions( const uint8_t * const pucPtr,
+#endif
 											 size_t uxTotalLength,
 											 FreeRTOS_Socket_t * const pxSocket,
 											 BaseType_t xHasSYNFlag )
@@ -1346,7 +1366,11 @@ TCPWindow_t *pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
 }
 /*-----------------------------------------------------------*/
 
+#ifdef CBMC
+void prvReadSackOption( const uint8_t * const pucPtr,
+#else
 static void prvReadSackOption( const uint8_t * const pucPtr,
+#endif
 							   size_t uxIndex,
 							   FreeRTOS_Socket_t * const pxSocket )
 {
