%%{
/*
 * Copyright (c) 2019-2020 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  ======== SlNet.Config.c.xdt ========
 */
%%}
%%{
    let SlNet = args[0];
    let hasNDK = false;
    let hasWiFi = false;
    let util = null;
    let SLNETCONN = system.modules["/ti/net/SlNetConn"];
%%}
/*
 *  ======== ti.net/SlNet ========
 */
#include <stdint.h>
#include <stdlib.h>
#include "string.h"
% if (SLNETCONN && SLNETCONN.$static.generateEventThread) {
#include <pthread.h>
% }

% if (SLNETCONN != null) {
#include <ti/net/slnetconn.h>
% }
#include <ti/net/slnetif.h>
#include <ti/net/slnetutils.h>
#include <ti/net/slnetsock.h>
#include <ti/net/slnet.h>
% for (let i = 0; i< SlNet.$instances.length; i++) {
%   let inst = SlNet.$instances[i];
%   if (!hasNDK && (inst.networkIfFxnList == "NDK")) {
#include <ti/ndk/slnetif/slnetifndk.h>
#include <ti/ndk/inc/stkmain.h>
%       hasNDK = true;
%       util = system.getScript("/ti/ndk/util.js");
%   }
%   else if (!hasWiFi && (inst.networkIfFxnList == "SimpleLink WiFi")) {
#include <ti/drivers/net/wifi/slnetifwifi.h>
%       hasWiFi = true;
%   }
%   // TODO - enable users to #include a header for "custom"
% }

% if (SLNETCONN && SLNETCONN.$static.generateEventThread) {
static int32_t createSlNetEventThread(void);
% }

/* This generated function must be called after the network stack(s) are
 * initialized.
 */
int32_t ti_net_SlNet_initConfig() {
    int32_t     status = 0;
    static bool slNetInitialized = false;

    if (slNetInitialized == false) {
        slNetInitialized = true;

        status = SlNetIf_init(0);

        if (status == 0) {
            status = SlNetSock_init(0);
        }

        if (status == 0) {
            SlNetUtil_init(0);
        }

% if (SLNETCONN != null) {
        if (status == 0) {
            status = SlNetConn_init(0);
        }

%   if (SLNETCONN.$static.generateEventThread) {
        if (status == 0) {
            status = createSlNetEventThread();
        }
% } /* end of: if(SLNETCONN.$static.generateEventThread) */
% } /* end of: if(SLNETCONN != null) */

% for (let i = 0; i< SlNet.$instances.length; i++) {
%   let inst = SlNet.$instances[i];
        /* add `inst.$name` interface */
        if (status == 0) {
%   if (inst.networkIfFxnList == "Custom") {
            extern SlNetIf_Config_t `inst.customFuncList`;
%   } /* end of: if (inst.networkIfFxnList == "customFuncList") { */
%   if (inst.importNIMU) {
%       let nimuIndex = util.findNimuIndex(inst);
            NIMU_IF_REQ ifReq;
            ifReq.index = `nimuIndex`;
            char ndkIfName[MAX_INTERFACE_NAME_LEN];

            status = NIMUIoctl(NIMU_GET_DEVICE_NAME, &ifReq, ndkIfName,
                            MAX_INTERFACE_NAME_LEN);
           /*
            * NIMUIoctl() should never fail as the arguments are correctly
            * generated by SysCfg and all NIMU devices require a name.
            * Just to be safe though, return -1 if there is an error.
            */
            if (status < 0 )
            {
                return (-1);
            }

            status = SlNetIf_add(SLNETIF_ID_`inst.id`, ndkIfName,
%   } /* end of: if (hasNDK) { */
%   else {
            status = SlNetIf_add(SLNETIF_ID_`inst.id`, "`inst.ifName`",
%   }
%   if (inst.networkIfFxnList == "NDK") {
%     if (inst.enableSecureSocks) {
                    (const SlNetIf_Config_t *)&SlNetIfConfigNDKSec,
%     } else {
                    (const SlNetIf_Config_t *)&SlNetIfConfigNDK,
%     }
%   } /* end of: if (inst.networkIfFxnList == "NDK") { */
%   else if (inst.networkIfFxnList == "SimpleLink WiFi") {
                    (const SlNetIf_Config_t *)&SlNetIfConfigWifi,
%   } /* end of: else if (inst.networkIfFxnList == "SimpleLink WiFi") { */
%   else {
                    (const SlNetIf_Config_t *)&`inst.customFuncList`,
%   }
                    `inst.priority`);
        }

%   if(inst.enableSecureSocks) {
%   for (let j = 0; j < inst.SECOBJ.length; j++) {
%       let secObj = inst.SECOBJ[j];
        if (status == 0) {
%       let secObjObject = null;
%       let secObjObjectLen = null;
%       if (secObj.dataInputMethod == "Reference to Secure Object Variable")  {
%           secObjObject = secObj.secObjVariable;
%           secObjObjectLen = secObj.secObjVariableSize;
            extern uint8_t `secObj.secObjVariable`[];
            extern uint16_t `secObj.secObjVariableSize`;
%       } /* end of: if (secObj.dataInputMethod == "Reference to Secure Object Variable") */
%       else if (secObj.dataInputMethod == "Secure Object Text") {
%           secObjObject = "config_secobj" + j + "_array";
%           secObjObjectLen = "config_secobj" + j + "_array_length";
            static uint8_t `secObjObject`[] =
%           let secObjLines = secObj.secObjText.split("\n");
%           for(let k = 0; k < secObjLines.length - 1; k++) {
                "`secObjLines[k]`\n"
%           } /* end of: for(let k = 0; k < secObjLines.length - 1; k++) { */
                "`secObjLines[secObjLines.length - 1]`";
            static const uint16_t `secObjObjectLen` = sizeof(config_secobj`j`_array);
%       } /* end of: else if (secObj.dataInputMethod == "Secure Object Text") { */

            status = SlNetIf_loadSecObj(`secObj.secObjType`, "`secObj.$name`",
                    strlen("`secObj.$name`"), `secObjObject`, `secObjObjectLen`, SLNETIF_ID_`inst.id`);
        }
%   } /* end of: for (let j = 0; j < inst.secObjs; j++) { */
%   } /* end of: if(inst.enableSecureSocks) { */
% } /*end of for (let i = 0; i< SlNet.$instances.length; i++) */
    }
    return (status);
}

% if (SLNETCONN && SLNETCONN.$static.generateEventThread) {
void *SlNetConn_processor(void *arg0) {

% if (hasNDK) {
    fdOpenSession(TaskSelf());
% }

    SlNetConn_process(NULL);

% if (hasNDK) {
    fdCloseSession(TaskSelf());
% }

    return (NULL);
}

static int32_t createSlNetEventThread(void) {
    int32_t             status;
    pthread_t           thread;
    pthread_attr_t      attrs;
    struct sched_param  priParam;

    pthread_attr_init(&attrs);
    priParam.sched_priority = `SLNETCONN.$static.eventThreadPriority`;

    status = pthread_attr_setschedparam(&attrs, &priParam);
    if (status == 0) {
        status = pthread_attr_setstacksize(&attrs, `SLNETCONN.$static.eventThreadStackSize`);
    }

    if (status == 0) {
        status = pthread_create(&thread, &attrs, SlNetConn_processor, 0);
    }

    return (status);
}
% } /* end of: if (SLNETCONN && SLNETCONN.$static.generateEventThread) */
