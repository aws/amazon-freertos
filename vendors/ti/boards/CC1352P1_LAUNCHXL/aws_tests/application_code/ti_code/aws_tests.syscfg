/*
 * Copyright (c) 2020, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// @cliArgs --board /ti/boards/CC1352P1_LAUNCHXL

/**
 * Import the modules used in this configuration.
 */
const ADCBuf      = scripting.addModule("/ti/drivers/ADCBuf", {}, false);
const ADCBuf1     = ADCBuf.addInstance();
const GPIO        = scripting.addModule("/ti/drivers/GPIO", {}, false);
const GPIO1       = GPIO.addInstance();
const GPIO2       = GPIO.addInstance();
const GPIO3       = GPIO.addInstance();
const I2C         = scripting.addModule("/ti/drivers/I2C", {}, false);
const I2C1        = I2C.addInstance();
const NVS         = scripting.addModule("/ti/drivers/NVS", {}, false);
const NVS1        = NVS.addInstance();
const NVS2        = NVS.addInstance();
const PWM         = scripting.addModule("/ti/drivers/PWM", {}, false);
const PWM1        = PWM.addInstance();
const RTOS        = scripting.addModule("/ti/drivers/RTOS");
const SPI         = scripting.addModule("/ti/drivers/SPI", {}, false);
const SPI1        = SPI.addInstance();
const Temperature = scripting.addModule("/ti/drivers/Temperature");
const UART        = scripting.addModule("/ti/drivers/UART", {}, false);
const UART1       = UART.addInstance();
const UART2       = UART.addInstance();
const Watchdog    = scripting.addModule("/ti/drivers/Watchdog", {}, false);
const Watchdog1   = Watchdog.addInstance();
const lpName = system.getScript("/ti/ble5stack/ble_common.js").getBoardOrLaunchPadName(true);

/**
 * Write custom configuration values to the imported modules.
 */
ADCBuf1.$name                                = "CONFIG_ADCBUF_0";
ADCBuf1.channels                             = 2;
ADCBuf1.timerInstance.$name                  = "CONFIG_GPTIMER_1";
ADCBuf1.adcBufChannel0.$name                 = "ADCBUF_CHANNEL_0";
ADCBuf1.adcBufChannel0.adc.adcPin.$assign    = "boosterpack.2";
ADCBuf1.adcBufChannel0.adcPinInstance0.$name = "CONFIG_PIN_11";
ADCBuf1.adcBufChannel1.$name                 = "ADCBUF_CHANNEL_1";
ADCBuf1.adcBufChannel1.adc.adcPin.$assign    = "boosterpack.6";
ADCBuf1.adcBufChannel1.adcPinInstance1.$name = "CONFIG_PIN_12";

GPIO1.$name             = "CONFIG_GPIO_0";
GPIO1.$hardware         = system.deviceData.board.components.LED_GREEN;
GPIO1.pinInstance.$name = "CONFIG_PIN_0";

GPIO2.$name             = "CONFIG_GPIO_1";
GPIO2.$hardware         = system.deviceData.board.components.LED_RED;
GPIO2.pinInstance.$name = "CONFIG_PIN_1";

GPIO3.$name                         = "CONFIG_GPIO_2";
GPIO3.gpioPin.$assignAllowConflicts = "boosterpack.24";
GPIO3.pinInstance.$name             = "CONFIG_PIN_2";

I2C1.$name                = "CONFIG_I2C_0";
I2C1.i2c.sdaPin.$assign   = "boosterpack.10";
I2C1.i2c.sclPin.$assign   = "boosterpack.9";
I2C1.sdaPinInstance.$name = "CONFIG_PIN_3";
I2C1.clkPinInstance.$name = "CONFIG_PIN_4";

NVS1.$name                    = "CONFIG_NVSINTERNAL";
NVS1.internalFlash.$name      = "ti_drivers_nvs_NVSCC26XX0";
NVS1.internalFlash.regionSize = 0x8000;
NVS1.internalFlash.regionBase   = 0x48000;
NVS2.$name                    = "CONFIG_NVSINTERNAL_COMMON_IO";
NVS2.internalFlash.$name      = "ti_drivers_nvs_NVSCC26XX0_1";
NVS2.internalFlash.regionSize = 0x8000;
NVS2.internalFlash.regionBase   = 0x40000;

PWM1.$name                                          = "CONFIG_PWM_0";
PWM1.timerObject.$name                              = "CONFIG_GPTIMER_0";
PWM1.timerObject.timer.$assign                      = "GPTM1";
PWM1.timerObject.timer.pwmPin.$assignAllowConflicts = "boosterpack.25";
PWM1.timerObject.pwmPinInstance.$name               = "CONFIG_PIN_10";

const CCFG              = scripting.addModule("/ti/devices/CCFG", {}, false);
CCFG.ccfgTemplate.$name = "ti_devices_CCFGTemplate0";

SPI1.$name                 = "CONFIG_SPI_0";
SPI1.sclkPinInstance.$name = "CONFIG_PIN_5";
SPI1.misoPinInstance.$name = "CONFIG_PIN_6";
SPI1.mosiPinInstance.$name = "CONFIG_PIN_7";

UART1.$name               = "CONFIG_UART_0";
UART1.$hardware           = system.deviceData.board.components.XDS110UART;
UART1.txPinInstance.$name = "CONFIG_PIN_8";
UART1.rxPinInstance.$name = "CONFIG_PIN_9";

UART2.$name                            = "CONFIG_UART_1";
UART2.uart.txPin.$assignAllowConflicts = "boosterpack.25";
UART2.uart.rxPin.$assignAllowConflicts = "boosterpack.24";
UART2.txPinInstance.$name              = "CONFIG_PIN_13";
UART2.rxPinInstance.$name              = "CONFIG_PIN_14";

Watchdog1.$name = "CONFIG_WATCHDOG_0";
RTOS.name = "FreeRTOS";
/* ======== AESCCM ======== */
var AESCCM = scripting.addModule("/ti/drivers/AESCCM");
var aesccm = AESCCM.addInstance();
aesccm.$name = "CONFIG_AESCCM0";
/* ======== AESECB ======== */
var AESECB = scripting.addModule("/ti/drivers/AESECB");
var aesecb = AESECB.addInstance();
aesecb.$name = "CONFIG_AESECB0";
/* ======== ECDH ======== */
var ECDH = scripting.addModule("/ti/drivers/ECDH");
var ecdh = ECDH.addInstance();
ecdh.$name = "CONFIG_ECDH0"
/* ======== AESCTRDRBG ======== */
var AESCTRDRBG = scripting.addModule("/ti/drivers/AESCTRDRBG");
var aesctrdrbg = AESCTRDRBG.addInstance();
aesctrdrbg.$name = "CONFIG_AESCTRDRBG_0";
aesctrdrbg.aesctrObject.$name = "CONFIG_AESCTR_0";
/* ======== RF ======== */
var RF = scripting.addModule("/ti/drivers/RF");
/* if an antenna component exists, assign it to the rf instance */
if (system.deviceData.board && system.deviceData.board.components.RF) {
    RF.$hardware = system.deviceData.board.components.RF;
}
/* ======== POWER ======== */
var Power = scripting.addModule("/ti/drivers/Power");
if(lpName == "CC2652RB_LAUNCHXL")
{
  Power.calibrateRCOSC_LF = false;
  Power.calibrateRCOSC_HF = false;
}
/* ======== TRNG ======== */
var TRNG = scripting.addModule("/ti/drivers/TRNG");
var trng = TRNG.addInstance();
/* ======== Device ======== */
var device = scripting.addModule("ti/devices/CCFG");
const ccfgSettings = system.getScript("/ti/common/lprf_ccfg_settings.js").ccfgSettings;
for(var setting in ccfgSettings)
{
    device[setting] = ccfgSettings[setting];
}
const bleCcfgSettings = system.getScript("/ti/ble5stack/ble_common.js").centralRoleCcfgSettings;
for(var setting in bleCcfgSettings)
{
    device[setting] = bleCcfgSettings[setting];
}
/* ======== RF Design ======== */
var rfDesign = scripting.addModule("ti/devices/radioconfig/rfdesign");
const rfDesignSettings = system.getScript("/ti/common/lprf_rf_design_settings.js").rfDesignSettings;
const radioSettings = system.getScript("/ti/ble5stack/ble_common.js").getRadioScript(rfDesign.rfDesign,system.deviceData.deviceId);
const bleRfDesignSettings = radioSettings.rfDesignParams;
for(var setting in rfDesignSettings)
{
    rfDesign[setting] = rfDesignSettings[setting];
}
for(var setting in bleRfDesignSettings)
{
    rfDesign[setting] = bleRfDesignSettings[setting];
}
/* ======== BLE ======== */
var ble = scripting.addModule("/ti/ble5stack/ble");
ble.rfDesign = rfDesignSettings.rfDesign;
ble.deviceRole = "PERIPHERAL_CFG";
ble.maxConnNum                         = 1;
ble.maxPDUNum                          = 3;
ble.maxPDUSize                         = 204;
ble.maxBonds                           = 1;

/**
 * Pinmux solution for unlocked pins/peripherals. This ensures that minor changes to the automatic solver in a future
 * version of the tool will not impact the pinmux you originally saw.  These lines can be completely deleted in order to
 * re-solve from scratch.
 */
ADCBuf1.adc.$suggestSolution                 = "ADC0";
ADCBuf1.adc.dmaADCChannel.$suggestSolution   = "DMA_CH7";
ADCBuf1.timerInstance.timer.$suggestSolution = "GPTM0";
ADCBuf1.adcBufChannel0.adc.$suggestSolution  = "ADC0";
ADCBuf1.adcBufChannel1.adc.$suggestSolution  = "ADC0";
GPIO1.gpioPin.$suggestSolution               = "boosterpack.40";
GPIO2.gpioPin.$suggestSolution               = "boosterpack.39";
I2C1.i2c.$suggestSolution                    = "I2C0";
SPI1.spi.$suggestSolution                    = "SSI0";
SPI1.spi.sclkPin.$suggestSolution            = "boosterpack.19";
SPI1.spi.misoPin.$suggestSolution            = "boosterpack.18";
SPI1.spi.mosiPin.$suggestSolution            = "boosterpack.30";
SPI1.spi.dmaRxChannel.$suggestSolution       = "DMA_CH3";
SPI1.spi.dmaTxChannel.$suggestSolution       = "DMA_CH4";
UART1.uart.$suggestSolution                  = "UART1";
UART1.uart.txPin.$suggestSolution            = "boosterpack.4";
UART1.uart.rxPin.$suggestSolution            = "boosterpack.3";
UART2.uart.$suggestSolution                  = "UART0";
Watchdog1.watchdog.$suggestSolution          = "WDT0";
