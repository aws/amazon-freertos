<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_getting_started.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>PDL depends on the Core Library. Download it from <a href="https://github.com/cypresssemiconductorco/core-lib">https://github.com/cypresssemiconductorco/core-lib</a> and add cy_utils.h to the include search path.</p>
<p>Include cy_pdl.h in your source code to use the library.</p>
<p>To successfully develop software for the PSoC 6 family of devices, you must configure the peripherals to implement desired behavior. In addition, you must configure clocks, GPIO, and interrupts, as well as route signals from one peripheral to another.</p>
<p>This introduction covers some high level concepts that help you understand and use the PDL to accomplish these tasks. The topics are:</p><ul>
<li><a class="el" href="page_getting_started.html#page_getting_started_pdl_overview">PDL Overview</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_pdl_design">PDL Design</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_memory_allocation">Memory Allocation</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_clk_and_periph">Clocks and Peripherals</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_gpio">General Purpose IO (GPIO)</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_interrupts">Interrupts</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_low_power">Power Mode Transitions</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_trigger_muxing">Trigger Muxing</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_inter_proc_comm">Inter-Processor Communication (IPC)</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_reentrancy_thread_safety">Reentrancy and Thread-safety</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_asserts">Asserts</a></li>
</ul>
<p>This PDL API Reference covers the peripheral drivers. Documentation on other parts of the overall software development kit are in there respective references, such as the Bootloader SDK API Reference and the BLE API Reference.</p>
<p><a class="anchor" id="page_getting_started_pdl_overview"></a></p><h1>PDL Overview</h1>
<p>PDL is the software development kit for the PSoC 6 family of devices. Although called the Peripheral Driver Library it contains much more than driver source code.</p>
<p>The PDL occupies the space between application code and the hardware IP blocks (peripherals). It provides driver source code you use to customize drivers for an application. To see the exact list of available drivers, expand the PDL API Reference in the left menu. It also includes all required device-specific header and startup files.</p>
<p>The PDL manages all register access. This reduces the need to understand register usage and bit fields, thus easing software development for the extensive set of peripherals provided for PSoC 6 devices.</p>
<p><a class="anchor" id="page_getting_started_pdl_design"></a></p><h1>PDL Design</h1>
<p>PSoC 6 devices use a dual core architecture with both a Cortex® M4 and a Cortex M0+ device. The hardware defines a shared register set and memory map for all peripherals. This means that, with few exceptions, either core can use any peripheral driver. For example, there is a single RTC driver used by either core, not separate CM4 and CM0+ RTC drivers.</p>
<p>The set of available peripherals varies per device. In some cases there are multiple instances of the same peripheral; for example, multiple Serial Communication Blocks (SCB). Each peripheral instance may itself operate on multiple instances of user data.</p>
<p>To enable a peripheral to be used by either or both cores, as well as multiple instances of configurable peripherals operating on (potentially) multiple instances of data, the PDL implements a simple, consistent design based on three fundamental concepts.</p>
<p><b>Base Hardware Address:</b> At the hardware level, peripheral features and behavior are controlled by registers. Each peripheral instance has a base hardware address that points to the registers for that instance. The PDL uses this base address to access the necessary registers. A device-specific header file defines the symbols for the base hardware address of each instance of each peripheral. For example, the PSoC 6 BLE Pioneer Kit uses the CY8C6347BZI-BLD53 device. The PDL includes the device-specific header file in the devices folder: &lt;PDL directory&gt;/devices/include/cy8c6347bzi_bld53.h</p>
<p>Each such file defines a symbol that represents a pointer to the base hardware address for each instance of each peripheral on the device. Use this symbol in your code. The next snippet shows the symbols for instances of the SCB peripheral on this device, which supports nine SCB instances: </p><div class="image">
<img src="getting_started_base_address.png" alt="getting_started_base_address.png"/>
</div>
<p> The header file contains similar definitions for each peripheral.</p>
<p><b>Configuration Structure:</b> Each peripheral instance is configurable. Modify values in a PDL configuration structure to change behavior to fit design requirements. The PDL then manages register access using the base hardware address.</p>
<p><b>Context Structure:</b> A PDL driver may require memory to peform operations. A driver does not allocate memory for this purpose. Firmware allocates the required memory by declaring an instance of a context structure. The address of this variable is passed in function calls. The PDL defines all necessary context structures.</p>
<p>The PDL manages the contents of the context variable. <em>Firmware does not read or write the values of the fields in a context variable.</em> In effect, firmware provides a scratch pad in memory for the PDL driver to do its work. Firmware must ensure that a context variable remains in scope when in use. Typically a context variable is declared as static, or as a global variable.</p>
<p>Many PDL API function calls require a parameter representing one or more of these three concepts. The precise details vary per peripheral, but the design is consistent. There are three commonly-named parameters in the PDL, used to support this design.</p>
<center>Common PDL Parameters</center><table class="doxtable">
<tr>
<th>Parameter </th><th>Data Type </th><th>Purpose  </th></tr>
<tr>
<td><code>base</code> </td><td>&lt;peripheral&gt;_Type* </td><td>Base hardware address for an instance of a peripheral  </td></tr>
<tr>
<td><code>config</code> </td><td>cy_stc_&lt;peripheral&gt;_config_t* </td><td>A structure with configuration information for a peripheral  </td></tr>
<tr>
<td><code>context</code> </td><td>cy_stc_&lt;peripheral&gt;_context_t* </td><td>A structure declared by firmware to allocate memory for a peripheral  </td></tr>
</table>
<p>In addition, all functions follow this naming convention: Cy_&lt;Peripheral&gt;_&lt;FunctionName&gt;().</p>
<p>Firmware must initialize and enable a driver before using it. The PDL API has functions for the purpose. Some peripherals may not implement one or more of these common functions because they aren’t needed for that particular peripheral.</p>
<center>Common PDL Functions</center><table class="doxtable">
<tr>
<th>Name </th><th>Purpose </th><th>Example  </th></tr>
<tr>
<td>Cy_&lt;Peripheral&gt;_Init() </td><td>Initialize a peripheral, typically based on a config structure </td><td><a class="el" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51" title="Initializes the SCB for UART operation. ">Cy_SCB_UART_Init()</a>  </td></tr>
<tr>
<td>Cy_&lt;Peripheral&gt;_DeInit() </td><td>de-initialize a peripheral </td><td><a class="el" href="group__group__scb__uart__general__functions.html#ga75294a651a2535fe9fd09af33c726920" title="De-initializes the SCB block. ">Cy_SCB_UART_DeInit()</a>  </td></tr>
<tr>
<td>Cy_&lt;Peripheral&gt;_Enable() </td><td>turn on the peripheral </td><td><a class="el" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905" title="Enables the SCB block for the UART operation. ">Cy_SCB_UART_Enable()</a>  </td></tr>
<tr>
<td>Cy_&lt;Peripheral&gt;_Disable() </td><td>turn off the peripheral </td><td><a class="el" href="group__group__scb__uart__general__functions.html#ga2a07f58f9a898202d43bc3b14caab2de" title="Disables the SCB block and clears context statuses. ">Cy_SCB_UART_Disable()</a>  </td></tr>
</table>
<p><b>Return Status Code:</b> Each driver has a unique return status enumeration type - cy_en_&lt;peripheral&gt;_status_t. The type is used by functions within the driver to indicate the return status. Drivers return success status code with a value of 0. The status code consists of the following fields:</p>
<div class="image">
<img src="getting_started_return_status_code.png" alt="getting_started_return_status_code.png"/>
</div>
<ul>
<li>The higher 14 bits identify the driver that is returning status.</li>
<li>The 2 bits after, indicates the status type: 0 for information, 1 for warning, and 2 for error.</li>
<li>The lower 16 bits contain the actual returned status.</li>
</ul>
<p>Example of return status type: </p><div class="image">
<img src="getting_started_return_status_example.png" alt="getting_started_return_status_example.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>It is possible for one driver to call another driver and return the status code from that other driver. For instance, for PSoC 64 devices the SysPm and SysClk drivers use PRA driver functionality. If there is an error in the PRA driver, the SysPm or SysClk driver may return the PRA driver status. The value returned always identifies the driver that is the source of the error. Refer to the driver description for details.</dd></dl>
<p><a class="anchor" id="page_getting_started_memory_allocation"></a></p><h1>Memory Allocation</h1>
<p>A direct effect of the context structure described in the PDL Design section is that the PDL drivers do not dynamically allocate memory. The user allocates the memory required by the driver, by declaring a context structure.</p>
<p><a class="anchor" id="page_getting_started_clk_and_periph"></a></p><h1>Clocks and Peripherals</h1>
<p>PSoC 6 devices have several source clocks, a Frequency Lock Loop (FLL), and one or more phase lock loops (PLL). Firmware configures and enables the source clocks and clock dividers based on design requirements. The clocks and clock tree are fully documented in the <em>Clocking System</em> chapter of the <em>Technical Reference Manual</em> (TRM).</p>
<p>A peripheral can only be clocked by a peripheral clock divider. For example, the PSoC 6 BLE has 29 peripheral clock dividers. CLK_PERI is the source clock for all programmable peripheral clock dividers. The output of any divider can be routed to any peripheral.</p>
<div class="image">
<img src="getting_started_clock_diagram.png" alt="getting_started_clock_diagram.png"/>
</div>
<p>The ModusToolbox Device Configurator provides a friendly user interface for managing clocks on the System and Peripheral-Clocks tabs. The Device Configurator generates the required code based upon your design (../GeneratedSources/cycfg_system.c/.h and cycfg_clocks.c/.h files correspondently).</p>
<p>If you create your design without the Device Configurator you must manage the clock configuration via code you write. The PDL provides the <a href="group__group__sysclk.html">System Clock</a> (SysClk) driver for this purpose.</p>
<p><a class="anchor" id="page_getting_started_gpio"></a></p><h1>GPIO</h1>
<p>The PSoC 6 I/O system provides the interface between the CPU core and peripheral components to the outside world. With a PSoC 6 device firmware can route most signals to most pins, which greatly simplifies circuit design and board layout.</p>
<p>The GPIO pins in PSoC 6 are grouped into ports; a port has a maximum of eight GPIOs. The high-speed I/O matrix (HSIOM) is a set of high-speed multiplexers that route internal CPU and peripheral signals to and from GPIOs. HSIOM allows GPIOs to be shared with multiple functions and multiplexes the pin connection to a particular peripheral selected by the user. See the <em>I/O System</em> chapter of the TRM for full technical details.</p>
<p>Each pin has several characteristics, such as drive mode, slew rate, and buffer mode. You can configure pins at the Pins tab of the ModusToolbox Device Configurator tool.</p>
<p>Firmware can configure and modify a pin at run time as well. The PDL provides the <a href="group__group__gpio.html">General Purpose Input Output</a> (GPIO) driver to assist. Firmware can initialize, read, write, set, clear, or invert the state of a pin, get or clear the interrupt state on the pin, and more.</p>
<p><a class="anchor" id="page_getting_started_interrupts"></a></p><h1>Interrupts</h1>
<p>A PSoC 6 device supports many system and peripheral interrupts. These are processed by the Nested Vector Interrupt Controller (NVIC) of the individual core. On the Cortex M4, system interrupt source 'n' is directly connected to the corresponding IRQn. The Cortex-M0+ has fewer IRQns than there are interrupt sources. Firmware can connect any interrupt source to any IRQn on the Cortex M0+. However, some CM0+ IRQs are reserved for system use. See the <a href="group__group__sysint.html">System Interrupt</a> (SysInt) driver documentation. The NVIC takes care of enabling/disabling individual interrupt IRQs, priority resolution, and communication with the CPU core. See the <em>Interrupts</em> chapter of the TRM.</p>
<p>Interrupts are set up at the system level for any peripheral that handles an interrupt. The PDL provides the <a href="group__group__sysint.html">System Interrupt</a> (SysInt) driver to assist in configuring interrupts. To connect an interrupt service routine (ISR) to an interrupt signal, initialize the system interrupt with a configuration structure (containing the interrupt number and priority), and provide the address of the ISR. For the M0+ device, also provide the interrupt source (because of interrupt muxing). Various drivers have support for setting, clearing, and masking interrupts, or to specify a callback routine.</p>
<p><a class="anchor" id="page_getting_started_low_power"></a></p><h1>Power Mode Transitions</h1>
<p>The System Power Management driver (SysPM) implements a callback mechanism to handle power mode transitions. This mechanism allows any driver to perform any operation required to prepare for the specific power mode, or to abort the transition. Power mode transition callbacks are maintained as a linked list. The driver calls them in order, either first to last, or last to first, as appropriate. </p>
<p>Every driver concerned with entering or returning from a low-power state must register callback functions with SysPM. If there is any order dependence among the drivers in your firmware, register the callbacks in the order you require. For example, callbacks that configure global resources, such as clock frequencies, should be registered last.</p>
<p>If your firmware does not register any SysPM callbacks, the device just executes the power mode transition.</p>
<p>See the <a href="group__group__syspm.html">System Power Management</a> (SysPM) documentation for details. </p>
<p><a class="anchor" id="page_getting_started_trigger_muxing"></a></p><h1>Trigger Muxing</h1>
<p>A design may require that the output from one peripheral triggers behavior in another peripheral. For example, a SPI (SCB) peripheral block receives data. After the data is received, a signal from the SCB triggers a DMA channel to transfer the received data to a memory buffer.</p>
<p>The PSoC 6 trigger multiplexer block implements a collection of multiplexers that can connect any trigger signal from any peripheral to any other peripheral. To support this the hardware implements an input layer and an output layer. The input layer has reduction multiplexer groups, which have as input the trigger signals coming from different peripheral blocks. The reduction multiplexer routes these signals to an intermediate trigger signal. The output side uses that intermediate trigger as its input, and uses a distribution multiplexer to send that signal to one or more peripherals. The design also supports a software trigger for any signal. See the <em>Trigger Multiplexer Block</em> chapter of the TRM.</p>
<p>The PDL provides the <a href="group__group__trigmux.html">Trigger Multiplexer</a> (TrigMux) driver to enable this. To route a trigger signal from one peripheral in the PSoC to another, firmware configures both a reduction multiplexer and a distribution multiplexer, to define where the signal comes from, and where it goes to. The software trigger triggers all peripherals connected to that output signal.</p>
<p><a class="anchor" id="page_getting_started_inter_proc_comm"></a></p><h1>Inter-Processor Communication (IPC)</h1>
<p>In a dual-core system, care must be taken to ensure that the two cores don’t access the same resource simultaneously. The IPC hardware block provides the functionality for multiple processors to communicate and synchronize their activities. See the <em>Inter-Processor Communication</em> chapter of the TRM.</p>
<p>The PDL provides the <a href="group__group__ipc.html">Inter-Process Communication</a> (IPC) driver to enable this.</p>
<p>The API implements the concept of a Pipe. A Pipe is typically a full-duplex communication channel between CPU cores. A pipe allows a single conduit to transfer messages or data to and from multiple processes or CPUs.</p>
<p>A pipe has two endpoints, one on each core. Each endpoint contains a dedicated IPC channel and an interrupt. The interrupt handles both notify and release events for the endpoint. Each endpoint has clients. A client is a process that receives a message and operates on the data in that message. A pipe can service an arbitrary number of clients on either endpoint. This design enables any number of processes on the sending core to put arbitrary data into a single pipe, destined for one or more recipients.</p>
<p>The data in the pipe is limited to a 32-bit value, which is a pointer to data of arbitrary complexity.</p>
<p>The IPC driver also implements a semaphore mechanism, so firmware can control access to shared resources.</p>
<p><a class="anchor" id="page_getting_started_reentrancy_thread_safety"></a></p><h1>Reentrancy and Thread-safety</h1>
<p>The PDL was designed to support multithreaded operations. Most of the PDL API functions are reentrant by satisfying the following conditions:</p>
<ul>
<li>Do not use internal static or global variables in a non-atomic way, unless a variable is allocated to a specific instance of a function. That is, each thread can have its own data area identifiable via function context parameter, so a single instance of the function can be shared by multiple threads.</li>
<li>Do not access a hardware resource in a non-atomic way. Access to a shared resource is protected using critical sections.</li>
<li>Static or global variables are set only at initialization, and then are read only.</li>
<li>Do not call non-reentrant functions.</li>
</ul>
<p>Some drivers are not thread-safe because they contain internal static state of the driver/peripheral. You can arrange your application code or use your own locking mechanism to ensure that functions in these drivers are called by only one thread at a time. Call initialization functions once to initialize the peripheral before creating any additional thread that will use the peripheral.</p>
<ul>
<li>EFUSE</li>
<li>Profile</li>
<li>Startup</li>
<li>SysClk</li>
<li>SysLib</li>
<li>SysPm</li>
</ul>
<p><a class="anchor" id="page_getting_started_asserts"></a></p><h1>Asserts</h1>
<p>The <a href="group__group__syslib.html">System Library</a> files define an assert mechanism that is used extensively by the PDL for parameter checking. It is enabled by default. It is recommended that asserts remain enabled when debugging firmware.</p>
<p>Firmware can use the same assert mechanism. The default assertion handler <a class="el" href="group__group__syslib__functions.html#ga0fe70e0948f5d2b2fb1615b85b0d7d7a" title="This function stores the ASSERT location of the file name (including path to file) and line number in...">Cy_SysLib_AssertFailed()</a> is weakly linked. Firmware can override that function to implement custom assert handling.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
