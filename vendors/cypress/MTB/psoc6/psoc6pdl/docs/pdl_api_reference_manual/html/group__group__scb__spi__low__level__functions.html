<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Low-Level</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__spi__low__level__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Low-Level<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a> &raquo; <a class="el" href="group__group__scb__spi.html">SPI (SCB)</a> &raquo; <a class="el" href="group__group__scb__spi__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga169c313a3508261fa76e6b6600cce726"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#ga169c313a3508261fa76e6b6600cce726">Cy_SCB_SPI_Read</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga169c313a3508261fa76e6b6600cce726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single data element from the SPI RX FIFO.  <a href="#ga169c313a3508261fa76e6b6600cce726">More...</a><br /></td></tr>
<tr class="separator:ga169c313a3508261fa76e6b6600cce726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecc7c7a8d0ba840fa5d65e5076cb9d84"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#gaecc7c7a8d0ba840fa5d65e5076cb9d84">Cy_SCB_SPI_ReadArray</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:gaecc7c7a8d0ba840fa5d65e5076cb9d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of data out of the SPI RX FIFO.  <a href="#gaecc7c7a8d0ba840fa5d65e5076cb9d84">More...</a><br /></td></tr>
<tr class="separator:gaecc7c7a8d0ba840fa5d65e5076cb9d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b613c5544c0595763e30d83da125a4d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#ga6b613c5544c0595763e30d83da125a4d">Cy_SCB_SPI_Write</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t data)</td></tr>
<tr class="memdesc:ga6b613c5544c0595763e30d83da125a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a single data element in the SPI TX FIFO.  <a href="#ga6b613c5544c0595763e30d83da125a4d">More...</a><br /></td></tr>
<tr class="separator:ga6b613c5544c0595763e30d83da125a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5415bd46d159b57f08fa0eb375a133e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#gad5415bd46d159b57f08fa0eb375a133e">Cy_SCB_SPI_WriteArray</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:gad5415bd46d159b57f08fa0eb375a133e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an array of data in the SPI TX FIFO.  <a href="#gad5415bd46d159b57f08fa0eb375a133e">More...</a><br /></td></tr>
<tr class="separator:gad5415bd46d159b57f08fa0eb375a133e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6899c2b1dd9f868a7fb625b03a7ee594"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#ga6899c2b1dd9f868a7fb625b03a7ee594">Cy_SCB_SPI_WriteArrayBlocking</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga6899c2b1dd9f868a7fb625b03a7ee594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places an array of data in the SPI TX FIFO.  <a href="#ga6899c2b1dd9f868a7fb625b03a7ee594">More...</a><br /></td></tr>
<tr class="separator:ga6899c2b1dd9f868a7fb625b03a7ee594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987fdbe86c1fbfbadfa51cdf82f84632"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#ga987fdbe86c1fbfbadfa51cdf82f84632">Cy_SCB_SPI_GetTxFifoStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga987fdbe86c1fbfbadfa51cdf82f84632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current status of the TX FIFO.  <a href="#ga987fdbe86c1fbfbadfa51cdf82f84632">More...</a><br /></td></tr>
<tr class="separator:ga987fdbe86c1fbfbadfa51cdf82f84632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6044cb7d9567450502fec59537dad4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#gadf6044cb7d9567450502fec59537dad4">Cy_SCB_SPI_ClearTxFifoStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t clearMask)</td></tr>
<tr class="memdesc:gadf6044cb7d9567450502fec59537dad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the selected statuses of the TX FIFO.  <a href="#gadf6044cb7d9567450502fec59537dad4">More...</a><br /></td></tr>
<tr class="separator:gadf6044cb7d9567450502fec59537dad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50acb3879906a729e5821fcc87d4f017"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#ga50acb3879906a729e5821fcc87d4f017">Cy_SCB_SPI_GetRxFifoStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga50acb3879906a729e5821fcc87d4f017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current status of the RX FIFO.  <a href="#ga50acb3879906a729e5821fcc87d4f017">More...</a><br /></td></tr>
<tr class="separator:ga50acb3879906a729e5821fcc87d4f017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08b31f2964a1c0895531d05487ad383"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#gae08b31f2964a1c0895531d05487ad383">Cy_SCB_SPI_ClearRxFifoStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t clearMask)</td></tr>
<tr class="memdesc:gae08b31f2964a1c0895531d05487ad383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the selected statuses of the RX FIFO.  <a href="#gae08b31f2964a1c0895531d05487ad383">More...</a><br /></td></tr>
<tr class="separator:gae08b31f2964a1c0895531d05487ad383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e9a4b77a8db35ccbda974e7f9d9d23"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#gac9e9a4b77a8db35ccbda974e7f9d9d23">Cy_SCB_SPI_GetSlaveMasterStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gac9e9a4b77a8db35ccbda974e7f9d9d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current status of either the slave or the master, depending on the configured SPI mode.  <a href="#gac9e9a4b77a8db35ccbda974e7f9d9d23">More...</a><br /></td></tr>
<tr class="separator:gac9e9a4b77a8db35ccbda974e7f9d9d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085a0e7fb73b9feb3b66ca5017449e6b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#ga085a0e7fb73b9feb3b66ca5017449e6b">Cy_SCB_SPI_ClearSlaveMasterStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t clearMask)</td></tr>
<tr class="memdesc:ga085a0e7fb73b9feb3b66ca5017449e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the selected statuses of either the slave or the master.  <a href="#ga085a0e7fb73b9feb3b66ca5017449e6b">More...</a><br /></td></tr>
<tr class="separator:ga085a0e7fb73b9feb3b66ca5017449e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9be16f0ae646a85e9fffe9731cb4896"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#gad9be16f0ae646a85e9fffe9731cb4896">Cy_SCB_SPI_GetNumInTxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gad9be16f0ae646a85e9fffe9731cb4896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data elements in the SPI TX FIFO.  <a href="#gad9be16f0ae646a85e9fffe9731cb4896">More...</a><br /></td></tr>
<tr class="separator:gad9be16f0ae646a85e9fffe9731cb4896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399842a2931b7c6cd85446a72cc2f81b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#ga399842a2931b7c6cd85446a72cc2f81b">Cy_SCB_SPI_IsTxComplete</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga399842a2931b7c6cd85446a72cc2f81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the TX FIFO and Shifter are empty and there is no more data to send.  <a href="#ga399842a2931b7c6cd85446a72cc2f81b">More...</a><br /></td></tr>
<tr class="separator:ga399842a2931b7c6cd85446a72cc2f81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6c37058e015b59c0e307d0d0e77ad0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#gaea6c37058e015b59c0e307d0d0e77ad0">Cy_SCB_SPI_GetNumInRxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gaea6c37058e015b59c0e307d0d0e77ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data elements in the SPI RX FIFO.  <a href="#gaea6c37058e015b59c0e307d0d0e77ad0">More...</a><br /></td></tr>
<tr class="separator:gaea6c37058e015b59c0e307d0d0e77ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a6bc98792bb02d878acfae0ff07ff0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#gaf8a6bc98792bb02d878acfae0ff07ff0">Cy_SCB_SPI_ClearRxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base)</td></tr>
<tr class="memdesc:gaf8a6bc98792bb02d878acfae0ff07ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data out of the SPI RX FIFO.  <a href="#gaf8a6bc98792bb02d878acfae0ff07ff0">More...</a><br /></td></tr>
<tr class="separator:gaf8a6bc98792bb02d878acfae0ff07ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eea4d58a1455170f4ec41dc6333b0a7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__spi__low__level__functions.html#ga6eea4d58a1455170f4ec41dc6333b0a7">Cy_SCB_SPI_ClearTxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base)</td></tr>
<tr class="memdesc:ga6eea4d58a1455170f4ec41dc6333b0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all data out of the SPI TX FIFO.  <a href="#ga6eea4d58a1455170f4ec41dc6333b0a7">More...</a><br /></td></tr>
<tr class="separator:ga6eea4d58a1455170f4ec41dc6333b0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga169c313a3508261fa76e6b6600cce726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga169c313a3508261fa76e6b6600cce726">&#9670;&nbsp;</a></span>Cy_SCB_SPI_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a single data element from the SPI RX FIFO. </p>
<p>This function does not check whether the RX FIFO has data before reading it. If the RX FIFO is empty, the function returns <a class="el" href="group__group__scb__spi__macros.html#ga065d56e0799fbb18c301ba22aaccd13c">CY_SCB_SPI_RX_NO_DATA</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data from the RX FIFO. The data element size is defined by the configured RX data width.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function only reads data available in the RX FIFO. It does not initiate an SPI transfer.</li>
<li>When in the master mode, this function writes data into the TX FIFO and waits until the transfer is completed before reading data from the RX FIFO. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaecc7c7a8d0ba840fa5d65e5076cb9d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecc7c7a8d0ba840fa5d65e5076cb9d84">&#9670;&nbsp;</a></span>Cy_SCB_SPI_ReadArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_ReadArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of data out of the SPI RX FIFO. </p>
<p>This function does not block. It returns how many data elements were read from the RX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to the location to place data read from the RX FIFO. The element size is defined by the data type, which depends on the configured RX data width.</td></tr>
    <tr><td class="paramname">size</td><td>The number of data elements to read from the RX FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements read from the RX FIFO.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function only reads data available in the RX FIFO. It does not initiate an SPI transfer.</li>
<li>When in the master mode, this function writes data into the TX FIFO and waits until the transfer is completed before reading data from the RX FIFO. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6b613c5544c0595763e30d83da125a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b613c5544c0595763e30d83da125a4d">&#9670;&nbsp;</a></span>Cy_SCB_SPI_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places a single data element in the SPI TX FIFO. </p>
<p>This function does not block. It returns how many data elements were placed in the TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
    <tr><td class="paramname">data</td><td>Data to put in the TX FIFO. The element size is defined by the data type, which depends on the configured TX data width.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements placed in the TX FIFO: 0 or 1.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When in the master mode, writing data into the TX FIFO starts an SPI transfer.</li>
<li>When in the slave mode, writing data into the TX FIFO does not start an SPI transfer. The data is loaded in the TX FIFO and will be sent to the master on its request.</li>
<li>The SPI interface is full-duplex, therefore reads and writes occur at the same time. Thus, for every data element transferred out of the TX FIFO, one is transferred into the RX FIFO. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad5415bd46d159b57f08fa0eb375a133e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5415bd46d159b57f08fa0eb375a133e">&#9670;&nbsp;</a></span>Cy_SCB_SPI_WriteArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_WriteArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places an array of data in the SPI TX FIFO. </p>
<p>This function does not block. It returns how many data elements were placed in the TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to the data to place in the TX FIFO. The element size is defined by the data type, which depends on the configured TX data width.</td></tr>
    <tr><td class="paramname">size</td><td>The number of data elements to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements placed in the TX FIFO.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When in the master mode, writing data into the TX FIFO starts an SPI transfer.</li>
<li>When in the slave mode, writing data into the TX FIFO does not start an SPI transfer. The data is loaded in the TX FIFO and will be sent to the master on its request.</li>
<li>The SPI interface is full-duplex, therefore reads and writes occur at the same time. Thus, for every data element transferred out of the TX FIFO, one is transferred into the RX FIFO. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6899c2b1dd9f868a7fb625b03a7ee594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6899c2b1dd9f868a7fb625b03a7ee594">&#9670;&nbsp;</a></span>Cy_SCB_SPI_WriteArrayBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SPI_WriteArrayBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places an array of data in the SPI TX FIFO. </p>
<p>This function blocks until the number of data elements specified by size is placed in the SPI TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to data to place in the TX FIFO. The element size is defined by the data type, which depends on the configured TX data width.</td></tr>
    <tr><td class="paramname">size</td><td>The number of data elements to write into the TX FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When in the master mode, writing data into the TX FIFO starts an SPI transfer.</li>
<li>When in the slave mode, writing data into the TX FIFO does not start an SPI transfer. The data is loaded in the TX FIFO and will be sent to the master on its request.</li>
<li>The SPI interface is full-duplex, therefore reads and writes occur at the same time. Thus, for every data element transferred out of the TX FIFO, one is transferred into the RX FIFO. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga987fdbe86c1fbfbadfa51cdf82f84632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987fdbe86c1fbfbadfa51cdf82f84632">&#9670;&nbsp;</a></span>Cy_SCB_SPI_GetTxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_GetTxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current status of the TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__spi__macros__tx__fifo__status.html">SPI TX FIFO Statuses</a> </dd></dl>

</div>
</div>
<a id="gadf6044cb7d9567450502fec59537dad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf6044cb7d9567450502fec59537dad4">&#9670;&nbsp;</a></span>Cy_SCB_SPI_ClearTxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SPI_ClearTxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the selected statuses of the TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
    <tr><td class="paramname">clearMask</td><td>The mask of which statuses to clear. See <a class="el" href="group__group__scb__spi__macros__tx__fifo__status.html">SPI TX FIFO Statuses</a> for the set of constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The status is also used for interrupt generation, so clearing it also clears the interrupt sources.</li>
<li>Level sensitive statuses such as <a class="el" href="group__group__scb__spi__macros__tx__fifo__status.html#ga09966d868419acdcc1b39a20e168437a">CY_SCB_SPI_TX_TRIGGER</a>, <a class="el" href="group__group__scb__spi__macros__tx__fifo__status.html#gac78e12f183e9dd8363763baf5c4694ab">CY_SCB_SPI_TX_EMPTY</a> and <a class="el" href="group__group__scb__spi__macros__tx__fifo__status.html#ga02c11eee0328c4d9907fae3ce30f050c">CY_SCB_SPI_TX_NOT_FULL</a> set high again after being cleared if the condition remains true. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga50acb3879906a729e5821fcc87d4f017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50acb3879906a729e5821fcc87d4f017">&#9670;&nbsp;</a></span>Cy_SCB_SPI_GetRxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_GetRxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current status of the RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__spi__macros__rx__fifo__status.html">SPI RX FIFO Statuses</a> </dd></dl>

</div>
</div>
<a id="gae08b31f2964a1c0895531d05487ad383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae08b31f2964a1c0895531d05487ad383">&#9670;&nbsp;</a></span>Cy_SCB_SPI_ClearRxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SPI_ClearRxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the selected statuses of the RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
    <tr><td class="paramname">clearMask</td><td>The mask of which statuses to clear. See <a class="el" href="group__group__scb__spi__macros__rx__fifo__status.html">SPI RX FIFO Statuses</a> for the set of constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This status is also used for interrupt generation, so clearing it also clears the interrupt sources.</li>
<li>Level sensitive statuses such as <a class="el" href="group__group__scb__spi__macros__rx__fifo__status.html#gaaa87359ee2a7bd8e448ba5417558e8bf">CY_SCB_SPI_RX_TRIGGER</a>, <a class="el" href="group__group__scb__spi__macros__rx__fifo__status.html#ga635fed2d6204ec644ad4ce4c8122350c">CY_SCB_SPI_RX_NOT_EMPTY</a> and <a class="el" href="group__group__scb__spi__macros__rx__fifo__status.html#ga2b1848eb7a3dfe6c4005bb6e66b820cc">CY_SCB_SPI_RX_FULL</a> set high again after being cleared if the condition remains true. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac9e9a4b77a8db35ccbda974e7f9d9d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9e9a4b77a8db35ccbda974e7f9d9d23">&#9670;&nbsp;</a></span>Cy_SCB_SPI_GetSlaveMasterStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_GetSlaveMasterStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current status of either the slave or the master, depending on the configured SPI mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__spi__macros__master__slave__status.html">SPI Master and Slave Statuses</a> </dd></dl>

</div>
</div>
<a id="ga085a0e7fb73b9feb3b66ca5017449e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga085a0e7fb73b9feb3b66ca5017449e6b">&#9670;&nbsp;</a></span>Cy_SCB_SPI_ClearSlaveMasterStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SPI_ClearSlaveMasterStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the selected statuses of either the slave or the master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
    <tr><td class="paramname">clearMask</td><td>The mask of which statuses to clear. See <a class="el" href="group__group__scb__spi__macros__master__slave__status.html">SPI Master and Slave Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9be16f0ae646a85e9fffe9731cb4896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9be16f0ae646a85e9fffe9731cb4896">&#9670;&nbsp;</a></span>Cy_SCB_SPI_GetNumInTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_GetNumInTxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data elements in the SPI TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements in the TX FIFO. The size of a data element defined by the configured TX data width.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This number does not include any data currently in the TX shifter. </dd></dl>

</div>
</div>
<a id="ga399842a2931b7c6cd85446a72cc2f81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399842a2931b7c6cd85446a72cc2f81b">&#9670;&nbsp;</a></span>Cy_SCB_SPI_IsTxComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SCB_SPI_IsTxComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the TX FIFO and Shifter are empty and there is no more data to send. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If true, transmission complete. If false, transmission is not complete. </dd></dl>

</div>
</div>
<a id="gaea6c37058e015b59c0e307d0d0e77ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea6c37058e015b59c0e307d0d0e77ad0">&#9670;&nbsp;</a></span>Cy_SCB_SPI_GetNumInRxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_SPI_GetNumInRxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data elements in the SPI RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of data elements in the RX FIFO. The size of a data element defined by the configured RX data width.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This number does not include any data currently in the RX shifter. </dd></dl>

</div>
</div>
<a id="gaf8a6bc98792bb02d878acfae0ff07ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a6bc98792bb02d878acfae0ff07ff0">&#9670;&nbsp;</a></span>Cy_SCB_SPI_ClearRxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SPI_ClearRxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all data out of the SPI RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Side Effects</dt><dd>Any data currently in the shifter is cleared and lost. </dd></dl>

</div>
</div>
<a id="ga6eea4d58a1455170f4ec41dc6333b0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eea4d58a1455170f4ec41dc6333b0a7">&#9670;&nbsp;</a></span>Cy_SCB_SPI_ClearTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SPI_ClearTxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all data out of the SPI TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SPI SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Side Effects</dt><dd>The TX FIFO clear operation also clears the shift register; the shifter can be cleared in the middle of a data element transfer, corrupting it. The data element corruption means that all bits that have not been transmitted are transmitted as 1s on the bus. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
