<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__ipc__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__ipc.html">IPC          (Inter Process Communication)</a> &raquo; <a class="el" href="group__group__ipc__drv.html">IPC driver layer (IPC_DRV)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Functions are used in the driver. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa1ca9b002b286f12fde442c8653aa3bf"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a> (uint32_t ipcIndex)</td></tr>
<tr class="memdesc:gaa1ca9b002b286f12fde442c8653aa3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes an IPC channel index as a parameter and returns the base address the IPC registers corresponding to the IPC channel.  <a href="#gaa1ca9b002b286f12fde442c8653aa3bf">More...</a><br /></td></tr>
<tr class="separator:gaa1ca9b002b286f12fde442c8653aa3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea293f27dc3d6d69eb40ef2d8f5c8d2b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE IPC_INTR_STRUCT_Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a> (uint32_t ipcIntrIndex)</td></tr>
<tr class="memdesc:gaea293f27dc3d6d69eb40ef2d8f5c8d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes an IPC interrupt structure index and returns the base address of the IPC interrupt registers corresponding to the IPC Interrupt.  <a href="#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">More...</a><br /></td></tr>
<tr class="separator:gaea293f27dc3d6d69eb40ef2d8f5c8d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47dfdecf96bad000b825ae79bfea0f80"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga47dfdecf96bad000b825ae79bfea0f80">Cy_IPC_Drv_AcquireNotify</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *base, uint32_t notifyEventIntr)</td></tr>
<tr class="memdesc:ga47dfdecf96bad000b825ae79bfea0f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function generates a acquire notification event by IPC interrupt structure.  <a href="#ga47dfdecf96bad000b825ae79bfea0f80">More...</a><br /></td></tr>
<tr class="separator:ga47dfdecf96bad000b825ae79bfea0f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae012b59909da4867ac1112f69f9dd3a1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#gae012b59909da4867ac1112f69f9dd3a1">Cy_IPC_Drv_ReleaseNotify</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *base, uint32_t notifyEventIntr)</td></tr>
<tr class="memdesc:gae012b59909da4867ac1112f69f9dd3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function generates a release notification event by IPC interrupt structure.  <a href="#gae012b59909da4867ac1112f69f9dd3a1">More...</a><br /></td></tr>
<tr class="separator:gae012b59909da4867ac1112f69f9dd3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8691465b9797f0b764505e9c77d41b02"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga8691465b9797f0b764505e9c77d41b02">Cy_IPC_Drv_LockAcquire</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:ga8691465b9797f0b764505e9c77d41b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to acquire the IPC channel.  <a href="#ga8691465b9797f0b764505e9c77d41b02">More...</a><br /></td></tr>
<tr class="separator:ga8691465b9797f0b764505e9c77d41b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c675e2c6b20599160bfb0046cfee109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga7c675e2c6b20599160bfb0046cfee109">Cy_IPC_Drv_LockRelease</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *base, uint32_t releaseEventIntr)</td></tr>
<tr class="memdesc:ga7c675e2c6b20599160bfb0046cfee109"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function is used to release an IPC channel from the locked state.  <a href="#ga7c675e2c6b20599160bfb0046cfee109">More...</a><br /></td></tr>
<tr class="separator:ga7c675e2c6b20599160bfb0046cfee109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed2f8f6a0343bdeedbe4f81c0df5e1a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga1ed2f8f6a0343bdeedbe4f81c0df5e1a">Cy_IPC_Drv_IsLockAcquired</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:ga1ed2f8f6a0343bdeedbe4f81c0df5e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function is used to test the status of an IPC channel.  <a href="#ga1ed2f8f6a0343bdeedbe4f81c0df5e1a">More...</a><br /></td></tr>
<tr class="separator:ga1ed2f8f6a0343bdeedbe4f81c0df5e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa178a606ff01af93d7545c7e3a25c648"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#gaa178a606ff01af93d7545c7e3a25c648">Cy_IPC_Drv_GetLockStatus</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *base)</td></tr>
<tr class="memdesc:gaa178a606ff01af93d7545c7e3a25c648"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function is used to get the status of an IPC channel.  <a href="#gaa178a606ff01af93d7545c7e3a25c648">More...</a><br /></td></tr>
<tr class="separator:gaa178a606ff01af93d7545c7e3a25c648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f75f0403a88420eb1268f54b21ed27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga60f75f0403a88420eb1268f54b21ed27">Cy_IPC_Drv_SendMsgWord</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *base, uint32_t notifyEventIntr, uint32_t message)</td></tr>
<tr class="memdesc:ga60f75f0403a88420eb1268f54b21ed27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send a 32-bit word message through an IPC channel.  <a href="#ga60f75f0403a88420eb1268f54b21ed27">More...</a><br /></td></tr>
<tr class="separator:ga60f75f0403a88420eb1268f54b21ed27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7235959bc77bc9d71f6660e315741a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#gadf7235959bc77bc9d71f6660e315741a">Cy_IPC_Drv_ReadMsgWord</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *base, uint32_t *message)</td></tr>
<tr class="memdesc:gadf7235959bc77bc9d71f6660e315741a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read a 32-bit word message through an IPC channel.  <a href="#gadf7235959bc77bc9d71f6660e315741a">More...</a><br /></td></tr>
<tr class="separator:gadf7235959bc77bc9d71f6660e315741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e1b6079cd81d9b918b354d9437744d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#gab9e1b6079cd81d9b918b354d9437744d">Cy_IPC_Drv_SendMsgPtr</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *base, uint32_t notifyEventIntr, void const *msgPtr)</td></tr>
<tr class="memdesc:gab9e1b6079cd81d9b918b354d9437744d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send a message pointer through an IPC channel.  <a href="#gab9e1b6079cd81d9b918b354d9437744d">More...</a><br /></td></tr>
<tr class="separator:gab9e1b6079cd81d9b918b354d9437744d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2641f60d4f3147aaea537d4c66d2b3a1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga2641f60d4f3147aaea537d4c66d2b3a1">Cy_IPC_Drv_ReadMsgPtr</a> (<a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *base, void **msgPtr)</td></tr>
<tr class="memdesc:ga2641f60d4f3147aaea537d4c66d2b3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read a 32-bit pointer message through an IPC channel.  <a href="#ga2641f60d4f3147aaea537d4c66d2b3a1">More...</a><br /></td></tr>
<tr class="separator:ga2641f60d4f3147aaea537d4c66d2b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e910b181ed0ef66a0fa9a2cc9afa105"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a> (IPC_INTR_STRUCT_Type *base, uint32_t ipcReleaseMask, uint32_t ipcAcquireMask)</td></tr>
<tr class="memdesc:ga6e910b181ed0ef66a0fa9a2cc9afa105"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set the interrupt mask for an IPC Interrupt.  <a href="#ga6e910b181ed0ef66a0fa9a2cc9afa105">More...</a><br /></td></tr>
<tr class="separator:ga6e910b181ed0ef66a0fa9a2cc9afa105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a79aaa6be9b9d40fe8c8ff17fce058b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga0a79aaa6be9b9d40fe8c8ff17fce058b">Cy_IPC_Drv_GetInterruptMask</a> (IPC_INTR_STRUCT_Type const *base)</td></tr>
<tr class="memdesc:ga0a79aaa6be9b9d40fe8c8ff17fce058b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the interrupt mask.  <a href="#ga0a79aaa6be9b9d40fe8c8ff17fce058b">More...</a><br /></td></tr>
<tr class="separator:ga0a79aaa6be9b9d40fe8c8ff17fce058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423a1a0df8939384794e95f7e05b1e03"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga423a1a0df8939384794e95f7e05b1e03">Cy_IPC_Drv_GetInterruptStatusMasked</a> (IPC_INTR_STRUCT_Type const *base)</td></tr>
<tr class="memdesc:ga423a1a0df8939384794e95f7e05b1e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the active unmasked interrupt.  <a href="#ga423a1a0df8939384794e95f7e05b1e03">More...</a><br /></td></tr>
<tr class="separator:ga423a1a0df8939384794e95f7e05b1e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0caa401ab6f35b70e99768a0c442c71a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga0caa401ab6f35b70e99768a0c442c71a">Cy_IPC_Drv_GetInterruptStatus</a> (IPC_INTR_STRUCT_Type const *base)</td></tr>
<tr class="memdesc:ga0caa401ab6f35b70e99768a0c442c71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the pending interrupts.  <a href="#ga0caa401ab6f35b70e99768a0c442c71a">More...</a><br /></td></tr>
<tr class="separator:ga0caa401ab6f35b70e99768a0c442c71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4223d653355f0cd7890b57ab1e8d1ff6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#ga4223d653355f0cd7890b57ab1e8d1ff6">Cy_IPC_Drv_SetInterrupt</a> (IPC_INTR_STRUCT_Type *base, uint32_t ipcReleaseMask, uint32_t ipcAcquireMask)</td></tr>
<tr class="memdesc:ga4223d653355f0cd7890b57ab1e8d1ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set the interrupt source.  <a href="#ga4223d653355f0cd7890b57ab1e8d1ff6">More...</a><br /></td></tr>
<tr class="separator:ga4223d653355f0cd7890b57ab1e8d1ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3dbb5de3a3b0336daa2758e72dded45"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__functions.html#gaa3dbb5de3a3b0336daa2758e72dded45">Cy_IPC_Drv_ClearInterrupt</a> (IPC_INTR_STRUCT_Type *base, uint32_t ipcReleaseMask, uint32_t ipcAcquireMask)</td></tr>
<tr class="memdesc:gaa3dbb5de3a3b0336daa2758e72dded45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to clear the interrupt source.  <a href="#gaa3dbb5de3a3b0336daa2758e72dded45">More...</a><br /></td></tr>
<tr class="separator:gaa3dbb5de3a3b0336daa2758e72dded45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa1ca9b002b286f12fde442c8653aa3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1ca9b002b286f12fde442c8653aa3bf">&#9670;&nbsp;</a></span>Cy_IPC_Drv_GetIpcBaseAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * Cy_IPC_Drv_GetIpcBaseAddress </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ipcIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes an IPC channel index as a parameter and returns the base address the IPC registers corresponding to the IPC channel. </p>
<dl class="section note"><dt>Note</dt><dd>The user is responsible for ensuring that ipcIndex does not exceed the limits.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcIndex</td><td>Represents the number of IPC structure. This is converted to the base address of the IPC channel registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the base of the IPC registers.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to send a &quot;one word&quot; (32-bit) message,</span></div><div class="line"><span class="comment">     * which can be also used as any command/flag/etc.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line">    uint32_t myMsg = 0x12345678UL;        <span class="comment">/* Example message */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> != <a class="code" href="group__group__ipc__functions.html#ga60f75f0403a88420eb1268f54b21ed27">Cy_IPC_Drv_SendMsgWord</a>(myIpc, MY_IPC_INTR_MASK, myMsg))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaea293f27dc3d6d69eb40ef2d8f5c8d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">&#9670;&nbsp;</a></span>Cy_IPC_Drv_GetIntrBaseAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE IPC_INTR_STRUCT_Type * Cy_IPC_Drv_GetIntrBaseAddr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ipcIntrIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes an IPC interrupt structure index and returns the base address of the IPC interrupt registers corresponding to the IPC Interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>The user is responsible for ensuring that ipcIntrIndex does not exceed the limits.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcIntrIndex</td><td>Represents the number of IPC interrupt structure. This is converted to the base address of the IPC interrupt registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the base of the IPC interrupt registers.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to check the IPC pending interrupts */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line">    IPC_INTR_STRUCT_Type * myIpcIntr = <a class="code" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>(MY_IPC_INTR_INDEX);</div><div class="line"></div><div class="line">    uint32_t intrStatus = <a class="code" href="group__group__ipc__functions.html#ga0caa401ab6f35b70e99768a0c442c71a">Cy_IPC_Drv_GetInterruptStatus</a>(myIpcIntr);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga47dfdecf96bad000b825ae79bfea0f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47dfdecf96bad000b825ae79bfea0f80">&#9670;&nbsp;</a></span>Cy_IPC_Drv_AcquireNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_IPC_Drv_AcquireNotify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>notifyEventIntr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function generates a acquire notification event by IPC interrupt structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
    <tr><td class="paramname">notifyEventIntr</td><td>Bit encoded list of IPC interrupt structures that are triggered by a notification. Bit number correspond to number of the IPC interrupt structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to acquire the IPC channel so that other CPU</span></div><div class="line"><span class="comment">     * cores are blocked to use it. Prior to acquiring, check if it is not already</span></div><div class="line"><span class="comment">     * acquired by another CPU core.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group__group__ipc__functions.html#ga1ed2f8f6a0343bdeedbe4f81c0df5e1a">Cy_IPC_Drv_IsLockAcquired</a>(myIpc))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#ga8691465b9797f0b764505e9c77d41b02">Cy_IPC_Drv_LockAcquire</a>(myIpc))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Scenario: there is a need to manually trigger the IPC notification</span></div><div class="line"><span class="comment">             * interrupt without specifying the data to be passed.</span></div><div class="line"><span class="comment">             * It can essentially be used as a 1-bit semaphore.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <a class="code" href="group__group__ipc__functions.html#ga47dfdecf96bad000b825ae79bfea0f80">Cy_IPC_Drv_AcquireNotify</a>(myIpc, MY_IPC_INTR_MASK);</div><div class="line">            <span class="comment">/* Another core is expected to own the interrupt generated in the</span></div><div class="line"><span class="comment">             * IPC interrupt channel #MY_IPC_INTR_INDEX</span></div><div class="line"><span class="comment">             */</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Insert error handling */</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gae012b59909da4867ac1112f69f9dd3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae012b59909da4867ac1112f69f9dd3a1">&#9670;&nbsp;</a></span>Cy_IPC_Drv_ReleaseNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_IPC_Drv_ReleaseNotify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>notifyEventIntr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function generates a release notification event by IPC interrupt structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
    <tr><td class="paramname">notifyEventIntr</td><td>Bit encoded list of IPC interrupt lines that are triggered by a notification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: a notification interrupt has just occurred so</span></div><div class="line"><span class="comment">     * there is a need to receive a &quot;one word&quot; (32-bit) message</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line">    uint32_t myMsg; <span class="comment">/* Example message */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#gadf7235959bc77bc9d71f6660e315741a">Cy_IPC_Drv_ReadMsgWord</a>(myIpc, &amp;myMsg))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Now myMsg contains the received message word */</span></div><div class="line"></div><div class="line">        <span class="comment">/* The IPC data is received and processed.</span></div><div class="line"><span class="comment">         * Free up the channel for the next transaction.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <a class="code" href="group__group__ipc__functions.html#gae012b59909da4867ac1112f69f9dd3a1">Cy_IPC_Drv_ReleaseNotify</a>(myIpc, MY_IPC_INTR_MASK);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga8691465b9797f0b764505e9c77d41b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8691465b9797f0b764505e9c77d41b02">&#9670;&nbsp;</a></span>Cy_IPC_Drv_LockAcquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a> Cy_IPC_Drv_LockAcquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to acquire the IPC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CY_IPC_DRV_SUCCESS</td><td>The IPC was successfully acquired </td></tr>
    <tr><td class="paramname">CY_IPC_DRV_ERROR</td><td>The IPC was not acquired because it was already acquired by another master</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to acquire the IPC channel so that other CPU</span></div><div class="line"><span class="comment">     * cores are blocked to use it. Prior to acquiring, check if it is not already</span></div><div class="line"><span class="comment">     * acquired by another CPU core.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group__group__ipc__functions.html#ga1ed2f8f6a0343bdeedbe4f81c0df5e1a">Cy_IPC_Drv_IsLockAcquired</a>(myIpc))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#ga8691465b9797f0b764505e9c77d41b02">Cy_IPC_Drv_LockAcquire</a>(myIpc))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Scenario: there is a need to manually trigger the IPC notification</span></div><div class="line"><span class="comment">             * interrupt without specifying the data to be passed.</span></div><div class="line"><span class="comment">             * It can essentially be used as a 1-bit semaphore.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <a class="code" href="group__group__ipc__functions.html#ga47dfdecf96bad000b825ae79bfea0f80">Cy_IPC_Drv_AcquireNotify</a>(myIpc, MY_IPC_INTR_MASK);</div><div class="line">            <span class="comment">/* Another core is expected to own the interrupt generated in the</span></div><div class="line"><span class="comment">             * IPC interrupt channel #MY_IPC_INTR_INDEX</span></div><div class="line"><span class="comment">             */</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Insert error handling */</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7c675e2c6b20599160bfb0046cfee109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c675e2c6b20599160bfb0046cfee109">&#9670;&nbsp;</a></span>Cy_IPC_Drv_LockRelease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a> Cy_IPC_Drv_LockRelease </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>releaseEventIntr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function is used to release an IPC channel from the locked state. </p>
<p>The function also has a way to specify through a parameter which IPC interrupts must be notified during the release event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
    <tr><td class="paramname">releaseEventIntr</td><td>Bit encoded list of IPC interrupt lines that are triggered by a release event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CY_IPC_DRV_SUCCESS</td><td>The function executed successfully and the IPC channel was released. </td></tr>
    <tr><td class="paramname">CY_IPC_DRV_ERROR</td><td>The IPC channel was not acquired before the function call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: an acquire notification interrupt has just occurred</span></div><div class="line"><span class="comment">     * so now is a time to read a message pointer and then whole the</span></div><div class="line"><span class="comment">     * message content</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC interrupt mask */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_MSG_SIZE         (7UL) </span><span class="comment">/* Example message size */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line">    uint32_t myMsg[MY_IPC_MSG_SIZE];       <span class="comment">/* Example message container */</span></div><div class="line">    <span class="keywordtype">void</span> * myMsgPtr;                       <span class="comment">/* Example message pointer */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#ga2641f60d4f3147aaea537d4c66d2b3a1">Cy_IPC_Drv_ReadMsgPtr</a>(myIpc, &amp;myMsgPtr))</div><div class="line">    {</div><div class="line">        uint32_t i;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(i = 0; i &lt; MY_IPC_MSG_SIZE; i++)</div><div class="line">        {</div><div class="line">            myMsg[i] = *((uint32_t*)((uint32_t)myMsgPtr + i)); <span class="comment">/* Copying the message content */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* The IPC data was received and processed.</span></div><div class="line"><span class="comment">     * Free up the channel for the next transaction.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#ga7c675e2c6b20599160bfb0046cfee109">Cy_IPC_Drv_LockRelease</a>(myIpc, MY_IPC_INTR_MASK))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Now the IPC channel is successfully released */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga1ed2f8f6a0343bdeedbe4f81c0df5e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed2f8f6a0343bdeedbe4f81c0df5e1a">&#9670;&nbsp;</a></span>Cy_IPC_Drv_IsLockAcquired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_IPC_Drv_IsLockAcquired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function is used to test the status of an IPC channel. </p>
<p>The function tells the reader if the IPC channel was in the locked or released state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status for the function: true: The IPC channel is in the Locked state. false: The IPC channel is in the Released state.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to acquire the IPC channel so that other CPU</span></div><div class="line"><span class="comment">     * cores are blocked to use it. Prior to acquiring, check if it is not already</span></div><div class="line"><span class="comment">     * acquired by another CPU core.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group__group__ipc__functions.html#ga1ed2f8f6a0343bdeedbe4f81c0df5e1a">Cy_IPC_Drv_IsLockAcquired</a>(myIpc))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#ga8691465b9797f0b764505e9c77d41b02">Cy_IPC_Drv_LockAcquire</a>(myIpc))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Scenario: there is a need to manually trigger the IPC notification</span></div><div class="line"><span class="comment">             * interrupt without specifying the data to be passed.</span></div><div class="line"><span class="comment">             * It can essentially be used as a 1-bit semaphore.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <a class="code" href="group__group__ipc__functions.html#ga47dfdecf96bad000b825ae79bfea0f80">Cy_IPC_Drv_AcquireNotify</a>(myIpc, MY_IPC_INTR_MASK);</div><div class="line">            <span class="comment">/* Another core is expected to own the interrupt generated in the</span></div><div class="line"><span class="comment">             * IPC interrupt channel #MY_IPC_INTR_INDEX</span></div><div class="line"><span class="comment">             */</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Insert error handling */</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaa178a606ff01af93d7545c7e3a25c648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa178a606ff01af93d7545c7e3a25c648">&#9670;&nbsp;</a></span>Cy_IPC_Drv_GetLockStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_IPC_Drv_GetLockStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function is used to get the status of an IPC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value from LOCK_STATUS register.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to check the IPC channel status */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line"></div><div class="line">    uint32_t ipcStatus = <a class="code" href="group__group__ipc__functions.html#gaa178a606ff01af93d7545c7e3a25c648">Cy_IPC_Drv_GetLockStatus</a>(myIpc);</div><div class="line">    <span class="comment">/* Now the ipcStatus contains all the LOCK_STATUS register content,</span></div><div class="line"><span class="comment">     * such a user/privileged, secure/non-secure access modes,</span></div><div class="line"><span class="comment">     * protection context, bus master, etc.</span></div><div class="line"><span class="comment">     */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga60f75f0403a88420eb1268f54b21ed27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60f75f0403a88420eb1268f54b21ed27">&#9670;&nbsp;</a></span>Cy_IPC_Drv_SendMsgWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a> Cy_IPC_Drv_SendMsgWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>notifyEventIntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to send a 32-bit word message through an IPC channel. </p>
<p>The function also has an associated notification field that will let the message notify one or multiple IPC interrupts. The IPC channel is locked and remains locked after the function returns. The receiver of the message should release the channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
    <tr><td class="paramname">notifyEventIntr</td><td>Bit encoded list of IPC interrupt lines that are triggered by a notification.</td></tr>
    <tr><td class="paramname">message</td><td>The message word that is the data placed in the IPC data register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation: </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CY_IPC_DRV_SUCCESS</td><td>The send operation was successful. </td></tr>
    <tr><td class="paramname">CY_IPC_DRV_ERROR</td><td>The IPC channel is unavailable because it is already locked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to send a &quot;one word&quot; (32-bit) message,</span></div><div class="line"><span class="comment">     * which can be also used as any command/flag/etc.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line">    uint32_t myMsg = 0x12345678UL;        <span class="comment">/* Example message */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> != <a class="code" href="group__group__ipc__functions.html#ga60f75f0403a88420eb1268f54b21ed27">Cy_IPC_Drv_SendMsgWord</a>(myIpc, MY_IPC_INTR_MASK, myMsg))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gadf7235959bc77bc9d71f6660e315741a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf7235959bc77bc9d71f6660e315741a">&#9670;&nbsp;</a></span>Cy_IPC_Drv_ReadMsgWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a> Cy_IPC_Drv_ReadMsgWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read a 32-bit word message through an IPC channel. </p>
<p>This function assumes that the channel is locked (for a valid message). If the channel is not locked, the message is invalid. The user must call Cy_IPC_Drv_Release() function after reading the message to release the IPC channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
    <tr><td class="paramname">message</td><td>A variable where the read data is copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CY_IPC_DRV_SUCCESS</td><td>The function executed successfully and the IPC was acquired. </td></tr>
    <tr><td class="paramname">CY_IPC_DRV_ERROR</td><td>The function encountered an error because the IPC channel was already in a released state, meaning the data may be invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: a notification interrupt has just occurred so</span></div><div class="line"><span class="comment">     * there is a need to receive a &quot;one word&quot; (32-bit) message</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line">    uint32_t myMsg; <span class="comment">/* Example message */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#gadf7235959bc77bc9d71f6660e315741a">Cy_IPC_Drv_ReadMsgWord</a>(myIpc, &amp;myMsg))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Now myMsg contains the received message word */</span></div><div class="line"></div><div class="line">        <span class="comment">/* The IPC data is received and processed.</span></div><div class="line"><span class="comment">         * Free up the channel for the next transaction.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <a class="code" href="group__group__ipc__functions.html#gae012b59909da4867ac1112f69f9dd3a1">Cy_IPC_Drv_ReleaseNotify</a>(myIpc, MY_IPC_INTR_MASK);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gab9e1b6079cd81d9b918b354d9437744d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e1b6079cd81d9b918b354d9437744d">&#9670;&nbsp;</a></span>Cy_IPC_Drv_SendMsgPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a> Cy_IPC_Drv_SendMsgPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>notifyEventIntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>msgPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to send a message pointer through an IPC channel. </p>
<p>The message structure may hold a generic pointer that may contain the address of any user data type or structure. This parameter could be a pointer to a 32-bit integer, an array, or even a data structure defined in the user code. This function acts as a transfer engine for sending the pointer. Any memory management of the pointer allocation and deallocation is up to the application code. The function also has an associated notification field that will let the message notify one or multiple interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
    <tr><td class="paramname">notifyEventIntr</td><td>Bit encoded list of IPC interrupt lines that are triggered during the release action.</td></tr>
    <tr><td class="paramname">msgPtr</td><td>The message pointer that is being sent over the IPC channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation: </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CY_IPC_DRV_SUCCESS</td><td>The send operation was successful. </td></tr>
    <tr><td class="paramname">CY_IPC_DRV_ERROR</td><td>The IPC channel is unavailable because it is already locked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to send a pointer of the message mailbox */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC interrupt mask */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_MSG_SIZE         (7UL) </span><span class="comment">/* Example message size */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line">    uint32_t myMsg[MY_IPC_MSG_SIZE] = {1,2,3,4,5,6,7}; <span class="comment">/* Example message, the content is fully user-defined */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> != <a class="code" href="group__group__ipc__functions.html#gab9e1b6079cd81d9b918b354d9437744d">Cy_IPC_Drv_SendMsgPtr</a>(myIpc, MY_IPC_INTR_MASK, (<span class="keywordtype">void</span> *) myMsg))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2641f60d4f3147aaea537d4c66d2b3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2641f60d4f3147aaea537d4c66d2b3a1">&#9670;&nbsp;</a></span>Cy_IPC_Drv_ReadMsgPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__ipc__enums.html#gab838549fe808bd6cb1bfc52d2b5cbf25">cy_en_ipcdrv_status_t</a> Cy_IPC_Drv_ReadMsgPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>msgPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read a 32-bit pointer message through an IPC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This parameter is a handle that represents the base address of the registers of the IPC channel. The parameter is generally returned from a call to the <a class="el" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>.</td></tr>
    <tr><td class="paramname">msgPtr</td><td>Pointer variable to hold the data pointer that is being read from the IPC channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CY_IPC_DRV_SUCCESS</td><td>The function executed successfully and the IPC was acquired. </td></tr>
    <tr><td class="paramname">CY_IPC_DRV_ERROR</td><td>The function encountered an error because the IPC channel was already in a released state meaning the data in it is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: an acquire notification interrupt has just occurred</span></div><div class="line"><span class="comment">     * so now is a time to read a message pointer and then whole the</span></div><div class="line"><span class="comment">     * message content</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX       (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX       (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_MASK        (1UL &lt;&lt; MY_IPC_INTR_INDEX) </span><span class="comment">/* IPC interrupt mask */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_MSG_SIZE         (7UL) </span><span class="comment">/* Example message size */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <a class="code" href="struct_i_p_c___s_t_r_u_c_t___type.html">IPC_STRUCT_Type</a> * myIpc = <a class="code" href="group__group__ipc__functions.html#gaa1ca9b002b286f12fde442c8653aa3bf">Cy_IPC_Drv_GetIpcBaseAddress</a>(MY_IPC_CHAN_INDEX); <span class="comment">/* Get IPC base register address */</span></div><div class="line">    uint32_t myMsg[MY_IPC_MSG_SIZE];       <span class="comment">/* Example message container */</span></div><div class="line">    <span class="keywordtype">void</span> * myMsgPtr;                       <span class="comment">/* Example message pointer */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#ga2641f60d4f3147aaea537d4c66d2b3a1">Cy_IPC_Drv_ReadMsgPtr</a>(myIpc, &amp;myMsgPtr))</div><div class="line">    {</div><div class="line">        uint32_t i;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(i = 0; i &lt; MY_IPC_MSG_SIZE; i++)</div><div class="line">        {</div><div class="line">            myMsg[i] = *((uint32_t*)((uint32_t)myMsgPtr + i)); <span class="comment">/* Copying the message content */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* The IPC data was received and processed.</span></div><div class="line"><span class="comment">     * Free up the channel for the next transaction.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__ipc__enums.html#ggab838549fe808bd6cb1bfc52d2b5cbf25a8748b3bf3a2b39bd469c0d41217a2cb2">CY_IPC_DRV_SUCCESS</a> == <a class="code" href="group__group__ipc__functions.html#ga7c675e2c6b20599160bfb0046cfee109">Cy_IPC_Drv_LockRelease</a>(myIpc, MY_IPC_INTR_MASK))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Now the IPC channel is successfully released */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga6e910b181ed0ef66a0fa9a2cc9afa105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e910b181ed0ef66a0fa9a2cc9afa105">&#9670;&nbsp;</a></span>Cy_IPC_Drv_SetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_IPC_Drv_SetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">IPC_INTR_STRUCT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ipcReleaseMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ipcAcquireMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set the interrupt mask for an IPC Interrupt. </p>
<p>The mask sets release or acquire notification events for all IPC channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This is a handle to the IPC interrupt. This handle can be calculated from the IPC interrupt number using <a class="el" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>.</td></tr>
    <tr><td class="paramname">ipcReleaseMask</td><td>An encoded list of all IPC channels that can trigger the interrupt on a release event.</td></tr>
    <tr><td class="paramname">ipcAcquireMask</td><td>An encoded list of all IPC channels that can trigger the interrupt on a notify event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: enable IPC interrupts in IPC interrupt channel #MY_IPC_INTR_INDEX</span></div><div class="line"><span class="comment">     * for both acquire and release events from the IPC channel #MY_IPC_CHAN_INDEX</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX        (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX        (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_RELEASE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_ACQUIRE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC acquire interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    IPC_INTR_STRUCT_Type * myIpcIntr = <a class="code" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>(MY_IPC_INTR_INDEX);</div><div class="line"></div><div class="line">    uint32_t intr = <a class="code" href="group__group__ipc__functions.html#ga0a79aaa6be9b9d40fe8c8ff17fce058b">Cy_IPC_Drv_GetInterruptMask</a>(myIpcIntr);</div><div class="line">    uint32_t releaseIntr = _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intr) | MY_IPC_RELEASE_INTR_MASK;</div><div class="line">    uint32_t acqiureIntr = _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intr) | MY_IPC_ACQUIRE_INTR_MASK;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a>(myIpcIntr, releaseIntr, acqiureIntr);</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: the next block is inside the IPC interrupt handler */</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Get all the enabled pending interrupts */</span></div><div class="line">        uint32_t intr = <a class="code" href="group__group__ipc__functions.html#ga423a1a0df8939384794e95f7e05b1e03">Cy_IPC_Drv_GetInterruptStatusMasked</a>(myIpcIntr);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (0UL != (MY_IPC_RELEASE_INTR_MASK &amp; intr))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle the RELEASE event of the IPC channel MY_IPC_CHAN_INDEX */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (0UL != (MY_IPC_ACQUIRE_INTR_MASK &amp; intr))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle the ACQUIRE interrupt */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clear the interrupt */</span></div><div class="line">        <a class="code" href="group__group__ipc__functions.html#gaa3dbb5de3a3b0336daa2758e72dded45">Cy_IPC_Drv_ClearInterrupt</a>(myIpcIntr, _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intr),</div><div class="line">                                             _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intr));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: disable ALL the IPC interrupts (not from the IPC channel</span></div><div class="line"><span class="comment">     * #MY_IPC_CHAN_INDEX only) in the IPC interrupt channel</span></div><div class="line"><span class="comment">     * #MY_IPC_INTR_INDEX when they are not needed anymore</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a>(myIpcIntr, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga0a79aaa6be9b9d40fe8c8ff17fce058b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a79aaa6be9b9d40fe8c8ff17fce058b">&#9670;&nbsp;</a></span>Cy_IPC_Drv_GetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_IPC_Drv_GetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">IPC_INTR_STRUCT_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the interrupt mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This is a handle to the IPC interrupt. This handle can be calculated from the IPC interrupt number using <a class="el" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is encoded as follows <table class="doxtable">
<tr>
<th>Interrupt sources </th><th>Value </th></tr>
<tr>
<td>Ipc_PORTX_RELEASE </td><td>Xth bit set </td></tr>
<tr>
<td>Ipc_PORTX_NOTIFY </td><td>X+16th bit set </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: enable IPC interrupts in IPC interrupt channel #MY_IPC_INTR_INDEX</span></div><div class="line"><span class="comment">     * for both acquire and release events from the IPC channel #MY_IPC_CHAN_INDEX</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX        (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX        (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_RELEASE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_ACQUIRE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC acquire interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    IPC_INTR_STRUCT_Type * myIpcIntr = <a class="code" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>(MY_IPC_INTR_INDEX);</div><div class="line"></div><div class="line">    uint32_t intr = <a class="code" href="group__group__ipc__functions.html#ga0a79aaa6be9b9d40fe8c8ff17fce058b">Cy_IPC_Drv_GetInterruptMask</a>(myIpcIntr);</div><div class="line">    uint32_t releaseIntr = _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intr) | MY_IPC_RELEASE_INTR_MASK;</div><div class="line">    uint32_t acqiureIntr = _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intr) | MY_IPC_ACQUIRE_INTR_MASK;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a>(myIpcIntr, releaseIntr, acqiureIntr);</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: the next block is inside the IPC interrupt handler */</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Get all the enabled pending interrupts */</span></div><div class="line">        uint32_t intr = <a class="code" href="group__group__ipc__functions.html#ga423a1a0df8939384794e95f7e05b1e03">Cy_IPC_Drv_GetInterruptStatusMasked</a>(myIpcIntr);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (0UL != (MY_IPC_RELEASE_INTR_MASK &amp; intr))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle the RELEASE event of the IPC channel MY_IPC_CHAN_INDEX */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (0UL != (MY_IPC_ACQUIRE_INTR_MASK &amp; intr))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle the ACQUIRE interrupt */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clear the interrupt */</span></div><div class="line">        <a class="code" href="group__group__ipc__functions.html#gaa3dbb5de3a3b0336daa2758e72dded45">Cy_IPC_Drv_ClearInterrupt</a>(myIpcIntr, _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intr),</div><div class="line">                                             _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intr));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: disable ALL the IPC interrupts (not from the IPC channel</span></div><div class="line"><span class="comment">     * #MY_IPC_CHAN_INDEX only) in the IPC interrupt channel</span></div><div class="line"><span class="comment">     * #MY_IPC_INTR_INDEX when they are not needed anymore</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a>(myIpcIntr, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga423a1a0df8939384794e95f7e05b1e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga423a1a0df8939384794e95f7e05b1e03">&#9670;&nbsp;</a></span>Cy_IPC_Drv_GetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_IPC_Drv_GetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">IPC_INTR_STRUCT_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the active unmasked interrupt. </p>
<p>This function can be used in the interrupt service routine to find which source triggered the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This is a handle to the IPC interrupt. This handle can be calculated from the IPC interrupt number using <a class="el" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is encoded as follows <table class="doxtable">
<tr>
<th>Interrupt sources </th><th>Value </th></tr>
<tr>
<td>Ipc_PORTX_RELEASE </td><td>Xth bit set </td></tr>
<tr>
<td>Ipc_PORTX_NOTIFY </td><td>X+16th bit set </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: enable IPC interrupts in IPC interrupt channel #MY_IPC_INTR_INDEX</span></div><div class="line"><span class="comment">     * for both acquire and release events from the IPC channel #MY_IPC_CHAN_INDEX</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX        (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX        (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_RELEASE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_ACQUIRE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC acquire interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    IPC_INTR_STRUCT_Type * myIpcIntr = <a class="code" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>(MY_IPC_INTR_INDEX);</div><div class="line"></div><div class="line">    uint32_t intr = <a class="code" href="group__group__ipc__functions.html#ga0a79aaa6be9b9d40fe8c8ff17fce058b">Cy_IPC_Drv_GetInterruptMask</a>(myIpcIntr);</div><div class="line">    uint32_t releaseIntr = _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intr) | MY_IPC_RELEASE_INTR_MASK;</div><div class="line">    uint32_t acqiureIntr = _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intr) | MY_IPC_ACQUIRE_INTR_MASK;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a>(myIpcIntr, releaseIntr, acqiureIntr);</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: the next block is inside the IPC interrupt handler */</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Get all the enabled pending interrupts */</span></div><div class="line">        uint32_t intr = <a class="code" href="group__group__ipc__functions.html#ga423a1a0df8939384794e95f7e05b1e03">Cy_IPC_Drv_GetInterruptStatusMasked</a>(myIpcIntr);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (0UL != (MY_IPC_RELEASE_INTR_MASK &amp; intr))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle the RELEASE event of the IPC channel MY_IPC_CHAN_INDEX */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (0UL != (MY_IPC_ACQUIRE_INTR_MASK &amp; intr))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle the ACQUIRE interrupt */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clear the interrupt */</span></div><div class="line">        <a class="code" href="group__group__ipc__functions.html#gaa3dbb5de3a3b0336daa2758e72dded45">Cy_IPC_Drv_ClearInterrupt</a>(myIpcIntr, _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intr),</div><div class="line">                                             _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intr));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: disable ALL the IPC interrupts (not from the IPC channel</span></div><div class="line"><span class="comment">     * #MY_IPC_CHAN_INDEX only) in the IPC interrupt channel</span></div><div class="line"><span class="comment">     * #MY_IPC_INTR_INDEX when they are not needed anymore</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a>(myIpcIntr, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga0caa401ab6f35b70e99768a0c442c71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0caa401ab6f35b70e99768a0c442c71a">&#9670;&nbsp;</a></span>Cy_IPC_Drv_GetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_IPC_Drv_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">IPC_INTR_STRUCT_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the pending interrupts. </p>
<p>Note that this read is an unmasked read of the interrupt status. Interrupt sources read as active by this function would generate interrupts only if they were not masked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This is a handle to the IPC interrupt. This handle can be calculated from the IPC interrupt number using <a class="el" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is encoded as follows <table class="doxtable">
<tr>
<th>Interrupt sources </th><th>Value </th></tr>
<tr>
<td>Ipc_PORTX_RELEASE </td><td>Xth bit set </td></tr>
<tr>
<td>Ipc_PORTX_NOTIFY </td><td>X+16th bit set </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to check the IPC pending interrupts */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line">    IPC_INTR_STRUCT_Type * myIpcIntr = <a class="code" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>(MY_IPC_INTR_INDEX);</div><div class="line"></div><div class="line">    uint32_t intrStatus = <a class="code" href="group__group__ipc__functions.html#ga0caa401ab6f35b70e99768a0c442c71a">Cy_IPC_Drv_GetInterruptStatus</a>(myIpcIntr);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga4223d653355f0cd7890b57ab1e8d1ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4223d653355f0cd7890b57ab1e8d1ff6">&#9670;&nbsp;</a></span>Cy_IPC_Drv_SetInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_IPC_Drv_SetInterrupt </td>
          <td>(</td>
          <td class="paramtype">IPC_INTR_STRUCT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ipcReleaseMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ipcAcquireMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set the interrupt source. </p>
<p>This function can be used to activate interrupts through software. </p><dl class="section note"><dt>Note</dt><dd>That interrupt sources set using this interrupt would generate interrupts only if they are not masked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This is a handle to the IPC interrupt. This handle can be calculated from the IPC interrupt number using <a class="el" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>.</td></tr>
    <tr><td class="paramname">ipcReleaseMask</td><td>An encoded list of all IPC channels that can trigger the interrupt on a release event.</td></tr>
    <tr><td class="paramname">ipcAcquireMask</td><td>An encoded list of all IPC channels that can trigger the interrupt on a notify event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to set the acquire of the IPC channel</span></div><div class="line"><span class="comment">     * #MY_IPC_CHAN_INDEX interrupt for the IPC interrupt channel</span></div><div class="line"><span class="comment">     * #MY_IPC_INTR_INDEX by software.</span></div><div class="line"><span class="comment">     * Prior to trigging the interrupt, ensure that the correspondent interrupt</span></div><div class="line"><span class="comment">     * mask is set in the IPC interrupt channel #MY_IPC_INTR_INDEX</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX        (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX        (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_ACQUIRE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC acquire interrupt mask example */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    IPC_INTR_STRUCT_Type * myIpcIntr = <a class="code" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>(MY_IPC_INTR_INDEX);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (0UL != (MY_IPC_ACQUIRE_INTR_MASK &amp; _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, <a class="code" href="group__group__ipc__functions.html#ga0a79aaa6be9b9d40fe8c8ff17fce058b">Cy_IPC_Drv_GetInterruptMask</a>(myIpcIntr))))</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__ipc__functions.html#ga4223d653355f0cd7890b57ab1e8d1ff6">Cy_IPC_Drv_SetInterrupt</a>(myIpcIntr, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>, MY_IPC_ACQUIRE_INTR_MASK);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* See the \ref Cy_IPC_Drv_SetInterruptMask function usage */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaa3dbb5de3a3b0336daa2758e72dded45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3dbb5de3a3b0336daa2758e72dded45">&#9670;&nbsp;</a></span>Cy_IPC_Drv_ClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_IPC_Drv_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype">IPC_INTR_STRUCT_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ipcReleaseMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ipcAcquireMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to clear the interrupt source. </p>
<p>Use this function to clear a pending interrupt source in the interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>This is a handle to the IPC interrupt. This handle can be calculated from the IPC interrupt number using <a class="el" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>.</td></tr>
    <tr><td class="paramname">ipcReleaseMask</td><td>An encoded list of all IPC channels that can trigger the interrupt on a release event.</td></tr>
    <tr><td class="paramname">ipcAcquireMask</td><td>An encoded list of all IPC channels that can trigger the interrupt on a notify event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: enable IPC interrupts in IPC interrupt channel #MY_IPC_INTR_INDEX</span></div><div class="line"><span class="comment">     * for both acquire and release events from the IPC channel #MY_IPC_CHAN_INDEX</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CHAN_INDEX        (8UL) </span><span class="comment">/* Example of IPC channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_INTR_INDEX        (8UL) </span><span class="comment">/* Example of IPC interrupt channel index */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_RELEASE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC release interrupt mask */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_ACQUIRE_INTR_MASK (1UL &lt;&lt; MY_IPC_CHAN_INDEX) </span><span class="comment">/* IPC acquire interrupt mask */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    IPC_INTR_STRUCT_Type * myIpcIntr = <a class="code" href="group__group__ipc__functions.html#gaea293f27dc3d6d69eb40ef2d8f5c8d2b">Cy_IPC_Drv_GetIntrBaseAddr</a>(MY_IPC_INTR_INDEX);</div><div class="line"></div><div class="line">    uint32_t intr = <a class="code" href="group__group__ipc__functions.html#ga0a79aaa6be9b9d40fe8c8ff17fce058b">Cy_IPC_Drv_GetInterruptMask</a>(myIpcIntr);</div><div class="line">    uint32_t releaseIntr = _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intr) | MY_IPC_RELEASE_INTR_MASK;</div><div class="line">    uint32_t acqiureIntr = _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intr) | MY_IPC_ACQUIRE_INTR_MASK;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a>(myIpcIntr, releaseIntr, acqiureIntr);</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: the next block is inside the IPC interrupt handler */</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Get all the enabled pending interrupts */</span></div><div class="line">        uint32_t intr = <a class="code" href="group__group__ipc__functions.html#ga423a1a0df8939384794e95f7e05b1e03">Cy_IPC_Drv_GetInterruptStatusMasked</a>(myIpcIntr);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (0UL != (MY_IPC_RELEASE_INTR_MASK &amp; intr))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle the RELEASE event of the IPC channel MY_IPC_CHAN_INDEX */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (0UL != (MY_IPC_ACQUIRE_INTR_MASK &amp; intr))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Handle the ACQUIRE interrupt */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clear the interrupt */</span></div><div class="line">        <a class="code" href="group__group__ipc__functions.html#gaa3dbb5de3a3b0336daa2758e72dded45">Cy_IPC_Drv_ClearInterrupt</a>(myIpcIntr, _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intr),</div><div class="line">                                             _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intr));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Scenario: disable ALL the IPC interrupts (not from the IPC channel</span></div><div class="line"><span class="comment">     * #MY_IPC_CHAN_INDEX only) in the IPC interrupt channel</span></div><div class="line"><span class="comment">     * #MY_IPC_INTR_INDEX when they are not needed anymore</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__ipc__functions.html#ga6e910b181ed0ef66a0fa9a2cc9afa105">Cy_IPC_Drv_SetInterruptMask</a>(myIpcIntr, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>, <a class="code" href="group__group__ipc__macros.html#ga8c02b33010a796cc0d610491bda52827">CY_IPC_NO_NOTIFICATION</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
