<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: SAR          (SAR ADC Subsystem)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__sar.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">SAR (SAR ADC Subsystem)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>This driver configures and controls the SAR ADC subsystem block. </p>
<p>The functions and other declarations used in this driver are in cy_sar.h. You can include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>This SAR ADC subsystem is comprised of:</p><ul>
<li>a 12-bit SAR converter (SARADC)</li>
<li>an embedded reference block (SARREF)</li>
<li>a mux (<a class="el" href="group__group__sar.html#group_sar_sarmux">SARMUX</a>) at the inputs of the converter</li>
<li>a sequence controller (<a class="el" href="group__group__sar.html#group_sar_sarmux">SARSEQ</a>) that enables multi-channel acquisition in a round robin fashion, without CPU intervention, to maximize scan rates.</li>
</ul>
<div class="image">
<img src="sar_block_diagram.png" alt="sar_block_diagram.png"/>
</div>
<p>The high level features of the subsystem are:</p><ul>
<li>maximum sample rate of 1 Msps</li>
<li>Sixteen individually configurable channels (depends on device routing capabilities)</li>
<li>per channel selectable<ul>
<li>single-ended or differential input mode</li>
<li>input from external pin (8 channels in single-ended mode or 4 channels in differential mode) or from internal signals (AMUXBUS, CTB, Die Temperature Sensor)</li>
<li>choose one of four programmable acquisition times</li>
<li>averaging and accumulation</li>
</ul>
</li>
<li>scan can be triggered by firmware or hardware in single shot or continuous mode</li>
<li>hardware averaging from 2 to 256 samples</li>
<li>selectable voltage references<ul>
<li>internal VDDA and VDDA/2 references</li>
<li>buffered 1.2 V bandgap reference from <a class="el" href="group__group__sysanalog.html">AREF</a></li>
<li>external reference from dedicated pin</li>
</ul>
</li>
<li>Interrupt generation</li>
</ul>
<h1><a class="anchor" id="group_sar_usage"></a>
Usage</h1>
<p>The high level steps to use this driver are:</p>
<ol type="1">
<li><a class="el" href="group__group__sar.html#group_sar_initialization">Initialization and Enable</a></li>
<li><a class="el" href="group__group__sar.html#group_sar_trigger_conversions">Triggering Conversions</a></li>
<li><a class="el" href="group__group__sar.html#group_sar_handle_interrupts">Handling Interrupts</a></li>
<li><a class="el" href="group__group__sar.html#group_sar_retrieve_result">Retrieve Channel Results</a></li>
</ol>
<h1><a class="anchor" id="group_sar_initialization"></a>
Initialization and Enable</h1>
<p>To configure the SAR subsystem, call <a class="el" href="group__group__sar__functions__basic.html#ga5c053a77ca29519ca29da56da7eaeebe">Cy_SAR_Init</a>. Pass in a pointer to the <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> structure for the base hardware register address and pass in the configuration structure, <a class="el" href="structcy__stc__sar__config__t.html">cy_stc_sar_config_t</a>.</p>
<p>After initialization, call <a class="el" href="group__group__sar__functions__basic.html#ga4b8bb939483fac5768910156075d4264">Cy_SAR_Enable</a> to enable the hardware.</p>
<p>Here is guidance on how to set the data fields of the configuration structure:</p>
<h2><a class="anchor" id="group_sar_init_struct_ctrl"></a>
uint32_t ctrl</h2>
<p>This field specifies configurations that apply to all channels such as the Vref source or the negative terminal selection for all single-ended channels. Select a value from each of the following enums that begin with "cy_en_sar_ctrl_" and "OR" them together.</p><ul>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#ga35b1b11fbe44b764ba6b6346116e177f">cy_en_sar_ctrl_pwr_ctrl_vref_t</a></li>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#ga8f8244be5b3475b12564d27ce435dc83">cy_en_sar_ctrl_vref_sel_t</a></li>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#ga6c41e98b415fe0fd34cbe3508b5a0903">cy_en_sar_ctrl_bypass_cap_t</a></li>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#ga714456a56b0bed98012dc37256b1145c">cy_en_sar_ctrl_neg_sel_t</a></li>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#gaed426a773be43a1d02d40fe5bef5349c">cy_en_sar_ctrl_hw_ctrl_negvref_t</a></li>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#ga0f2ec6b75df20cba7016f35ef164c181">cy_en_sar_ctrl_comp_delay_t</a></li>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#ga3b5fb1f5e7ab25bb3fb93ced1eb84c08">cy_en_sar_ctrl_comp_pwr_t</a></li>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#ga73b02bd3911df06c999614e5fb3cc30d">cy_en_sar_ctrl_sarmux_deep_sleep_t</a></li>
<li><a class="el" href="group__group__sar__ctrl__register__enums.html#ga0f744ea4e07091484f5587e5466a4a57">cy_en_sar_ctrl_sarseq_routing_switches_t</a></li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">    #define CTRL                  (uint32_t)CY_SAR_VREF_PWR_100           </span><span class="comment">/* Set reference voltage buffer to full power (100%) */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_VREF_SEL_VDDA_DIV_2    </span><span class="comment">/* Select internal VDDA/2 as the Vref. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_BYPASS_CAP_ENABLE      </span><span class="comment">/* Enable Vref bypass capacitory. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_NEG_SEL_VREF           </span><span class="comment">/* Use Vref as the negative terminal for all single-ended channels. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CTRL_NEGVREF_HW        </span><span class="comment">/* Enable hardware control of switch between Vref and negative terminal. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CTRL_COMP_DLY_2P5      </span><span class="comment">/* Set comparator latch delay to 2.5 ns delay for maximum conversion rates. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_COMP_PWR_100           </span><span class="comment">/* Set comparator power to full power for maximum conversion rates. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_DEEPSLEEP_SARMUX_OFF   </span><span class="comment">/* Disable SARMUX in Deep Sleep mode. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_SARSEQ_SWITCH_ENABLE   </span><span class="comment">/* Enable the SARSEQ. */</span><span class="preprocessor"></span></div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_init_struct_sampleCtrl"></a>
uint32_t sampleCtrl</h2>
<p>This field configures sampling details that apply to all channels. Select a value from each of the following enums that begin with "cy_en_sar_sample_" and "OR" them together.</p><ul>
<li><a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gaa4ffb0ad77de3d0bdf85bfbc713218f6">cy_en_sar_sample_ctrl_result_align_t</a></li>
<li><a class="el" href="group__group__sar__sample__ctrl__register__enums.html#ga8919e435c53bfc20a8f26530e3ba7270">cy_en_sar_sample_ctrl_single_ended_format_t</a></li>
<li><a class="el" href="group__group__sar__sample__ctrl__register__enums.html#ga2d4acecaee4c010ea2e553171675a5b6">cy_en_sar_sample_ctrl_differential_format_t</a></li>
<li><a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gaed912a3edfab12b4ebea94fedf289ecf">cy_en_sar_sample_ctrl_avg_cnt_t</a></li>
<li><a class="el" href="group__group__sar__sample__ctrl__register__enums.html#ga9632ebe875d036e34a15d7c8df57e331">cy_en_sar_sample_ctrl_avg_mode_t</a></li>
<li><a class="el" href="group__group__sar__sample__ctrl__register__enums.html#ga62ecb4e368dcea23cfbfc41bd0497fc6">cy_en_sar_sample_ctrl_trigger_mode_t</a></li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">    #define SAMPLE_CTRL           (uint32_t)CY_SAR_RIGHT_ALIGN                </span><span class="comment">/* Right align result data to bits[11:0]. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_SINGLE_ENDED_UNSIGNED      </span><span class="comment">/* Single ended channels are unsigned. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_DIFFERENTIAL_SIGNED        </span><span class="comment">/* Differential channels are signed. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_AVG_CNT_2                  </span><span class="comment">/* Set number of samples averaged to 2. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_AVG_MODE_SEQUENTIAL_FIXED  </span><span class="comment">/* Averaging mode is sequential 12-bit fixed.*/</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_TRIGGER_MODE_FW_ONLY       </span><span class="comment">/* Hardware trigger is disabled. */</span><span class="preprocessor"></span></div><div class="line">    </div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_init_struct_sampleTime01"></a>
uint32_t sampleTime01</h2>
<p>This field configures the value for sample times 0 and 1 in ADC clock cycles.</p>
<p>The SAR has four programmable 10-bit aperture times that are configured using two data fields, <a class="el" href="group__group__sar.html#group_sar_init_struct_sampleTime01">uint32_t sampleTime01</a> and <a class="el" href="group__group__sar.html#group_sar_init_struct_sampleTime23">uint32_t sampleTime23</a>. Ten bits allow for a range of 0 to 1023 cycles, however 0 and 1 are invalid. The minimum aperture time is 167 ns. With an 18 MHz ADC clock, this is equal to 3 cycles or a value of 4 in this field. The actual aperture time is one cycle less than the value stored in this field.</p>
<p>Use the shifts defined in <a class="el" href="group__group__sar__sample__time__shift__enums.html#gac2dbd174d90a705e84237c67622da004">cy_en_sar_sample_time_shift_t</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">    #define SAMPLE_TIME01       (135 &lt;&lt; CY_SAR_SAMPLE_TIME0_SHIFT)  </span><span class="comment">/* Sample Time 0 set to 134 ADC clock cycles. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (4 &lt;&lt; CY_SAR_SAMPLE_TIME1_SHIFT)  </span><span class="comment">/* Sample Time 1 set to 3 ADC clock cycles. */</span><span class="preprocessor"></span></div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_init_struct_sampleTime23"></a>
uint32_t sampleTime23</h2>
<p>This field configures the value for sample times 2 and 3 in ADC clock cycles. Use the shifts defined in <a class="el" href="group__group__sar__sample__time__shift__enums.html#gac2dbd174d90a705e84237c67622da004">cy_en_sar_sample_time_shift_t</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">    #define SAMPLE_TIME23       (4 &lt;&lt; CY_SAR_SAMPLE_TIME2_SHIFT)    </span><span class="comment">/* Sample Time 2 set to 3 ADC clock cycles. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (4 &lt;&lt; CY_SAR_SAMPLE_TIME3_SHIFT)  </span><span class="comment">/* Sample Time 3 set to 3 ADC clock cycles. */</span><span class="preprocessor"></span></div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_init_struct_rangeThres"></a>
uint32_t rangeThres</h2>
<p>This field configures the upper and lower thresholds for the range interrupt. These thresholds apply on a global level for all channels with range detection enabled.</p>
<p>The SARSEQ supports range detection to allow for automatic detection of sample values compared to two programmable thresholds without CPU involvement. Range detection is done after averaging, alignment, and sign extension (if applicable). In other words the threshold values need to have the same data format as the result data. The values are interpreted as signed or unsigned according to each channel's configuration.</p>
<p>Use the shifts defined in <a class="el" href="group__group__sar__range__thres__register__enums.html#ga4e9ea88485879db9d2b7667066577fe6">cy_en_sar_range_thres_shift_t</a>.</p>
<p>The <a class="el" href="group__group__sar__functions__config.html#gaff69993327b0aba19490c7ac9708138c">Cy_SAR_SetLowLimit</a> and <a class="el" href="group__group__sar__functions__config.html#ga1010c3aa3528648ac3715481c0339e28">Cy_SAR_SetHighLimit</a> provide run-time configurability of these thresholds.</p>
<div class="fragment"><div class="line"><span class="preprocessor">    #define RANGE_THRES         (0x300uL  &lt;&lt; CY_SAR_RANGE_LOW_SHIFT)     </span><span class="comment">/* Lower limit of range detection is 0x300. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (0xC00uL  &lt;&lt; CY_SAR_RANGE_HIGH_SHIFT) </span><span class="comment">/* Upper limit of range detection is 0xC00. */</span><span class="preprocessor"></span></div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_init_struct_rangeCond"></a>
cy_en_sar_range_detect_condition_t rangeCond</h2>
<p>This field configures the condition (below, inside, outside, or above) that will trigger the range interrupt. Select a value from the <a class="el" href="group__group__sar__range__thres__register__enums.html#gaccf649d65a86e17939c3d20a684cd9cd">cy_en_sar_range_detect_condition_t</a> enum.</p>
<h2><a class="anchor" id="group_sar_init_struct_chanEn"></a>
uint32_t chanEn</h2>
<p>This field configures which channels will be scanned. Each bit corresponds to a channel. Bit 0 enables channel 0, bit 1 enables channel 1, bit 2 enables channel 2, and so on.</p>
<h2><a class="anchor" id="group_sar_init_struct_chanConfig"></a>
uint32_t chanConfig[16]</h2>
<p>Each channel has its own channel configuration register. The channel configuration specifies which pin/signal is connected to that channel and how the channel is sampled.</p>
<p>Select a value from each of the following enums that begin with "cy_en_sar_chan_config_" and "OR" them together.</p>
<ul>
<li><a class="el" href="group__group__sar__chan__config__register__enums.html#gaa170caf9884001307e012cac1900f4d4">cy_en_sar_chan_config_input_mode_t</a></li>
<li><a class="el" href="group__group__sar__chan__config__register__enums.html#ga57ec594c27e779c87f4132145357f267">cy_en_sar_chan_config_pos_pin_addr_t</a></li>
<li><a class="el" href="group__group__sar__chan__config__register__enums.html#ga75e8d54e8aae0f42256cb47aaf7996d8">cy_en_sar_chan_config_pos_port_addr_t</a></li>
<li><a class="el" href="group__group__sar__chan__config__register__enums.html#gadab9893c1ba4c1a567d75909c3433128">cy_en_sar_chan_config_avg_en_t</a></li>
<li><a class="el" href="group__group__sar__chan__config__register__enums.html#ga4536867f2568fc3a2724bf39a83ddf8e">cy_en_sar_chan_config_sample_time_t</a></li>
<li><a class="el" href="group__group__sar__chan__config__register__enums.html#ga1087221febbbebdd812291b9f2f9411a">cy_en_sar_chan_config_neg_pin_addr_t</a></li>
<li><a class="el" href="group__group__sar__chan__config__register__enums.html#ga8c0c98079440ebcd5ac9c04b170e574d">cy_en_sar_chan_config_neg_port_addr_t</a></li>
</ul>
<p>Some important considerations are:</p><ul>
<li>The POS_PORT_ADDR and POS_PIN_ADDR bit fields are used by the SARSEQ to select the connection to the positive terminal (Vplus) of the ADC for each channel.</li>
<li>When the channel is an unpaired differential input (<a class="el" href="group__group__sar__chan__config__register__enums.html#ggaa170caf9884001307e012cac1900f4d4a1380c52520885ff16d02023be2633321">CY_SAR_CHAN_DIFFERENTIAL_UNPAIRED</a>), the NEG_PORT_ADDR and NEG_PIN_ADDR are used by the SARSEQ to select the connection to the negative terminal (Vminus) of the ADC.</li>
<li>When the channel is a differential input pair (<a class="el" href="group__group__sar__chan__config__register__enums.html#ggaa170caf9884001307e012cac1900f4d4a3e9268c5cac60e272be2504bb6d63c50">CY_SAR_CHAN_DIFFERENTIAL_PAIRED</a>), the NEG_PORT_ADDR and NEG_PIN_ADDR are ignored. For differential input pairs, only the pin for the positive terminal needs to be specified and this pin must be even. For example, Pin 0 (positive terminal) and Pin 1 (negative terminal) are a pair. Pin 2 (positive terminal) and Pin 3 (negative terminal) are a pair.</li>
</ul>
<p>If the SARSEQ is disabled (<a class="el" href="group__group__sar__ctrl__register__enums.html#ga0f744ea4e07091484f5587e5466a4a57">cy_en_sar_ctrl_sarseq_routing_switches_t</a>) or it is not controlling any switches (<a class="el" href="group__group__sar.html#group_sar_init_struct_muxSwitchSqCtrl">uint32_t muxSwitchSqCtrl</a> = 0), the port and pin addresses are ignored. This is possible when there is only one channel to scan.</p>
<div class="fragment"><div class="line"><span class="preprocessor">    #define CHANNEL_0_CONFIG    CY_SAR_CHAN_SINGLE_ENDED        </span><span class="comment">/* Channel 0 is a single ended channel. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_CHAN_SAMPLE_TIME_0     </span><span class="comment">/* Aperature time is set by Sample Time 0. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_POS_PORT_ADDR_SARMUX   </span><span class="comment">/* Use the SARMUX dedicated port (see the device datasheet for the SARMUX port). */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_CHAN_POS_PIN_ADDR_2    </span><span class="comment">/* Use Pin 2 of the SARMUX. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_CHAN_AVG_DISABLE       </span><span class="comment">/* Disable averaging. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_1_CONFIG    CY_SAR_CHAN_DIFFERENTIAL_PAIRED </span><span class="comment">/* Channel 1 is a differential paired channel. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_CHAN_SAMPLE_TIME_1     </span><span class="comment">/* Aperature time is set by Sample Time 1. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_POS_PORT_ADDR_SARMUX   </span><span class="comment">/* Use the SARMUX dedicated port (see the device datasheet for the SARMUX port). */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_CHAN_POS_PIN_ADDR_0    </span><span class="comment">/* Positive terminal is connected to Pin 0 and negative terminal is connected to Pin 1 of the SARMUX. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_CHAN_AVG_ENABLE        </span><span class="comment">/* Enable averaging. */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define CHANNEL_CONFIG      {(uint32_t)CHANNEL_0_CONFIG, \</span></div><div class="line"><span class="preprocessor">                                 (uint32_t)CHANNEL_1_CONFIG, \</span></div><div class="line"><span class="preprocessor">                                 0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U} </span><span class="comment">/* All other channels are unconfigured. */</span><span class="preprocessor"></span></div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_init_struct_intrMask"></a>
uint32_t intrMask</h2>
<p>This field configures which interrupt events (end of scan, overflow, or firmware collision) will be serviced by the firmware.</p>
<p>Select one or more values from the <a class="el" href="group__group__sar__intr__mask__t__register__enums.html#gaed86236056495517571b7949afec3eb9">cy_en_sar_intr_mask_t</a> enum and "OR" them together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">    #define INTR_MASK           CY_SAR_INTR_EOS_MASK | CY_SAR_INTR_OVERFLOW_MASK </span><span class="comment">/* Enable both EOS and overflow interrupt evnts. */</span><span class="preprocessor"></span></div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_init_struct_satIntrMask"></a>
uint32_t satIntrMask</h2>
<p>This field configures which channels will cause a saturation interrupt.</p>
<p>The SARSEQ has a saturation detect that is always applied to every conversion. This feature detects whether a channel's sample value is equal to the minimum or maximum values. This allows the firmware to take action, for example, discard the result, when the SARADC saturates. The sample value is tested right after conversion, that is, before averaging. This means that it can happen that the interrupt is set while the averaged result in the data register is not equal to the minimum or maximum.</p>
<p>Each bit corresponds to a channel. A value of 0 disables saturation detection for all channels.</p>
<h2><a class="anchor" id="group_sar_init_struct_rangeIntrMask"></a>
uint32_t rangeIntrMask</h2>
<p>This field configures which channels will cause a range detection interrupt. Each bit corresponds to a channel. A value of 0 disables range detection for all channels.</p>
<h2><a class="anchor" id="group_sar_init_struct_muxSwitch"></a>
uint32_t muxSwitch</h2>
<p>This field is the firmware control of the SARMUX switches.</p>
<p>Use one or more values from the <a class="el" href="group__group__sar__mux__switch__register__enums.html#ga54fb9cfe9a89cf962de036422f9d9782">cy_en_sar_mux_switch_fw_ctrl_t</a> enum and "OR" them together. If the SARSEQ is enabled, the SARMUX switches that will be used must also be closed using this firmware control.</p>
<div class="fragment"><div class="line"><span class="preprocessor">    #define MUX_SWITCH          CY_SAR_MUX_FW_P2_VPLUS          </span><span class="comment">/* Connect Pin 2 of the SARMUX to the positive terminal of the SARADC. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_P0_VPLUS        </span><span class="comment">/* Connect Pin 0 of the SARMUX to the positive terminal of the SARADC. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_P1_VMINUS       </span><span class="comment">/* Connect Pin 1 of the SARMUX to the negative terminal of the SARADC. */</span><span class="preprocessor"></span></div></div><!-- fragment --><p> Firmware control can be changed at run-time by calling <a class="el" href="group__group__sar__functions__switches.html#gabc0b47c3fd4c0a21adb41140bb380592">Cy_SAR_SetAnalogSwitch</a> with <a class="el" href="group__group__sar__enums.html#ggaa45a7677b7c1051696ea01c15439bc11a78079f5b79489ddd8d21a0b4ec8be486">CY_SAR_MUX_SWITCH0</a> and the desired switch states.</p>
<h2><a class="anchor" id="group_sar_init_struct_muxSwitchSqCtrl"></a>
uint32_t muxSwitchSqCtrl</h2>
<p>This field enables or disables SARSEQ control of the SARMUX switches. To disable control of all switches, set this field to 0. To disable the SARSEQ all together, use <a class="el" href="group__group__sar__ctrl__register__enums.html#gga0f744ea4e07091484f5587e5466a4a57a81471e07bac4eb63b5aaca6c99654115">CY_SAR_SARSEQ_SWITCH_DISABLE</a> when configuring the <a class="el" href="group__group__sar.html#group_sar_init_struct_ctrl">uint32_t ctrl</a> register.</p>
<p>Use one or more values from the <a class="el" href="group__group__sar__mux__switch__register__enums.html#ga5af95eff1664f03132e1e02dd865f8a4">cy_en_sar_mux_switch_sq_ctrl_t</a> enum and "OR" them together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">    #define MUX_SWITCH_SQ_CTRL  CY_SAR_MUX_SQ_CTRL_P0           </span><span class="comment">/* Enable sequencer control of Pins 0 of the SARMUX. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_SQ_CTRL_P1         </span><span class="comment">/* Enable sequencer control of Pins 1 of the SARMUX. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_SQ_CTRL_P2         </span><span class="comment">/* Enable sequencer control of Pins 2 of the SARMUX. */</span><span class="preprocessor"></span></div></div><!-- fragment --><p> SARSEQ control can be changed at run-time by calling <a class="el" href="group__group__sar__functions__switches.html#ga0f2411703292dae743387769f41b14d4">Cy_SAR_SetSwitchSarSeqCtrl</a>.</p>
<h2><a class="anchor" id="group_sar_init_struct_configRouting"></a>
bool configRouting</h2>
<p>If true, the <a class="el" href="group__group__sar.html#group_sar_init_struct_muxSwitch">uint32_t muxSwitch</a> and <a class="el" href="group__group__sar.html#group_sar_init_struct_muxSwitchSqCtrl">uint32_t muxSwitchSqCtrl</a> fields will be used. If false, the fields will be ignored.</p>
<h2><a class="anchor" id="group_sar_init_struct_vrefMvValue"></a>
uint32_t vrefMvValue</h2>
<p>This field sets the value of the reference voltage in millivolts used. This value is used for converting counts to volts in the <a class="el" href="group__group__sar__functions__countsto.html#gaf9e34e8b68020602396686ec699314a1">Cy_SAR_CountsTo_Volts</a>, <a class="el" href="group__group__sar__functions__countsto.html#ga8f1189056459a76c4b9f9917dc3a9e6e">Cy_SAR_CountsTo_mVolts</a>, and <a class="el" href="group__group__sar__functions__countsto.html#ga0950546e50604fc6daa33b2bdb155e5d">Cy_SAR_CountsTo_uVolts</a> functions.</p>
<h1><a class="anchor" id="group_sar_trigger_conversions"></a>
Triggering Conversions</h1>
<p>The SAR subsystem has the following modes for triggering a conversion: </p><table class="doxtable">
<tr>
<th>Mode </th><th>Description </th><th>Usage  </th></tr>
<tr>
<td>Continuous </td><td>After completing a scan, the SARSEQ will immediately start the next scan. That is, the SARSEQ will always be BUSY. As a result all other triggers, firmware or hardware, are essentially ignored.  </td><td>To enter this mode, call <a class="el" href="group__group__sar__functions__basic.html#ga92cb7f3c5947df6e47b59f1b2796883c">Cy_SAR_StartConvert</a> with <a class="el" href="group__group__sar__enums.html#ggaf21d08e4f15f54ac638943e50538d95caf9d6d2d190b4a044611be54dbe147890">CY_SAR_START_CONVERT_CONTINUOUS</a>. To stop continuous conversions, call <a class="el" href="group__group__sar__functions__basic.html#ga1397031ccf2c1f8a5a95a77f9362e1d1">Cy_SAR_StopConvert</a>.   </td></tr>
<tr>
<td>Firmware single shot </td><td>A single conversion of all enabled channels is triggered with a function call to <a class="el" href="group__group__sar__functions__basic.html#ga92cb7f3c5947df6e47b59f1b2796883c">Cy_SAR_StartConvert</a> with <a class="el" href="group__group__sar__enums.html#ggaf21d08e4f15f54ac638943e50538d95ca2aae9e550dc6dd379d8a37d28445dbbf">CY_SAR_START_CONVERT_SINGLE_SHOT</a>.  </td><td>Firmware triggering is always available by calling <a class="el" href="group__group__sar__functions__basic.html#ga92cb7f3c5947df6e47b59f1b2796883c">Cy_SAR_StartConvert</a> with <a class="el" href="group__group__sar__enums.html#ggaf21d08e4f15f54ac638943e50538d95ca2aae9e550dc6dd379d8a37d28445dbbf">CY_SAR_START_CONVERT_SINGLE_SHOT</a>. To allow only firmware triggering, or disable hardware triggering, set up the <a class="el" href="structcy__stc__sar__config__t.html">cy_stc_sar_config_t</a> config structure with <a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gga62ecb4e368dcea23cfbfc41bd0497fc6a55a26ca93dcfd68c8b9b120416bc1b32">CY_SAR_TRIGGER_MODE_FW_ONLY</a>.   </td></tr>
<tr>
<td>Hardware edge sensitive </td><td>A single conversion of all enabled channels is triggered on the rising edge of the hardware trigger signal. </td><td>To enable this mode, set up the <a class="el" href="structcy__stc__sar__config__t.html">cy_stc_sar_config_t</a> config structure with <a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gga62ecb4e368dcea23cfbfc41bd0497fc6a7eed8528ba801da55b7727c170d361e1">CY_SAR_TRIGGER_MODE_FW_AND_HWEDGE</a>.  </td></tr>
<tr>
<td>Hardware level sensitive </td><td>Conversions are triggered continuously when the hardware trigger signal is high. </td><td>To enable this mode, set up the <a class="el" href="structcy__stc__sar__config__t.html">cy_stc_sar_config_t</a> config structure with <a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gga62ecb4e368dcea23cfbfc41bd0497fc6ac7d137ec50152f166656503877638943">CY_SAR_TRIGGER_MODE_FW_AND_HWLEVEL</a>.  </td></tr>
</table>
<p>The trigger mode can be changed during run time with <a class="el" href="group__group__sar__functions__config.html#gaabd68168933e0922c739ee8ebe3cddd6">Cy_SAR_SetConvertMode</a>.</p>
<p>For the hardware trigger modes, use the <a class="el" href="group__group__trigmux.html">TrigMux (Trigger Multiplexer)</a> driver to route an internal or external signal to the SAR trigger input. When making the required <a class="el" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a> calls, use the pre-defined enum, TRIG6_OUT_PASS_TR_SAR_IN, for the SAR trigger input.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: P0.0 is used to trigger the SAR conversions.</span></div><div class="line"><span class="comment">     * Configure and route P0.0 as the trigger input of the SAR. */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Set drive mode of P0.0 to digital High-Z with the input buffer on.</span></div><div class="line"><span class="comment">     * Connect P0.0 to the HSIOM. */</span>    </div><div class="line">    <a class="code" href="group__group__gpio__functions__init.html#gaf57c501727276013d3e8974a9fb7d0a7">Cy_GPIO_Pin_FastInit</a>(GPIO_PRT0, 0UL, <a class="code" href="group__group__gpio__drive_modes.html#gaf2fe5dc00ba1770b37e620a01169485c">CY_GPIO_DM_HIGHZ</a>, 0UL, P0_0_PERI_TR_IO_INPUT0);</div><div class="line"></div><div class="line">    <span class="comment">/* Connect the HSIOM to the SAR trigger input. */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_MXPERI_VERSION == 1U)</span></div><div class="line">    (void)<a class="code" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a>(TRIG12_IN_PERI_TR_IO_INPUT0, TRIG12_OUT_TR_GROUP2_INPUT32, CY_TR_MUX_TR_INV_DISABLE, TRIGGER_TYPE_PERI_TR_IO_INPUT__LEVEL);</div><div class="line">    (void)<a class="code" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a>(TRIG6_IN_TR_GROUP12_OUTPUT7, TRIG6_OUT_PASS_TR_SAR_IN, CY_TR_MUX_TR_INV_DISABLE, TRIGGER_TYPE_TR_GROUP_OUTPUT__LEVEL);</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CY_IP_MXPERI_VERSION &gt; 1 */</span><span class="preprocessor"></span></div><div class="line">    (void)<a class="code" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a>(TRIG_IN_MUX_9_HSIOM_TR_OUT0, TRIG_OUT_MUX_9_PASS_TR_SAR_IN, CY_TR_MUX_TR_INV_DISABLE, TRIGGER_TYPE_PERI_TR_IO_INPUT__LEVEL);</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_IP_MXPERI_VERSION */</span><span class="preprocessor"></span></div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="group_sar_handle_interrupts"></a>
Handling Interrupts</h1>
<p>The SAR can generate interrupts on these events:</p>
<ul>
<li>End of scan (EOS): when scanning of all enabled channels complete.</li>
<li>Overflow: when the result register is updated before the previous result is read.</li>
<li>FW collision: when a new trigger is received while the SAR is still processing the previous trigger.</li>
<li>Saturation detection: when the channel result is equal to the minimum or maximum value.</li>
<li>Range detection: when the channel result meets the programmed upper or lower threshold values.</li>
</ul>
<p>The SAR interrupt to the NVIC is raised any time the intersection (logic and) of the interrupt flags and the corresponding interrupt masks are non-zero.</p>
<p>Implement an interrupt routine and assign it to the SAR interrupt. Use the pre-defined enum, pass_interrupt_sar_IRQn, as the interrupt source for the SAR.</p>
<p>The following code snippet demonstrates how to implement a routine to handle the interrupt. The routine gets called when any one of the SAR interrupts are triggered. When servicing an interrupt, the user must clear the interrupt so that subsequent interrupts can be handled.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* ISR function to handle all SAR interrupts. </span></div><div class="line"><span class="comment"> * This same routine gets called when any of the enabled SAR interrupt sources</span></div><div class="line"><span class="comment"> * are enabled (EOS, overflow, FW collision, saturation detection, or range detection). */</span></div><div class="line"><span class="keywordtype">void</span> SAR_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status = 0u;</div><div class="line"></div><div class="line">    <span class="comment">/* Read interrupt status register. */</span></div><div class="line">    intr_status = <a class="code" href="group__group__sar__functions__interrupt.html#gaddf21063ab5d851b7a658af1c3c07f65">Cy_SAR_GetInterruptStatus</a>(SAR);</div><div class="line"></div><div class="line">    <span class="comment">/* Check what triggered the interrupt. */</span></div><div class="line">    <span class="keywordflow">if</span> ((intr_status &amp; (uint32_t) <a class="code" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a7a9f203ad00dedc91c67f162104520cd">CY_SAR_INTR_EOS_MASK</a>) == (uint32_t) CY_SAR_INTR_EOS_MASK)</div><div class="line">    {</div><div class="line">        <span class="comment">/* An end of scan occured, retrieve the ADC result and do something with it here. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Check for the saturation detection status, if enabled. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Check for the range detection status, if enabled. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Clear the handled interrupt. */</span></div><div class="line">    <a class="code" href="group__group__sar__functions__interrupt.html#ga749c0d8406080c3a2fc0d6f6d86fc06e">Cy_SAR_ClearInterrupt</a>(SAR, intr_status);</div><div class="line">}</div></div><!-- fragment --><p> The following code snippet demonstrates how to configure and enable the interrupt.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Configure and enable the SAR interrupt. */</span></div><div class="line">                </div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> ADC_IRQ_cfg = {</div><div class="line"><span class="preprocessor">        #if (CY_CPU_CORTEX_M0P)</span></div><div class="line">            <span class="comment">/* .intrSrc         = */</span> NvicMux7_IRQn,             <span class="comment">/* CM0+ interrupt is NVIC #7 */</span></div><div class="line">            <span class="comment">/* .cm0pSrc         = */</span> pass_interrupt_sar_IRQn,   <span class="comment">/* Source of NVIC #7 is the SAR interrupt */</span></div><div class="line">            <span class="comment">/* .intrPriority    = */</span> 3UL                        <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <span class="comment">/* .intrSrc         = */</span> pass_interrupt_sar_IRQn,   <span class="comment">/* Interrupt source is the SAR interrupt */</span></div><div class="line">            <span class="comment">/* .intrPriority    = */</span> 7UL                        <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    };</div><div class="line">    </div><div class="line">    <span class="comment">/* Configure the interrupt with vector at SAR_Interrupt(). */</span></div><div class="line">    (void)<a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;ADC_IRQ_cfg, SAR_Interrupt);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the interrupt. */</span></div><div class="line">    NVIC_EnableIRQ(ADC_IRQ_cfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div><div class="line">    </div></div><!-- fragment --><p> Alternately, instead of handling the interrupts, the <a class="el" href="group__group__sar__functions__basic.html#ga977c6fb6f81ee39d27eae43c0e45d85c">Cy_SAR_IsEndConversion</a> function allows for firmware polling of the end of conversion status.</p>
<h1><a class="anchor" id="group_sar_retrieve_result"></a>
Retrieve Channel Results</h1>
<p>Retrieve the ADC result by calling <a class="el" href="group__group__sar__functions__basic.html#ga5d7a3489629382b1e46477c034bbb2d0">Cy_SAR_GetResult16</a> with the desired channel. To convert the result to a voltage, pass the ADC result to <a class="el" href="group__group__sar__functions__countsto.html#gaf9e34e8b68020602396686ec699314a1">Cy_SAR_CountsTo_Volts</a>, <a class="el" href="group__group__sar__functions__countsto.html#ga8f1189056459a76c4b9f9917dc3a9e6e">Cy_SAR_CountsTo_mVolts</a>, or <a class="el" href="group__group__sar__functions__countsto.html#ga0950546e50604fc6daa33b2bdb155e5d">Cy_SAR_CountsTo_uVolts</a>.</p>
<h1><a class="anchor" id="group_sar_clock"></a>
SAR Clock Configuration</h1>
<p>The SAR requires a clock. Assign a clock to the SAR using the pre-defined enum, PCLK_PASS_CLOCK_SAR, to identify the SAR subsystem. Set the clock divider value to achieve the desired clock rate. The SAR can support a maximum frequency of 18 MHz.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: The PeriClk has been configured to output 50 MHz.</span></div><div class="line"><span class="comment">     * Use one of the PeriClk dividers with a divider value of 3 to get a 16.67 Mhz SAR clock. */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Assign divider number 0 of the the 8-bit dividers to the SAR. */</span></div><div class="line">    <a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gacb66324e3191006f6d1cee8b29238fb2">Cy_SysClk_PeriphAssignDivider</a>(PCLK_PASS_CLOCK_SAR, <a class="code" href="group__group__sysclk__clk__peripheral__enums.html#gga06138349be16d91fd5d00ded2f4592b8ad2299deae6e36a070de5a60368b319ad">CY_SYSCLK_DIV_8_BIT</a>, 0u);</div><div class="line"></div><div class="line">    <span class="comment">/* Divide the PeriClk by 3, which is a input value of 2. */</span></div><div class="line">    <a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gac67931844e6ec06b5ff88f4f3119e127">Cy_SysClk_PeriphSetDivider</a>(<a class="code" href="group__group__sysclk__clk__peripheral__enums.html#gga06138349be16d91fd5d00ded2f4592b8ad2299deae6e36a070de5a60368b319ad">CY_SYSCLK_DIV_8_BIT</a>, 0u, 2u);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the divider. */</span></div><div class="line">    <a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga8c626f11b583d8296516bbcf4a22f98e">Cy_SysClk_PeriphEnableDivider</a>(<a class="code" href="group__group__sysclk__clk__peripheral__enums.html#gga06138349be16d91fd5d00ded2f4592b8ad2299deae6e36a070de5a60368b319ad">CY_SYSCLK_DIV_8_BIT</a>, 0u);</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="group_sar_scan_time"></a>
Scan Rate</h1>
<p>The scan rate is dependent on the following:</p>
<ul>
<li>ADC clock rate</li>
<li>Number of channels</li>
<li>Averaging</li>
<li>Resolution</li>
<li>Acquisition times</li>
</ul>
<h2><a class="anchor" id="group_sar_acquisition_time"></a>
Acquisition Time</h2>
<p>The acquisition time of a channel is based on which of the four global aperture times are selected for that channel. The selection is done during initialization per channel with <a class="el" href="group__group__sar.html#group_sar_init_struct_chanConfig">uint32_t chanConfig[16]</a>. The four global aperture times are also set during initialization with <a class="el" href="group__group__sar.html#group_sar_init_struct_sampleTime01">uint32_t sampleTime01</a> and <a class="el" href="group__group__sar.html#group_sar_init_struct_sampleTime23">uint32_t sampleTime23</a>. Note that these global aperture times are in SAR clock cycles and the acquisition time is 1 less than that value in the register.</p>
<div class="image">
<img src="sar_acquisition_time_eqn.png" alt="sar_acquisition_time_eqn.png"/>
</div>
<h2><a class="anchor" id="group_sar_channel_sample_time"></a>
Channel Sample Time</h2>
<p>The sample time for a channel is the time required to acquire the analog signal and convert it to a digital code.</p>
<div class="image">
<img src="sar_channel_sample_time_eqn.png" alt="sar_channel_sample_time_eqn.png"/>
</div>
<p>The SAR ADC is a 12-bit converter so Resolution = 12.</p>
<h2><a class="anchor" id="group_sar_total_scan_time"></a>
Total Scan Time</h2>
<p>Channels using one of the sequential averaging modes (<a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gga9632ebe875d036e34a15d7c8df57e331a91a5fad5906a200940bbfbf15ef08868">CY_SAR_AVG_MODE_SEQUENTIAL_ACCUM</a> or <a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gga9632ebe875d036e34a15d7c8df57e331ade22974fa0104308e9484cc606842b2d">CY_SAR_AVG_MODE_SEQUENTIAL_FIXED</a>) are sampled multiple times per scan. The number of samples averaged are set during initialization with <a class="el" href="group__group__sar.html#group_sar_init_struct_sampleCtrl">uint32_t sampleCtrl</a> using one of the values from <a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gaed912a3edfab12b4ebea94fedf289ecf">cy_en_sar_sample_ctrl_avg_cnt_t</a>. Channels that are not averaged or use the <a class="el" href="group__group__sar__sample__ctrl__register__enums.html#gga9632ebe875d036e34a15d7c8df57e331a89d83498d39e5e049cb2b33c18145095">CY_SAR_AVG_MODE_INTERLEAVED</a> mode are only sampled once per scan.</p>
<p>The total scan time is the sum of each channel's sample time multiplied by the samples per scan.</p>
<div class="image">
<img src="sar_scan_rate_eqn.png" alt="sar_scan_rate_eqn.png"/>
</div>
<p>where N is the total number of channels in the scan.</p>
<h1><a class="anchor" id="group_sar_sarmux"></a>
SARMUX and SARSEQ</h1>
<p>The SARMUX is an analog programmable multiplexer. Its switches can be controlled by the SARSEQ or firmware. and the inputs can come from:</p><ul>
<li>a dedicated port (can support 8 single-ended channels or 4 differential channels)</li>
<li>an internal die temperature (DieTemp) sensor</li>
<li>CTB output via SARBUS0/1 (if CTBs are available on the device)</li>
<li>AMUXBUSA/B</li>
</ul>
<p>The following figure shows the SARMUX switches. See the device datasheet for the exact location of SARMUX pins.</p>
<div class="image">
<img src="sar_sarmux_switches.png" alt="sar_sarmux_switches.png"/>
</div>
<p>When using the SARSEQ, the following configurations must be performed:</p><ul>
<li>enable SARSEQ control of required switches (see <a class="el" href="group__group__sar.html#group_sar_init_struct_muxSwitchSqCtrl">uint32_t muxSwitchSqCtrl</a>)</li>
<li>close the required switches with firmware (see <a class="el" href="group__group__sar.html#group_sar_init_struct_muxSwitch">uint32_t muxSwitch</a>)</li>
<li>configure the POS_PORT_ADDR and POS_PIN_ADDR, and if used, the NEG_PORT_ADDR and NEG_PIN_ADDR (see <a class="el" href="group__group__sar.html#group_sar_init_struct_chanConfig">uint32_t chanConfig[16]</a>)</li>
</ul>
<p>While firmware can control every switch in the SARMUX, not every switch can be controlled by the SARSEQ (green switches in the above figure). Additionally, switches outside of the SARMUX such as the AMUXBUSA/B switches or CTB switches will require separate function calls (see <a class="el" href="group__group__gpio.html">GPIO</a> and <a class="el" href="group__group__ctb.html">CTB</a> drivers). The SARSEQ can control three switches in the <a class="el" href="group__group__ctb.html">CTB</a> driver (see <a class="el" href="group__group__ctb__functions__switches.html#ga1071f19b5c0808366de90f17e1e25b57">Cy_CTB_EnableSarSeqCtrl</a>). These switches need to be enabled for SARSEQ control if the CTB outputs are used as the SARMUX inputs.</p>
<p>The following table shows the required POS_PORT_ADDR and POS_PIN_ADDR settings for different input connections.</p>
<table class="doxtable">
<tr>
<th>Input Connection Selection </th><th>POS_PORT_ADDR </th><th>POS_PIN_ADDR  </th></tr>
<tr>
<td>SARMUX dedicated port </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga75e8d54e8aae0f42256cb47aaf7996d8a166f050c530bd3c2b7bf9a9882d9bf27">CY_SAR_POS_PORT_ADDR_SARMUX</a> </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga57ec594c27e779c87f4132145357f267af6beb6730492beb56ee62d25402c2d58">CY_SAR_CHAN_POS_PIN_ADDR_0</a> through <a class="el" href="group__group__sar__chan__config__register__enums.html#gga57ec594c27e779c87f4132145357f267a51c6b1308be0596399c1dfe2e482fab3">CY_SAR_CHAN_POS_PIN_ADDR_7</a>  </td></tr>
<tr>
<td>DieTemp sensor </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga75e8d54e8aae0f42256cb47aaf7996d8a2467c1287339e68e44929b1e7f337fa5">CY_SAR_POS_PORT_ADDR_SARMUX_VIRT</a> </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga57ec594c27e779c87f4132145357f267af6beb6730492beb56ee62d25402c2d58">CY_SAR_CHAN_POS_PIN_ADDR_0</a>  </td></tr>
<tr>
<td>AMUXBUSA </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga75e8d54e8aae0f42256cb47aaf7996d8a2467c1287339e68e44929b1e7f337fa5">CY_SAR_POS_PORT_ADDR_SARMUX_VIRT</a> </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga57ec594c27e779c87f4132145357f267a1e670672bd9d8055b18d434fd2151a90">CY_SAR_CHAN_POS_PIN_ADDR_2</a>  </td></tr>
<tr>
<td>AMUXBUSB </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga75e8d54e8aae0f42256cb47aaf7996d8a2467c1287339e68e44929b1e7f337fa5">CY_SAR_POS_PORT_ADDR_SARMUX_VIRT</a> </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga57ec594c27e779c87f4132145357f267a937ad68dea7987b45d159664a9751194">CY_SAR_CHAN_POS_PIN_ADDR_3</a>  </td></tr>
<tr>
<td>CTB0 Opamp0 1x output </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga75e8d54e8aae0f42256cb47aaf7996d8a80a4cd64680ba9fee93846ea020b6a41">CY_SAR_POS_PORT_ADDR_CTB0</a> </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga57ec594c27e779c87f4132145357f267a1e670672bd9d8055b18d434fd2151a90">CY_SAR_CHAN_POS_PIN_ADDR_2</a>  </td></tr>
<tr>
<td>CTB0 Opamp1 1x output </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga75e8d54e8aae0f42256cb47aaf7996d8a80a4cd64680ba9fee93846ea020b6a41">CY_SAR_POS_PORT_ADDR_CTB0</a> </td><td><a class="el" href="group__group__sar__chan__config__register__enums.html#gga57ec594c27e779c87f4132145357f267a937ad68dea7987b45d159664a9751194">CY_SAR_CHAN_POS_PIN_ADDR_3</a>  </td></tr>
</table>
<h2><a class="anchor" id="group_sar_sarmux_dietemp"></a>
Input from DieTemp sensor</h2>
<p>When using the DieTemp sensor, always use single-ended mode. The temperature sensor can be routed to Vplus using the <a class="el" href="group__group__sar__mux__switch__register__enums.html#gga54fb9cfe9a89cf962de036422f9d9782a4d91423741115c1f65c36b51fc2dd667">CY_SAR_MUX_FW_TEMP_VPLUS</a> switch. Connecting this switch will also enable the sensor. Set the <a class="el" href="group__group__sar.html#group_sar_acquisition_time">acquisition time</a> to be at least 1 us to meet the settling time of the temperature sensor.</p>
<div class="image">
<img src="sar_sarmux_dietemp.png" alt="sar_sarmux_dietemp.png"/>
</div>
<div class="fragment"><div class="line"><span class="preprocessor">    #define CHANNEL_EN          1u</span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_0_CONFIG    ((uint32_t)CY_SAR_CHAN_SINGLE_ENDED           </span><span class="comment">/* Single-ended channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1         </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time.*/</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_SARMUX_VIRT  </span><span class="comment">/* Set the Vplus port address to SARMUX_VIRT for the DieTemp. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_0        </span><span class="comment">/* Set the Vplus pin address to 0 for the DieTemp. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_AVG_DISABLE)</span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_CONFIG      {(uint32_t)CHANNEL_0_CONFIG \</span></div><div class="line"><span class="preprocessor">                                ,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL} </span><span class="comment">/* Channels 1 through 15 are unconfigured. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define MUX_SWITCH          ( CY_SAR_MUX_FW_TEMP_VPLUS      </span><span class="comment">/* Close switch between Vplus and the DieTemp. This will also turn on the DieTemp sensor. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_VSSA_VMINUS)    </span><span class="comment">/* Close switch between Vminus and VSSA. */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define MUX_SWITCH_SQ_CTRL  0u  </span><span class="comment">/* Disable SARSEQ since there is only one channel enabled. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line">    <span class="comment">/* If the DieTemp is scanned with other channels, enable SARSEQ with (CY_SAR_MUX_SQ_CTRL_TEMP | CY_SAR_MUX_SQ_CTRL_VSSA)</span></div><div class="line"><span class="comment">     * along with switches for other channels. */</span></div><div class="line">    </div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_sarmux_se_diff"></a>
Input from SARMUX port</h2>
<p>The following figure and code snippet show how two GPIOs on the SARMUX dedicated port are connected to the SARADC as separate single-ended channels and as a differential-pair channel.</p>
<div class="image">
<img src="sar_sarmux_dedicated_port.png" alt="sar_sarmux_dedicated_port.png"/>
</div>
<div class="fragment"><div class="line"><span class="preprocessor">    #define CHANNEL_EN          7u</span></div><div class="line"><span class="preprocessor">    #define CHANNEL_0_CONFIG    ((uint32_t)CY_SAR_CHAN_SINGLE_ENDED       </span><span class="comment">/* Single-ended channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_0     </span><span class="comment">/* Use Sample Time 0 for 180 ns acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_SARMUX   </span><span class="comment">/* Use dedicated SARMUX port. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_0)   </span><span class="comment">/* Use Pin 0. */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define CHANNEL_1_CONFIG    ((uint32_t)CY_SAR_CHAN_SINGLE_ENDED       </span><span class="comment">/* Single-ended channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1     </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_SARMUX   </span><span class="comment">/* Use dedicated SARMUX port. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_1)   </span><span class="comment">/* Use Pin 1. */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define CHANNEL_2_CONFIG    ((uint32_t)CY_SAR_CHAN_DIFFERENTIAL_PAIRED    </span><span class="comment">/* Differentia-paired channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1         </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_SARMUX       </span><span class="comment">/* Use dedicated SARMUX port. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_0)       </span><span class="comment">/* Vplus connected to Pin 0 and Vminus connected to Pin 1. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_CONFIG      {(uint32_t)CHANNEL_0_CONFIG \</span></div><div class="line"><span class="preprocessor">                                , (uint32_t)CHANNEL_1_CONFIG \</span></div><div class="line"><span class="preprocessor">                                , (uint32_t)CHANNEL_2_CONFIG \</span></div><div class="line"><span class="preprocessor">                                , 0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL} </span><span class="comment">/* Channels 3 through 15 are unconfigured. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define MUX_SWITCH          (CY_SAR_MUX_FW_P0_VPLUS         </span><span class="comment">/* Close switch between Vplus and SARMUX Pin 0 for Channels 0 and 2. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_P1_VPLUS        </span><span class="comment">/* Close switch between Vplus and SARMUX Pin 1 for Channel 1. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_P1_VMINUS       </span><span class="comment">/* Close switch between Vmius and SARMUX Pin 1 for Channel 2. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_VSSA_VMINUS)    </span><span class="comment">/* Close switch between Vminus and VSSA for single-ended channels 0 and 1. */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define MUX_SWITCH_SQ_CTRL  (CY_SAR_MUX_SQ_CTRL_P0          </span><span class="comment">/* Enable SARSEQ control of SARMUX Pin 0 switch. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_SQ_CTRL_P1         </span><span class="comment">/* Enable SARSEQ control of SARMUX Pin 1. */</span><span class="preprocessor">  \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_SQ_CTRL_VSSA)      </span><span class="comment">/* Enable SARSEQ control of VSSA switch. */</span><span class="preprocessor"> </span></div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_sarmux_ctb"></a>
Input from CTB output visa SARBUS0/1</h2>
<p>The following figure and code snippet show how the two opamp outputs from the CTB are connected to the SARADC as separate single-ended channels and as a differential-pair channel. Note that separate function calls are needed to configure and enable the opamps, perform required analog routing, and enable SARSEQ control of the switches contained in the CTB.</p>
<div class="image">
<img src="sar_sarmux_ctb.png" alt="sar_sarmux_ctb.png"/>
</div>
<div class="fragment"><div class="line">    <span class="comment">/* Check the device TRM for the CTB block presence */</span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_EN          7u</span></div><div class="line"><span class="preprocessor">    #define CHANNEL_0_CONFIG    ((uint32_t)CY_SAR_CHAN_SINGLE_ENDED           </span><span class="comment">/* Single-ended channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1         </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_CTB0         </span><span class="comment">/* Use CTB0 output. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_2)       </span><span class="comment">/* Use Pin address 2 for Opamp0 of CTB0. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_1_CONFIG    ((uint32_t)CY_SAR_CHAN_SINGLE_ENDED           </span><span class="comment">/* Single-ended channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1         </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_CTB0         </span><span class="comment">/* Use CTB0 output. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_3)       </span><span class="comment">/* Use Pin address 3 for Opamp1 of CTB0. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_2_CONFIG    ((uint32_t)CY_SAR_CHAN_DIFFERENTIAL_PAIRED    </span><span class="comment">/* Differential paired channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1         </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_CTB0         </span><span class="comment">/* Use CTB0 outputs. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_2)       </span><span class="comment">/* Use Opamp0 (pin address 2) for Vplus and Opamp1 (pin address 3) for Vminus. Note, differential paired input. */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define CHANNEL_CONFIG      {(uint32_t)CHANNEL_0_CONFIG \</span></div><div class="line"><span class="preprocessor">                                ,(uint32_t)CHANNEL_1_CONFIG \</span></div><div class="line"><span class="preprocessor">                                ,(uint32_t)CHANNEL_2_CONFIG \</span></div><div class="line"><span class="preprocessor">                                ,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL} </span><span class="comment">/* Channels 3 through 15 are unconfigured. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define MUX_SWITCH          (CY_SAR_MUX_FW_SARBUS0_VPLUS        </span><span class="comment">/* Close switch between Vplus and SARBUS0 for Channels 0, 1, and 2. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_SARBUS1_VMINUS      </span><span class="comment">/* Close switch between Vminus and SARBUS1 for Channel 2. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_VSSA_VMINUS)        </span><span class="comment">/* Close switch between Vminus and VSSA for single-ended Channel 0. */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define MUX_SWITCH_SQ_CTRL  (CY_SAR_MUX_SQ_CTRL_SARBUS0         </span><span class="comment">/* Enable SARSEQ control of SARBUS0 switch. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_SQ_CTRL_SARBUS1        </span><span class="comment">/* Enable SARSEQ control of SARBUS1 switch. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_SQ_CTRL_VSSA)          </span><span class="comment">/* Enable SARSEQ control of VSSA switch. */</span><span class="preprocessor"> </span></div><div class="line">    </div><div class="line">    <span class="comment">/* Configure both opamps in CTB for 1x mode. */</span></div><div class="line">    (void) <a class="code" href="group__group__ctb__functions__init.html#ga7bdb789cecd993b6871bc3e31a239473">Cy_CTB_FastInit</a>(CTBM0, &amp;<a class="code" href="group__group__ctb__globals.html#ga4a8e8b6be10950b49f8972996ac93189">Cy_CTB_Fast_Opamp0_Opamp1x</a>, &amp;<a class="code" href="group__group__ctb__globals.html#ga09d24f5970ad021c2dabd7db05041c0e">Cy_CTB_Fast_Opamp1_Opamp1x</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Configure Opamp0 as a follower with Pin 0 of the CTB port as the input. */</span></div><div class="line">    <a class="code" href="group__group__ctb__functions__switches.html#ga63ec666c26a24b2668124d7ddb69d0d3">Cy_CTB_SetAnalogSwitch</a>(CTBM0, <a class="code" href="group__group__ctb__enums.html#ggaec6e363ff07a3f06e9e4f1c709c1574ea50c28d673af60be66d7e4a4902dbabd3">CY_CTB_SWITCH_OA0_SW</a>, <a class="code" href="group__group__ctb__enums.html#gga489ce541855b5cc316c20a7f801b068ca1793d12de89225c8c03687658c63df3a">CY_CTB_SW_OA0_NEG_OUT_MASK</a> | <a class="code" href="group__group__ctb__enums.html#gga489ce541855b5cc316c20a7f801b068caf66ad18756866b4ee3f3cd2da7b0fcc0">CY_CTB_SW_OA0_POS_PIN0_MASK</a>, <a class="code" href="group__group__ctb__enums.html#ggac8acf16f6a93889e58b75b4815fe28e1ae2c904113408e3b49060ed262c68b296">CY_CTB_SWITCH_CLOSE</a>);</div><div class="line">    <a class="code" href="group__group__ctb__functions__switches.html#ga63ec666c26a24b2668124d7ddb69d0d3">Cy_CTB_SetAnalogSwitch</a>(CTBM0, <a class="code" href="group__group__ctb__enums.html#ggaec6e363ff07a3f06e9e4f1c709c1574ea3adb0e2bc252a87689056cfcb7331717">CY_CTB_SWITCH_CTD_SW</a>, <a class="code" href="group__group__ctb__enums.html#ggaf0495f79031c0cac37acdb7830cb0149aff93f7d60121d0d0f05f6ed9d043c878">CY_CTB_SW_CTD_CHOLD_OA0_POS_ISOLATE_MASK</a>, <a class="code" href="group__group__ctb__enums.html#ggac8acf16f6a93889e58b75b4815fe28e1ae2c904113408e3b49060ed262c68b296">CY_CTB_SWITCH_CLOSE</a>);</div><div class="line">    <a class="code" href="group__group__ctb__functions__switches.html#ga63ec666c26a24b2668124d7ddb69d0d3">Cy_CTB_SetAnalogSwitch</a>(CTBM0, <a class="code" href="group__group__ctb__enums.html#ggaec6e363ff07a3f06e9e4f1c709c1574ea50c28d673af60be66d7e4a4902dbabd3">CY_CTB_SWITCH_OA0_SW</a>, <a class="code" href="group__group__ctb__enums.html#gga489ce541855b5cc316c20a7f801b068cafaf7c4f189fd00caeff0e2dedca7baee">CY_CTB_SW_OA0_OUT_SARBUS0_MASK</a>, <a class="code" href="group__group__ctb__enums.html#ggac8acf16f6a93889e58b75b4815fe28e1ae2c904113408e3b49060ed262c68b296">CY_CTB_SWITCH_CLOSE</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Configure Opamp1 as a follower with Pin 7 of the CTB port as the input. */</span></div><div class="line">    <a class="code" href="group__group__ctb__functions__switches.html#ga63ec666c26a24b2668124d7ddb69d0d3">Cy_CTB_SetAnalogSwitch</a>(CTBM0, <a class="code" href="group__group__ctb__enums.html#ggaec6e363ff07a3f06e9e4f1c709c1574ea298181a09a72b4991fd65bdc2bed53b0">CY_CTB_SWITCH_OA1_SW</a>, <a class="code" href="group__group__ctb__enums.html#gga2d6abb7e9f8fb4e7c41bf1480d829eebae1dc2638caf2ff2b7841c2e798c9b880">CY_CTB_SW_OA1_NEG_OUT_MASK</a> | <a class="code" href="group__group__ctb__enums.html#gga2d6abb7e9f8fb4e7c41bf1480d829eebafa644eda36074088cb30c791bd29cde4">CY_CTB_SW_OA1_POS_PIN7_MASK</a>, <a class="code" href="group__group__ctb__enums.html#ggac8acf16f6a93889e58b75b4815fe28e1ae2c904113408e3b49060ed262c68b296">CY_CTB_SWITCH_CLOSE</a>);</div><div class="line">    <a class="code" href="group__group__ctb__functions__switches.html#ga63ec666c26a24b2668124d7ddb69d0d3">Cy_CTB_SetAnalogSwitch</a>(CTBM0, <a class="code" href="group__group__ctb__enums.html#ggaec6e363ff07a3f06e9e4f1c709c1574ea298181a09a72b4991fd65bdc2bed53b0">CY_CTB_SWITCH_OA1_SW</a>, <a class="code" href="group__group__ctb__enums.html#gga2d6abb7e9f8fb4e7c41bf1480d829eeba80e1de8eb9c2d800a950c00a7150c23d">CY_CTB_SW_OA1_OUT_SARBUS0_MASK</a> | <a class="code" href="group__group__ctb__enums.html#gga2d6abb7e9f8fb4e7c41bf1480d829eeba7ef7667132af7a77c6013ba5de913bca">CY_CTB_SW_OA1_OUT_SARBUS1_MASK</a>, <a class="code" href="group__group__ctb__enums.html#ggac8acf16f6a93889e58b75b4815fe28e1ae2c904113408e3b49060ed262c68b296">CY_CTB_SWITCH_CLOSE</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Enable SARSEQ control of switches inside CTB0. These are the only switches capable of SARSEQ control. */</span></div><div class="line">    <a class="code" href="group__group__ctb__functions__switches.html#ga1071f19b5c0808366de90f17e1e25b57">Cy_CTB_EnableSarSeqCtrl</a>(CTBM0, <a class="code" href="group__group__ctb__enums.html#gga59d4d9205cd078c9cd13da897cff59c9ad1fdbc2f7df70acf1fcfc095b55afbbf">CY_CTB_SW_SEQ_CTRL_D51_D52_D62_MASK</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Enable the opamps. */</span></div><div class="line">    <a class="code" href="group__group__ctb__functions__init.html#gac80e1468e965c0ab15c3b14c15bb6c3d">Cy_CTB_Enable</a>(CTBM0);</div><div class="line">    </div></div><!-- fragment --> <h2><a class="anchor" id="group_sar_sarmux_amuxbus"></a>
Input from other pins through AMUXBUSA/B</h2>
<p>The following figure and code snippet show how two GPIOs on any port through the AMUXBUSA and AMUXBUSB are connected to the SARADC as separate single-ended channels and as a differential-pair channel. Note that separate function calls are needed to route the device pins to the SARMUX. The AMUXBUSes are separated into multiple segments and these segments are connected/disconnected using the AMUX_SPLIT_CTL registers in the HSIOM.</p>
<div class="image">
<img src="sar_sarmux_amuxbus.png" alt="sar_sarmux_amuxbus.png"/>
</div>
<div class="fragment"><div class="line"><span class="preprocessor">    #define CHANNEL_EN          7u</span></div><div class="line"><span class="preprocessor">    #define CHANNEL_0_CONFIG    ((uint32_t)CY_SAR_CHAN_SINGLE_ENDED           </span><span class="comment">/* Single-ended channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1         </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_SARMUX_VIRT  </span><span class="comment">/* Set the Vplus port address to SARMUX_VIRT for the DieTemp. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_2)       </span><span class="comment">/* Set pin address to 2 for AMUXBUSA. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_1_CONFIG    ((uint32_t)CY_SAR_CHAN_SINGLE_ENDED           </span><span class="comment">/* Single-ended channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1         </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_SARMUX_VIRT  </span><span class="comment">/* Set the Vplus port address to SARMUX_VIRT for the DieTemp. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_3)       </span><span class="comment">/* Set pin address to 3 for AMUXBUSB. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_2_CONFIG    ((uint32_t)CY_SAR_CHAN_DIFFERENTIAL_PAIRED    </span><span class="comment">/* Differential paired channel. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_SAMPLE_TIME_1         </span><span class="comment">/* Use Sample Time 1 for 1 us acquisition time. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_POS_PORT_ADDR_SARMUX_VIRT  </span><span class="comment">/* Set the Vplus port address to SARMUX_VIRT for the DieTemp. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | (uint32_t)CY_SAR_CHAN_POS_PIN_ADDR_2)       </span><span class="comment">/* Use AMUXBUSA (pin address 2) for Vplus and AMXBUSB (pin address 3) for Vminus. Note, differential input pair. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define CHANNEL_CONFIG      {(uint32_t)CHANNEL_0_CONFIG \</span></div><div class="line"><span class="preprocessor">                                ,(uint32_t)CHANNEL_1_CONFIG \</span></div><div class="line"><span class="preprocessor">                                ,(uint32_t)CHANNEL_2_CONFIG \</span></div><div class="line"><span class="preprocessor">                                ,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL,0uL} </span><span class="comment">/* Channels 3 through 15 are unconfigured. */</span><span class="preprocessor"></span></div><div class="line">    </div><div class="line"><span class="preprocessor">    #define MUX_SWITCH          (CY_SAR_MUX_FW_AMUXBUSA_VPLUS       </span><span class="comment">/* Close switch between Vplus and AMUXBUSA for Channels 0 and 2. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_AMUXBUSB_VPLUS      </span><span class="comment">/* Close switch between Vplus and AMUXBUSB for Channel 1. */</span><span class="preprocessor">\</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_AMUXBUSB_VMINUS     </span><span class="comment">/* Close switch between Vminus and AMUXMBUS for Channel 2. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_FW_VSSA_VMINUS)        </span><span class="comment">/* Close switch between Vminus and VSSA for single-ended Channels 0 and 1. */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define MUX_SWITCH_SQ_CTRL  (CY_SAR_MUX_SQ_CTRL_AMUXBUSA        </span><span class="comment">/* Enable SARSEQ control of AMUXBUSA switch. */</span><span class="preprocessor"> \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_SQ_CTRL_AMUXBUSB       </span><span class="comment">/* Enable SARSEQ control of AMUXBUSB switch. */</span><span class="preprocessor">  \</span></div><div class="line"><span class="preprocessor">                                | CY_SAR_MUX_SQ_CTRL_VSSA)          </span><span class="comment">/* Enable SARSEQ control of VSSA switch. */</span><span class="preprocessor"> </span></div><div class="line">    </div><div class="line">    <span class="comment">/* Configure pins */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(GPIO_PRT9, 1u, P9_1_AMUXA);    <span class="comment">/* Connect P9_1 to AMUXBUSA. */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(GPIO_PRT9, 2u, P9_2_AMUXB);    <span class="comment">/* Connect P9_2 to AMUXBUSB. */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Set drive mode of P9_1 and P9_2 to analog high-z. */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(GPIO_PRT9, 1u, <a class="code" href="group__group__gpio__drive_modes.html#gabb81a7da2a4cd1ed6501515f9b6950e8">CY_GPIO_DM_ANALOG</a>);</div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(GPIO_PRT9, 2u, <a class="code" href="group__group__gpio__drive_modes.html#gabb81a7da2a4cd1ed6501515f9b6950e8">CY_GPIO_DM_ANALOG</a>);</div><div class="line">    </div></div><!-- fragment --><p>To connect SARMUX to any other non-dedicated port, you may need to close additional HSIOM switches to route signals through AMUXBUS. For more detail, see the device TRM, AMUX splitting.</p>
<p>The following code snippet is an alternative pin configuration. To connect Port 1 to AMUXBUS, close the left and right switches of AMUX_SPLIT_CTL[1] and AMUX_SPLIT_CTL[6].</p>
<dl class="section warning"><dt>Warning</dt><dd>This snippet shows how to configure pins for CY8C6347BZI-BLD53.</dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Alternative pin configuration */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(GPIO_PRT1, 2u, P1_2_AMUXA);    <span class="comment">/* Connect P1_2 to AMUXBUSA. */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(GPIO_PRT1, 4u, P1_4_AMUXB);    <span class="comment">/* Connect P1_4 to AMUXBUSB. */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Set drive mode of P1_2 and P1_4 to analog high-z. */</span></div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(GPIO_PRT1, 2u, <a class="code" href="group__group__gpio__drive_modes.html#gabb81a7da2a4cd1ed6501515f9b6950e8">CY_GPIO_DM_ANALOG</a>);</div><div class="line">    <a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(GPIO_PRT1, 4u, <a class="code" href="group__group__gpio__drive_modes.html#gabb81a7da2a4cd1ed6501515f9b6950e8">CY_GPIO_DM_ANALOG</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/* To connect the SARMUX to Port 1 requires additional HSIOM switches, AMUX_SPLIT_CTL[1] and AMUX_SPLIT_CTL[6].</span></div><div class="line"><span class="comment">     * See the device TRM about AMUXBUS splitting. */</span></div><div class="line">    HSIOM-&gt;AMUX_SPLIT_CTL[1] = HSIOM_AMUX_SPLIT_CTL_SWITCH_AA_SL_Msk \</div><div class="line">                               | HSIOM_AMUX_SPLIT_CTL_SWITCH_AA_SR_Msk \</div><div class="line">                               | HSIOM_AMUX_SPLIT_CTL_SWITCH_BB_SL_Msk \</div><div class="line">                               | HSIOM_AMUX_SPLIT_CTL_SWITCH_BB_SR_Msk;</div><div class="line">    </div><div class="line">    HSIOM-&gt;AMUX_SPLIT_CTL[6] = HSIOM_AMUX_SPLIT_CTL_SWITCH_AA_SL_Msk \</div><div class="line">                               | HSIOM_AMUX_SPLIT_CTL_SWITCH_AA_SR_Msk \</div><div class="line">                               | HSIOM_AMUX_SPLIT_CTL_SWITCH_BB_SL_Msk \</div><div class="line">                               | HSIOM_AMUX_SPLIT_CTL_SWITCH_BB_SR_Msk;</div><div class="line">    </div></div><!-- fragment --> <h1><a class="anchor" id="group_sar_low_power"></a>
Low Power Support</h1>
<p>This SAR driver provides a callback function to handle power mode transitions. The <a class="el" href="group__group__sar__functions__power.html#ga1a3beac74f3cd40c05cf968f63192b29">Cy_SAR_DeepSleepCallback</a> function ensures that SAR conversions are stopped before Deep Sleep entry. Upon wakeup, the callback enables the hardware and continuous conversions, if previously enabled.</p>
<p>To trigger the callback execution, the callback must be registered before calling <a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca">Cy_SysPm_CpuEnterDeepSleep</a>. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration.</p>
<p>Recall that during configuration of the <a class="el" href="group__group__sar.html#group_sar_init_struct_ctrl">ctrl</a> field, the SARMUX can be configured to remain enabled in Deep Sleep mode. All other blocks (SARADC, REFBUF, and SARSEQ) do not support Deep Sleep mode operation.</p>
<h1><a class="anchor" id="group_sar_more_information"></a>
More Information</h1>
<p>For more information on the SAR ADC subsystem, refer to the technical reference manual (TRM).</p>
<h1><a class="anchor" id="group_sar_MISRA"></a>
MISRA-C Compliance]</h1>
<p>This driver has the following specific deviations:</p>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th>Description of Deviation(s)  </th></tr>
<tr>
<td>11.4 </td><td>Advisory </td><td>A cast should not be performed between a pointer to object type and a different pointer to object type. </td><td>The cy_syspm driver defines the pointer to void in the <a class="el" href="structcy__stc__syspm__callback__params__t.html#a56076e99358e2b7c99681312108b09af">cy_stc_syspm_callback_params_t::base</a> field. This SAR driver implements a Deep Sleep callback conforming to the cy_syspm driver requirements. When the callback is called, the base should point to the <a class="el" href="struct_s_a_r___type.html" title="The struct type definition for the hardware register set contained in the block.  The address of a va...">SAR_Type</a> register address.   </td></tr>
</table>
<h1><a class="anchor" id="group_sar_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.20.3 </td><td>Minor documentation updates. </td><td>Documentation enhancement.  </td></tr>
<tr>
<td>1.20.2 </td><td>Code snippets update. </td><td>PDL infrastructure update, documentation enhancement.  </td></tr>
<tr>
<td>1.20.1 </td><td>Code snippets update. </td><td>PDL infrastructure update, documentation enhancement.  </td></tr>
<tr>
<td rowspan="2">1.20 </td><td>Flattened the organization of the driver source code into the single source directory and the single include directory. </td><td>Driver library directory-structure simplification.  </td></tr>
<tr>
<td>Added register access layer. Use register access macros instead of direct register access using dereferenced pointers. </td><td>Makes register access device-independent, so that the PDL does not need to be recompiled for each supported part number.  </td></tr>
<tr>
<td rowspan="3">1.10 </td><td>Added workaround for parts with out of range CAP_TRIM in Init API. </td><td>Correct CAP_TRIM is necessary achieving specified SAR ADC linearity  </td></tr>
<tr>
<td>Turn off the entire hardware block only if the SARMUX is not enabled for Deep Sleep operation.  </td><td>Improvement of the <a class="el" href="group__group__sar__functions__power.html#ga7f5da233753269fdf05b5745515a7c21">Cy_SAR_DeepSleep</a> flow  </td></tr>
<tr>
<td>Updated "Low Power Support" section to describe registering the Deep Sleep callback. Added parenthesis around logical AND operation in Sleep API. </td><td>Documentation update and clarification  </td></tr>
<tr>
<td>1.0 </td><td>Initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__sar__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__sar__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__sar__globals"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__globals.html">Global Variables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__sar__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__sar__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
