<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Low Level Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__smif__low__level__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Low Level Functions<div class="ingroups"><a class="el" href="group__group__smif.html">SMIF         (Serial Memory Interface)</a> &raquo; <a class="el" href="group__group__smif__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Basic flow for read/write commands using <a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11">Cy_SMIF_TransmitCommand</a>, <a class="el" href="group__group__smif__low__level__functions.html#gae84cdf32e45e492e80dea38f9d3a7586">Cy_SMIF_TransmitData</a>, <a class="el" href="group__group__smif__low__level__functions.html#ga1b365e1400ccd6580533a0c92deb48c7">Cy_SMIF_ReceiveData</a> and <a class="el" href="group__group__smif__low__level__functions.html#gae40a30c84a9a5956d03279b9ee8c3999">Cy_SMIF_SendDummyCycles</a>. </p>
<div class="image">
<img src="smif_1_0_p03_rw_cmd.png" alt="smif_1_0_p03_rw_cmd.png"/>
</div>
<p>The sequence of the PDL functions required in a read or write transaction is: <a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11">Cy_SMIF_TransmitCommand()</a> -&gt; <a class="el" href="group__group__smif__low__level__functions.html#gae40a30c84a9a5956d03279b9ee8c3999">Cy_SMIF_SendDummyCycles()</a> -&gt; <a class="el" href="group__group__smif__low__level__functions.html#ga1b365e1400ccd6580533a0c92deb48c7">Cy_SMIF_ReceiveData()</a> / <a class="el" href="group__group__smif__low__level__functions.html#gae84cdf32e45e492e80dea38f9d3a7586">Cy_SMIF_TransmitData()</a> -&gt; <a class="el" href="group__group__smif__low__level__functions.html#ga58e965697047847ce906329eb6b5341c">Cy_SMIF_BusyCheck()</a>. The address is sent as part of the <a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11" title="This function transmits a command byte followed by a parameter which is typically an address field...">Cy_SMIF_TransmitCommand()</a> function. No separate function call is required. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__smif__functions__syspm__callback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__functions__syspm__callback.html">Low Power Callback</a></td></tr>
<tr class="memdesc:group__group__smif__functions__syspm__callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">The driver supports SysPm callback for Deep Sleep and Hibernate transition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaea2684847f04e2e7e2c85cfe7fd37881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gaea2684847f04e2e7e2c85cfe7fd37881">Cy_SMIF_Init</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="structcy__stc__smif__config__t.html">cy_stc_smif_config_t</a> const *config, uint32_t timeout, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *context)</td></tr>
<tr class="memdesc:gaea2684847f04e2e7e2c85cfe7fd37881"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the SMIF block as a communication block.  <a href="#gaea2684847f04e2e7e2c85cfe7fd37881">More...</a><br /></td></tr>
<tr class="separator:gaea2684847f04e2e7e2c85cfe7fd37881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfff3629c2c649b4eb776e8e98523dda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gacfff3629c2c649b4eb776e8e98523dda">Cy_SMIF_DeInit</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base)</td></tr>
<tr class="memdesc:gacfff3629c2c649b4eb776e8e98523dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function de-initializes the SMIF block to default values.  <a href="#gacfff3629c2c649b4eb776e8e98523dda">More...</a><br /></td></tr>
<tr class="separator:gacfff3629c2c649b4eb776e8e98523dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df033f6664a2b41cf044f2c4ec60817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga1df033f6664a2b41cf044f2c4ec60817">Cy_SMIF_SetDataSelect</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="group__group__smif__enums.html#gad776a0db9224477ab865254a32d9e312">cy_en_smif_slave_select_t</a> slaveSelect, <a class="el" href="group__group__smif__enums.html#ga6d9ba2ef785b94cf542c573a51a0eb58">cy_en_smif_data_select_t</a> dataSelect)</td></tr>
<tr class="memdesc:ga1df033f6664a2b41cf044f2c4ec60817"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the data select option for a specific slave.  <a href="#ga1df033f6664a2b41cf044f2c4ec60817">More...</a><br /></td></tr>
<tr class="separator:ga1df033f6664a2b41cf044f2c4ec60817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957f49ed7cf091e9b9d736ee589f2583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga957f49ed7cf091e9b9d736ee589f2583">Cy_SMIF_SetMode</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="group__group__smif__enums.html#ga2baa7c37d2cedf2e2c837facc753ab5d">cy_en_smif_mode_t</a> mode)</td></tr>
<tr class="memdesc:ga957f49ed7cf091e9b9d736ee589f2583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mode of operation for the SMIF.  <a href="#ga957f49ed7cf091e9b9d736ee589f2583">More...</a><br /></td></tr>
<tr class="separator:ga957f49ed7cf091e9b9d736ee589f2583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d11d9c308bd61aa0050ed6cec4c734a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga2baa7c37d2cedf2e2c837facc753ab5d">cy_en_smif_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga9d11d9c308bd61aa0050ed6cec4c734a">Cy_SMIF_GetMode</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base)</td></tr>
<tr class="memdesc:ga9d11d9c308bd61aa0050ed6cec4c734a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the mode of operation for the SMIF.  <a href="#ga9d11d9c308bd61aa0050ed6cec4c734a">More...</a><br /></td></tr>
<tr class="separator:ga9d11d9c308bd61aa0050ed6cec4c734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5abea630fca93c72faece8b23549cd11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11">Cy_SMIF_TransmitCommand</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint8_t cmd, <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a> cmdTxfrWidth, uint8_t const cmdParam[], uint32_t paramSize, <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a> paramTxfrWidth, <a class="el" href="group__group__smif__enums.html#gad776a0db9224477ab865254a32d9e312">cy_en_smif_slave_select_t</a> slaveSelect, uint32_t completeTxfr, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga5abea630fca93c72faece8b23549cd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function transmits a command byte followed by a parameter which is typically an address field.  <a href="#ga5abea630fca93c72faece8b23549cd11">More...</a><br /></td></tr>
<tr class="separator:ga5abea630fca93c72faece8b23549cd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae84cdf32e45e492e80dea38f9d3a7586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gae84cdf32e45e492e80dea38f9d3a7586">Cy_SMIF_TransmitData</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint8_t const *txBuffer, uint32_t size, <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a> transferWidth, <a class="el" href="group__group__smif__data__structures.html#ga13688dde62e8977a11ab69cf6b2c39b5">cy_smif_event_cb_t</a> TxCompleteCb, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *context)</td></tr>
<tr class="memdesc:gae84cdf32e45e492e80dea38f9d3a7586"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to transmit data using the SMIF interface.  <a href="#gae84cdf32e45e492e80dea38f9d3a7586">More...</a><br /></td></tr>
<tr class="separator:gae84cdf32e45e492e80dea38f9d3a7586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ce9afb095c14426f272a75ed51c9be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga60ce9afb095c14426f272a75ed51c9be">Cy_SMIF_TransmitDataBlocking</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint8_t const *txBuffer, uint32_t size, <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a> transferWidth, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga60ce9afb095c14426f272a75ed51c9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements the transmit data phase in the memory command.  <a href="#ga60ce9afb095c14426f272a75ed51c9be">More...</a><br /></td></tr>
<tr class="separator:ga60ce9afb095c14426f272a75ed51c9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b365e1400ccd6580533a0c92deb48c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga1b365e1400ccd6580533a0c92deb48c7">Cy_SMIF_ReceiveData</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint8_t *rxBuffer, uint32_t size, <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a> transferWidth, <a class="el" href="group__group__smif__data__structures.html#ga13688dde62e8977a11ab69cf6b2c39b5">cy_smif_event_cb_t</a> RxCompleteCb, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1b365e1400ccd6580533a0c92deb48c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements the receive data phase in the memory command.  <a href="#ga1b365e1400ccd6580533a0c92deb48c7">More...</a><br /></td></tr>
<tr class="separator:ga1b365e1400ccd6580533a0c92deb48c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c3033ff812c2342cea0657096a46b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga93c3033ff812c2342cea0657096a46b9">Cy_SMIF_ReceiveDataBlocking</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint8_t *rxBuffer, uint32_t size, <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a> transferWidth, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga93c3033ff812c2342cea0657096a46b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements the receive data phase in the memory command.  <a href="#ga93c3033ff812c2342cea0657096a46b9">More...</a><br /></td></tr>
<tr class="separator:ga93c3033ff812c2342cea0657096a46b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40a30c84a9a5956d03279b9ee8c3999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gae40a30c84a9a5956d03279b9ee8c3999">Cy_SMIF_SendDummyCycles</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint32_t cycles)</td></tr>
<tr class="memdesc:gae40a30c84a9a5956d03279b9ee8c3999"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends dummy-clock cycles.  <a href="#gae40a30c84a9a5956d03279b9ee8c3999">More...</a><br /></td></tr>
<tr class="separator:gae40a30c84a9a5956d03279b9ee8c3999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1a6bbecbb57233ea612d39d53b8f4c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga9b1a6bbecbb57233ea612d39d53b8f4c">Cy_SMIF_GetTransferStatus</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga9b1a6bbecbb57233ea612d39d53b8f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the status of the transfer.  <a href="#ga9b1a6bbecbb57233ea612d39d53b8f4c">More...</a><br /></td></tr>
<tr class="separator:ga9b1a6bbecbb57233ea612d39d53b8f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5428ca682fd56b837a1a3763fc2596b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga5428ca682fd56b837a1a3763fc2596b8">Cy_SMIF_Enable</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *context)</td></tr>
<tr class="memdesc:ga5428ca682fd56b837a1a3763fc2596b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the operation of the SMIF block.  <a href="#ga5428ca682fd56b837a1a3763fc2596b8">More...</a><br /></td></tr>
<tr class="separator:ga5428ca682fd56b837a1a3763fc2596b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318b7c99ac2ba33e833cb4a0ab675e17"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga318b7c99ac2ba33e833cb4a0ab675e17">Cy_SMIF_Disable</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base)</td></tr>
<tr class="memdesc:ga318b7c99ac2ba33e833cb4a0ab675e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the operation of the SMIF block.  <a href="#ga318b7c99ac2ba33e833cb4a0ab675e17">More...</a><br /></td></tr>
<tr class="separator:ga318b7c99ac2ba33e833cb4a0ab675e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74985772e86b44ab99a95ea467f6245"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gae74985772e86b44ab99a95ea467f6245">Cy_SMIF_SetInterruptMask</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint32_t interrupt)</td></tr>
<tr class="memdesc:gae74985772e86b44ab99a95ea467f6245"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set an interrupt mask for the SMIF Interrupt.  <a href="#gae74985772e86b44ab99a95ea467f6245">More...</a><br /></td></tr>
<tr class="separator:gae74985772e86b44ab99a95ea467f6245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83bbab71bc76fc372b4c8ad363e2512d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga83bbab71bc76fc372b4c8ad363e2512d">Cy_SMIF_GetInterruptMask</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base)</td></tr>
<tr class="memdesc:ga83bbab71bc76fc372b4c8ad363e2512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read an interrupt mask for the SMIF Interrupt.  <a href="#ga83bbab71bc76fc372b4c8ad363e2512d">More...</a><br /></td></tr>
<tr class="separator:ga83bbab71bc76fc372b4c8ad363e2512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eba5a1edd402a8170d0d5649dda98c4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga6eba5a1edd402a8170d0d5649dda98c4">Cy_SMIF_GetInterruptStatusMasked</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base)</td></tr>
<tr class="memdesc:ga6eba5a1edd402a8170d0d5649dda98c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read an active masked interrupt.  <a href="#ga6eba5a1edd402a8170d0d5649dda98c4">More...</a><br /></td></tr>
<tr class="separator:ga6eba5a1edd402a8170d0d5649dda98c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga412a309c2929869dea85c59a62067085"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga412a309c2929869dea85c59a62067085">Cy_SMIF_GetInterruptStatus</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base)</td></tr>
<tr class="memdesc:ga412a309c2929869dea85c59a62067085"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read an active interrupt.  <a href="#ga412a309c2929869dea85c59a62067085">More...</a><br /></td></tr>
<tr class="separator:ga412a309c2929869dea85c59a62067085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb165119cb003e0e69d6fcf39be65033"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gadb165119cb003e0e69d6fcf39be65033">Cy_SMIF_SetInterrupt</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint32_t interrupt)</td></tr>
<tr class="memdesc:gadb165119cb003e0e69d6fcf39be65033"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set an interrupt source.  <a href="#gadb165119cb003e0e69d6fcf39be65033">More...</a><br /></td></tr>
<tr class="separator:gadb165119cb003e0e69d6fcf39be65033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728aaee38b9821b954d3a56e53787fb1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga728aaee38b9821b954d3a56e53787fb1">Cy_SMIF_ClearInterrupt</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint32_t interrupt)</td></tr>
<tr class="memdesc:ga728aaee38b9821b954d3a56e53787fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to clear an interrupt source.  <a href="#ga728aaee38b9821b954d3a56e53787fb1">More...</a><br /></td></tr>
<tr class="separator:ga728aaee38b9821b954d3a56e53787fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b71a3308f1a654b2fc583033761a7a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gac9b71a3308f1a654b2fc583033761a7a">Cy_SMIF_SetTxFifoTriggerLevel</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint32_t level)</td></tr>
<tr class="memdesc:gac9b71a3308f1a654b2fc583033761a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set a trigger level for the TX FIFO.  <a href="#gac9b71a3308f1a654b2fc583033761a7a">More...</a><br /></td></tr>
<tr class="separator:gac9b71a3308f1a654b2fc583033761a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac31d93c962f0ff359932ac8ad6a4baec"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gac31d93c962f0ff359932ac8ad6a4baec">Cy_SMIF_SetRxFifoTriggerLevel</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint32_t level)</td></tr>
<tr class="memdesc:gac31d93c962f0ff359932ac8ad6a4baec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set a trigger level for the RX FIFO.  <a href="#gac31d93c962f0ff359932ac8ad6a4baec">More...</a><br /></td></tr>
<tr class="separator:gac31d93c962f0ff359932ac8ad6a4baec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e0da7a14fb7bdc9ee054f87239b38e7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga0e0da7a14fb7bdc9ee054f87239b38e7">Cy_SMIF_GetCmdFifoStatus</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base)</td></tr>
<tr class="memdesc:ga0e0da7a14fb7bdc9ee054f87239b38e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the status of the CMD FIFO.  <a href="#ga0e0da7a14fb7bdc9ee054f87239b38e7">More...</a><br /></td></tr>
<tr class="separator:ga0e0da7a14fb7bdc9ee054f87239b38e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10662c147b39a1b71a2f2221b0e3f59f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga10662c147b39a1b71a2f2221b0e3f59f">Cy_SMIF_GetTxFifoStatus</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base)</td></tr>
<tr class="memdesc:ga10662c147b39a1b71a2f2221b0e3f59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the status of the TX FIFO.  <a href="#ga10662c147b39a1b71a2f2221b0e3f59f">More...</a><br /></td></tr>
<tr class="separator:ga10662c147b39a1b71a2f2221b0e3f59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e4c5a29449fabe546b4770061f31b7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga54e4c5a29449fabe546b4770061f31b7">Cy_SMIF_GetRxFifoStatus</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base)</td></tr>
<tr class="memdesc:ga54e4c5a29449fabe546b4770061f31b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the status of the RX FIFO.  <a href="#ga54e4c5a29449fabe546b4770061f31b7">More...</a><br /></td></tr>
<tr class="separator:ga54e4c5a29449fabe546b4770061f31b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a32005b94591adb8fd7daa1068ddbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga91a32005b94591adb8fd7daa1068ddbc">Cy_SMIF_Encrypt</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, uint32_t address, uint8_t data[], uint32_t size, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga91a32005b94591adb8fd7daa1068ddbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the Encryption engine to create an encrypted result when the input, key and data arrays are provided.  <a href="#ga91a32005b94591adb8fd7daa1068ddbc">More...</a><br /></td></tr>
<tr class="separator:ga91a32005b94591adb8fd7daa1068ddbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e965697047847ce906329eb6b5341c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga58e965697047847ce906329eb6b5341c">Cy_SMIF_BusyCheck</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *base)</td></tr>
<tr class="memdesc:ga58e965697047847ce906329eb6b5341c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the status of the IP block (False - not busy, True - busy).  <a href="#ga58e965697047847ce906329eb6b5341c">More...</a><br /></td></tr>
<tr class="separator:ga58e965697047847ce906329eb6b5341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedbec6f968745b8f594dd4b32e91ceba"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gaedbec6f968745b8f594dd4b32e91ceba">Cy_SMIF_Interrupt</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *context)</td></tr>
<tr class="memdesc:gaedbec6f968745b8f594dd4b32e91ceba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Interrupt Service Routine for the SMIF.  <a href="#gaedbec6f968745b8f594dd4b32e91ceba">More...</a><br /></td></tr>
<tr class="separator:gaedbec6f968745b8f594dd4b32e91ceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f06f761c260849fa8e37d7a3f858dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga28f06f761c260849fa8e37d7a3f858dc">Cy_SMIF_CacheEnable</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a> cacheType)</td></tr>
<tr class="memdesc:ga28f06f761c260849fa8e37d7a3f858dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to enable the fast cache, the slow cache or both.  <a href="#ga28f06f761c260849fa8e37d7a3f858dc">More...</a><br /></td></tr>
<tr class="separator:ga28f06f761c260849fa8e37d7a3f858dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb0c1e80c19ef607a1efc70df6818ccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gacb0c1e80c19ef607a1efc70df6818ccb">Cy_SMIF_CacheDisable</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a> cacheType)</td></tr>
<tr class="memdesc:gacb0c1e80c19ef607a1efc70df6818ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to disable the fast cache, the slow cache or both.  <a href="#gacb0c1e80c19ef607a1efc70df6818ccb">More...</a><br /></td></tr>
<tr class="separator:gacb0c1e80c19ef607a1efc70df6818ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff445110c019e30b942fb87878b32c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga0ff445110c019e30b942fb87878b32c7">Cy_SMIF_CachePrefetchingEnable</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a> cacheType)</td></tr>
<tr class="memdesc:ga0ff445110c019e30b942fb87878b32c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to enable pre-fetching for the fast cache, the slow cache or both.  <a href="#ga0ff445110c019e30b942fb87878b32c7">More...</a><br /></td></tr>
<tr class="separator:ga0ff445110c019e30b942fb87878b32c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb34fe2a90c311a2e1fa23c66a21c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#gabbb34fe2a90c311a2e1fa23c66a21c81">Cy_SMIF_CachePrefetchingDisable</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a> cacheType)</td></tr>
<tr class="memdesc:gabbb34fe2a90c311a2e1fa23c66a21c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to disable pre-fetching for the fast cache, the slow cache or both.  <a href="#gabbb34fe2a90c311a2e1fa23c66a21c81">More...</a><br /></td></tr>
<tr class="separator:gabbb34fe2a90c311a2e1fa23c66a21c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72240c0ce8307c50b65c4fca45c9cd30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__smif__low__level__functions.html#ga72240c0ce8307c50b65c4fca45c9cd30">Cy_SMIF_CacheInvalidate</a> (<a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *base, <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a> cacheType)</td></tr>
<tr class="memdesc:ga72240c0ce8307c50b65c4fca45c9cd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to invalidate/clear the fast cache, the slow cache or both.  <a href="#ga72240c0ce8307c50b65c4fca45c9cd30">More...</a><br /></td></tr>
<tr class="separator:ga72240c0ce8307c50b65c4fca45c9cd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaea2684847f04e2e7e2c85cfe7fd37881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea2684847f04e2e7e2c85cfe7fd37881">&#9670;&nbsp;</a></span>Cy_SMIF_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__config__t.html">cy_stc_smif_config_t</a> const *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the SMIF block as a communication block. </p>
<p>The user must ensure that the SMIF interrupt is disabled while this function is called. Enabling the interrupts can lead to triggering in the middle of the initialization operation, which can lead to erroneous initialization.</p>
<p>As parameters, this function takes the SMIF register base address and a context structure along with the configuration needed for the SMIF block, stored in a config</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">config</td><td>Passes a configuration structure that configures the SMIF block for operation.</td></tr>
    <tr><td class="paramname">timeout</td><td>A timeout in microseconds for blocking APIs in use.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Make sure that the interrupts are initialized and disabled.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacfff3629c2c649b4eb776e8e98523dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfff3629c2c649b4eb776e8e98523dda">&#9670;&nbsp;</a></span>Cy_SMIF_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SMIF_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function de-initializes the SMIF block to default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The SMIF must be disabled before calling the function. Call <a class="el" href="group__group__smif__low__level__functions.html#ga318b7c99ac2ba33e833cb4a0ab675e17">Cy_SMIF_Disable</a> </dd></dl>

</div>
</div>
<a id="ga1df033f6664a2b41cf044f2c4ec60817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1df033f6664a2b41cf044f2c4ec60817">&#9670;&nbsp;</a></span>Cy_SMIF_SetDataSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SMIF_SetDataSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gad776a0db9224477ab865254a32d9e312">cy_en_smif_slave_select_t</a>&#160;</td>
          <td class="paramname"><em>slaveSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#ga6d9ba2ef785b94cf542c573a51a0eb58">cy_en_smif_data_select_t</a>&#160;</td>
          <td class="paramname"><em>dataSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the data select option for a specific slave. </p>
<p>The selection provides pre-set combinations for connecting the SMIF data lines to the GPIOs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">slaveSelect</td><td>The slave device ID. This number is either CY_SMIF_SLAVE_SELECT_0 or CY_SMIF_SLAVE_SELECT_1 or CY_SMIF_SLAVE_SELECT_2 or CY_SMIF_SLAVE_SELECT_3 (<a class="el" href="group__group__smif__enums.html#gad776a0db9224477ab865254a32d9e312">cy_en_smif_slave_select_t</a>). It defines the slave select line to be used during the transmission.</td></tr>
    <tr><td class="paramname">dataSelect</td><td>This parameter selects the data select option. <a class="el" href="group__group__smif__enums.html#ga6d9ba2ef785b94cf542c573a51a0eb58">cy_en_smif_data_select_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga957f49ed7cf091e9b9d736ee589f2583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga957f49ed7cf091e9b9d736ee589f2583">&#9670;&nbsp;</a></span>Cy_SMIF_SetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SMIF_SetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#ga2baa7c37d2cedf2e2c837facc753ab5d">cy_en_smif_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the mode of operation for the SMIF. </p>
<p>The mode of operation can be the XIP mode where the slave devices are mapped as memories and are directly accessed from the PSoC register map. In the MMIO mode, the SMIF block acts as a simple SPI engine.</p>
<dl class="section note"><dt>Note</dt><dd>Interrupt and triggers and not working in XIP mode, see TRM for details</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">mode</td><td>The mode of the SMIF operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d11d9c308bd61aa0050ed6cec4c734a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d11d9c308bd61aa0050ed6cec4c734a">&#9670;&nbsp;</a></span>Cy_SMIF_GetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga2baa7c37d2cedf2e2c837facc753ab5d">cy_en_smif_mode_t</a> Cy_SMIF_GetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the mode of operation for the SMIF. </p>
<p>The mode of operation can be the XIP mode where the slave devices are mapped as memories and are directly accessed from the PSoC register map. In the MMIO mode, the SMIF block acts as a simple SPI engine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mode of SMIF operation (see <a class="el" href="group__group__smif__enums.html#ga2baa7c37d2cedf2e2c837facc753ab5d">cy_en_smif_mode_t</a>). </dd></dl>

</div>
</div>
<a id="ga5abea630fca93c72faece8b23549cd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5abea630fca93c72faece8b23549cd11">&#9670;&nbsp;</a></span>Cy_SMIF_TransmitCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_TransmitCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>&#160;</td>
          <td class="paramname"><em>cmdTxfrWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>cmdParam</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>paramSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>&#160;</td>
          <td class="paramname"><em>paramTxfrWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gad776a0db9224477ab865254a32d9e312">cy_en_smif_slave_select_t</a>&#160;</td>
          <td class="paramname"><em>slaveSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>completeTxfr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function transmits a command byte followed by a parameter which is typically an address field. </p>
<p>The transfer is implemented using the TX FIFO. This function also asserts the slave select line. A command to a memory device generally starts with a command byte transmission. This function sets up the slave lines for the rest of the command structure. The <a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11">Cy_SMIF_TransmitCommand</a> is called before <a class="el" href="group__group__smif__low__level__functions.html#gae84cdf32e45e492e80dea38f9d3a7586">Cy_SMIF_TransmitData</a> or <a class="el" href="group__group__smif__low__level__functions.html#ga1b365e1400ccd6580533a0c92deb48c7">Cy_SMIF_ReceiveData</a> is called. When enabled, the completeTxfr parameter in the function will de-assert the slave select line at the end of the function execution.</p>
<dl class="section note"><dt>Note</dt><dd>This function blocks until all the command and associated parameters have been transmitted over the SMIF block or timeout expire.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">cmd</td><td>The command byte to be transmitted.</td></tr>
    <tr><td class="paramname">cmdTxfrWidth</td><td>The width of command byte transfer <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>.</td></tr>
    <tr><td class="paramname">cmdParam</td><td>This is the pointer to an array that has bytes to be transmitted after the command byte. Typically, this field has the address bytes associated with the memory command.</td></tr>
    <tr><td class="paramname">paramSize</td><td>The size of the cmdParam array.</td></tr>
    <tr><td class="paramname">paramTxfrWidth</td><td>The width of parameter transfer <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>.</td></tr>
    <tr><td class="paramname">slaveSelect</td><td>Denotes the number of the slave device to which the transfer is made. (0, 1, 2 or 4 - the bit defines which slave to enable) Two-bit enable is possible only for the double quad SPI mode.</td></tr>
    <tr><td class="paramname">completeTxfr</td><td>Specifies if the slave select line must be de-asserted after transferring the last byte in the parameter array. Typically, this field is set to 0 when this function succeed through <a class="el" href="group__group__smif__low__level__functions.html#gae84cdf32e45e492e80dea38f9d3a7586">Cy_SMIF_TransmitData</a> or <a class="el" href="group__group__smif__low__level__functions.html#ga1b365e1400ccd6580533a0c92deb48c7">Cy_SMIF_ReceiveData</a>.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of the command transmit.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41acec88a667ae4eb2db47acfc63492ac7d">CY_SMIF_EXCEED_TIMEOUT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Check <a class="el" href="group__group__smif.html#group_smif_usage_rules">Rules for PSoC6 QSPI/SMIF Block Usage</a> for any usage restriction </dd></dl>

</div>
</div>
<a id="gae84cdf32e45e492e80dea38f9d3a7586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae84cdf32e45e492e80dea38f9d3a7586">&#9670;&nbsp;</a></span>Cy_SMIF_TransmitData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_TransmitData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>txBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>&#160;</td>
          <td class="paramname"><em>transferWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__data__structures.html#ga13688dde62e8977a11ab69cf6b2c39b5">cy_smif_event_cb_t</a>&#160;</td>
          <td class="paramname"><em>TxCompleteCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to transmit data using the SMIF interface. </p>
<p>This function uses the TX Data FIFO to implement the transmit functionality. The function sets up an interrupt to trigger the TX Data FIFO and uses that interrupt to fill the TX Data FIFO until all the data is transmitted. At the end of the transmission, the TxCompleteCb is executed.</p>
<dl class="section note"><dt>Note</dt><dd>This function is to be preceded by <a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11">Cy_SMIF_TransmitCommand</a> where the slave select is selected. The slave is de-asserted at the end of a transmit. The function triggers the transfer and the transfer itself utilizes the interrupt for FIFO operations in the background. Thus, frequent interrupts will be executed after this function is triggered. Since this API is non-blocking and sets up the interrupt to act on the data FIFO, ensure there will be no another instance of the function called before the current instance has completed execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">txBuffer</td><td>The pointer to the data to be transferred. If this pointer is a NULL, then the function does not enable the interrupt. This use case is typically used when the FIFO is handled outside the interrupt and is managed in either a polling-based code or a DMA. The user would handle the FIFO management in a DMA or a polling-based code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the user provides a NULL pointer in this function and does not handle the FIFO transaction, this could either stall or timeout the operation. The transfer statuses returned by <a class="el" href="group__group__smif__low__level__functions.html#ga9b1a6bbecbb57233ea612d39d53b8f4c">Cy_SMIF_GetTransferStatus</a> are no longer valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of txBuffer. Must be &gt; 0 and not greater than 65536.</td></tr>
    <tr><td class="paramname">transferWidth</td><td>The width of transfer <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>.</td></tr>
    <tr><td class="paramname">TxCompleteCb</td><td>The callback executed at the end of a transmission. NULL interpreted as no callback.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of a transmission.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a9785ad5aefcfc44b2f342035e2eb141a">CY_SMIF_CMD_FIFO_FULL</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga60ce9afb095c14426f272a75ed51c9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60ce9afb095c14426f272a75ed51c9be">&#9670;&nbsp;</a></span>Cy_SMIF_TransmitDataBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_TransmitDataBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>txBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>&#160;</td>
          <td class="paramname"><em>transferWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements the transmit data phase in the memory command. </p>
<p>The data is transmitted using the Tx Data FIFO and the TX_COUNT command. This function blocks until completion. The function does not use the interrupts and will use CPU to monitor the FIFO status and move data accordingly. The function returns only on completion.</p>
<dl class="section note"><dt>Note</dt><dd>Since this API is blocking, ensure that other transfers finished and it will not be called during non-blocking transfer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">txBuffer</td><td>The pointer to the data to be transferred. If this pointer is a NULL, then the function does not fill TX_FIFO. The user would handle the FIFO management in a DMA or a polling-based code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the user provides a NULL pointer in this function and does not handle the FIFO transaction, this could either stall or timeout the operation. The transfer statuses returned by <a class="el" href="group__group__smif__low__level__functions.html#ga9b1a6bbecbb57233ea612d39d53b8f4c">Cy_SMIF_GetTransferStatus</a> are no longer valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of txBuffer. Must be &gt; 0 and not greater than 65536.</td></tr>
    <tr><td class="paramname">transferWidth</td><td>The width of transfer <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of a transmission.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a9785ad5aefcfc44b2f342035e2eb141a">CY_SMIF_CMD_FIFO_FULL</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41acec88a667ae4eb2db47acfc63492ac7d">CY_SMIF_EXCEED_TIMEOUT</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1b365e1400ccd6580533a0c92deb48c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b365e1400ccd6580533a0c92deb48c7">&#9670;&nbsp;</a></span>Cy_SMIF_ReceiveData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_ReceiveData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>&#160;</td>
          <td class="paramname"><em>transferWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__data__structures.html#ga13688dde62e8977a11ab69cf6b2c39b5">cy_smif_event_cb_t</a>&#160;</td>
          <td class="paramname"><em>RxCompleteCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements the receive data phase in the memory command. </p>
<p>The data is received into the RX Data FIFO using the RX_COUNT command. This function sets up the interrupt to trigger on the RX Data FIFO level, and the data is fetched from the RX Data FIFO to the rxBuffer as it gets filled. This function does not block until completion. The completion will trigger the call back function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is to be preceded by <a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11">Cy_SMIF_TransmitCommand</a>. The slave select is de-asserted at the end of the receive. The function triggers the transfer and the transfer itself utilizes the interrupt for FIFO operations in the background. Thus, frequent interrupts will be executed after this function is triggered. This API is non-blocking and sets up the interrupt to act on the data FIFO, ensure there will be no another instance of the function called before the current instance has completed execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">rxBuffer</td><td>The pointer to the variable where the receive data is stored. If this pointer is a NULL, then the function does not enable the interrupt. This use case is typically used when the FIFO is handled outside the interrupt and is managed in either a polling-based code or a DMA. The user would handle the FIFO management in a DMA or a polling-based code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the user provides a NULL pointer in this function and does not handle the FIFO transaction, this could either stall or timeout the operation. The transfer statuses returned by <a class="el" href="group__group__smif__low__level__functions.html#ga9b1a6bbecbb57233ea612d39d53b8f4c">Cy_SMIF_GetTransferStatus</a> are no longer valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of data to be received. Must be &gt; 0 and not greater than 65536.</td></tr>
    <tr><td class="paramname">transferWidth</td><td>The width of transfer <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>.</td></tr>
    <tr><td class="paramname">RxCompleteCb</td><td>The callback executed at the end of a reception. NULL interpreted as no callback.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of a reception.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a9785ad5aefcfc44b2f342035e2eb141a">CY_SMIF_CMD_FIFO_FULL</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Check <a class="el" href="group__group__smif.html#group_smif_usage_rules">Rules for PSoC6 QSPI/SMIF Block Usage</a> for any usage restriction </dd></dl>

</div>
</div>
<a id="ga93c3033ff812c2342cea0657096a46b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c3033ff812c2342cea0657096a46b9">&#9670;&nbsp;</a></span>Cy_SMIF_ReceiveDataBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_ReceiveDataBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>&#160;</td>
          <td class="paramname"><em>transferWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements the receive data phase in the memory command. </p>
<p>The data is received into the RX Data FIFO using the RX_COUNT command. This function blocks until completion. The function does not use the interrupts and will use CPU to monitor the FIFO status and move data accordingly. The function returns only on completion.</p>
<dl class="section note"><dt>Note</dt><dd>This function is to be preceded by <a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11">Cy_SMIF_TransmitCommand</a>. The slave select is de-asserted at the end of the receive. Ensure there is no another transfers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">rxBuffer</td><td>The pointer to the variable where the receive data is stored. If this pointer is a NULL, then the function does not enable the interrupt. This use case is typically used when the FIFO is handled outside the interrupt and is managed in either a polling-based code or a DMA. The user would handle the FIFO management in a DMA or a polling-based code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the user provides a NULL pointer in this function and does not handle the FIFO transaction, this could either stall or timeout the operation. The transfer statuses returned by <a class="el" href="group__group__smif__low__level__functions.html#ga9b1a6bbecbb57233ea612d39d53b8f4c">Cy_SMIF_GetTransferStatus</a> are no longer valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of data to be received. Must be &gt; 0 and not greater than 65536.</td></tr>
    <tr><td class="paramname">transferWidth</td><td>The width of transfer <a class="el" href="group__group__smif__enums.html#gab71e4b1f4c80b3e8c82dd85570415e44">cy_en_smif_txfr_width_t</a>.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of a reception.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a9785ad5aefcfc44b2f342035e2eb141a">CY_SMIF_CMD_FIFO_FULL</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41acec88a667ae4eb2db47acfc63492ac7d">CY_SMIF_EXCEED_TIMEOUT</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Check <a class="el" href="group__group__smif.html#group_smif_usage_rules">Rules for PSoC6 QSPI/SMIF Block Usage</a> for any usage restriction </dd></dl>

</div>
</div>
<a id="gae40a30c84a9a5956d03279b9ee8c3999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40a30c84a9a5956d03279b9ee8c3999">&#9670;&nbsp;</a></span>Cy_SMIF_SendDummyCycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_SendDummyCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends dummy-clock cycles. </p>
<p>The data lines are tri-stated during the dummy cycles.</p>
<dl class="section note"><dt>Note</dt><dd>This function is to be preceded by <a class="el" href="group__group__smif__low__level__functions.html#ga5abea630fca93c72faece8b23549cd11">Cy_SMIF_TransmitCommand</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">cycles</td><td>The number of dummy cycles. Must be &gt; 0 and not greater than 65536.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of dummy cycles sending.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a9785ad5aefcfc44b2f342035e2eb141a">CY_SMIF_CMD_FIFO_FULL</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9b1a6bbecbb57233ea612d39d53b8f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b1a6bbecbb57233ea612d39d53b8f4c">&#9670;&nbsp;</a></span>Cy_SMIF_GetTransferStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SMIF_GetTransferStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the status of the transfer. </p>
<p>This function is used to poll for the status of the TransmitData or receiveData function. When this function is called to determine the status of ongoing <a class="el" href="group__group__smif__low__level__functions.html#ga1b365e1400ccd6580533a0c92deb48c7">Cy_SMIF_ReceiveData()</a> or <a class="el" href="group__group__smif__low__level__functions.html#gae84cdf32e45e492e80dea38f9d3a7586">Cy_SMIF_TransmitData()</a>, the returned status is only valid if the functions passed a non-NULL buffer to transmit or receive respectively. If the pointer passed to <a class="el" href="group__group__smif__low__level__functions.html#ga1b365e1400ccd6580533a0c92deb48c7">Cy_SMIF_ReceiveData()</a> or <a class="el" href="group__group__smif__low__level__functions.html#gae84cdf32e45e492e80dea38f9d3a7586">Cy_SMIF_TransmitData()</a> is a NULL, then the code/DMA outside this driver will take care of the transfer and the Cy_GetTxfrStatus() will return an erroneous result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the transfer status. <a class="el" href="group__group__smif__enums.html#gaf65a7e26c18fcd3d3469eb083f78bb85">cy_en_smif_txfr_status_t</a> </dd></dl>

</div>
</div>
<a id="ga5428ca682fd56b837a1a3763fc2596b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5428ca682fd56b837a1a3763fc2596b8">&#9670;&nbsp;</a></span>Cy_SMIF_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SMIF_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the operation of the SMIF block. </p>
<dl class="section note"><dt>Note</dt><dd>This function only enables the SMIF IP. The interrupts associated with the SMIF will need to be separately enabled using the interrupt driver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga318b7c99ac2ba33e833cb4a0ab675e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318b7c99ac2ba33e833cb4a0ab675e17">&#9670;&nbsp;</a></span>Cy_SMIF_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SMIF_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the operation of the SMIF block. </p>
<p>The SMIF block can be disabled only when it is not in the active state. Use the <a class="el" href="group__group__smif__low__level__functions.html#ga58e965697047847ce906329eb6b5341c" title="This function provides the status of the IP block (False - not busy, True - busy). ">Cy_SMIF_BusyCheck()</a> API to check it before calling this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae74985772e86b44ab99a95ea467f6245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae74985772e86b44ab99a95ea467f6245">&#9670;&nbsp;</a></span>Cy_SMIF_SetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SMIF_SetInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set an interrupt mask for the SMIF Interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">interrupt</td><td>This is the mask for different source options that can be masked. See <a class="el" href="group__group__smif__macros__isr.html">Interrupt Macros</a> for possible values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83bbab71bc76fc372b4c8ad363e2512d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83bbab71bc76fc372b4c8ad363e2512d">&#9670;&nbsp;</a></span>Cy_SMIF_GetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SMIF_GetInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read an interrupt mask for the SMIF Interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mask set for the SMIF interrupt. </dd></dl>

</div>
</div>
<a id="ga6eba5a1edd402a8170d0d5649dda98c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eba5a1edd402a8170d0d5649dda98c4">&#9670;&nbsp;</a></span>Cy_SMIF_GetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SMIF_GetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read an active masked interrupt. </p>
<p>This function can be used in the interrupt service-routine to find which source triggered the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a word with bits set at positions corresponding to the interrupts triggered in the system. </dd></dl>

</div>
</div>
<a id="ga412a309c2929869dea85c59a62067085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga412a309c2929869dea85c59a62067085">&#9670;&nbsp;</a></span>Cy_SMIF_GetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SMIF_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read an active interrupt. </p>
<p>This status is the unmasked result, so will also show interrupts that will not generate active interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a word with bits set at positions corresponding to the interrupts triggered in the system. </dd></dl>

</div>
</div>
<a id="gadb165119cb003e0e69d6fcf39be65033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb165119cb003e0e69d6fcf39be65033">&#9670;&nbsp;</a></span>Cy_SMIF_SetInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SMIF_SetInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set an interrupt source. </p>
<p>This function can be used to activate interrupts through the software.</p>
<dl class="section note"><dt>Note</dt><dd>Interrupt sources set using this interrupt will generate interrupts only if they are not masked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">interrupt</td><td>An encoded integer with a bit set corresponding to the interrupt to be triggered. See <a class="el" href="group__group__smif__macros__isr.html">Interrupt Macros</a> for possible values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga728aaee38b9821b954d3a56e53787fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga728aaee38b9821b954d3a56e53787fb1">&#9670;&nbsp;</a></span>Cy_SMIF_ClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SMIF_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to clear an interrupt source. </p>
<p>This function can be used in the user code to clear all pending interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">interrupt</td><td>An encoded integer with a bit set corresponding to the interrupt that must be cleared. See <a class="el" href="group__group__smif__macros__isr.html">Interrupt Macros</a> for possible values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9b71a3308f1a654b2fc583033761a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9b71a3308f1a654b2fc583033761a7a">&#9670;&nbsp;</a></span>Cy_SMIF_SetTxFifoTriggerLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SMIF_SetTxFifoTriggerLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set a trigger level for the TX FIFO. </p>
<p>This value must be an integer between 0 and 7. For the normal mode only. The triggering is active when TX_DATA_FIFO_STATUS &lt;= level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">level</td><td>The trigger level to set (0-8). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac31d93c962f0ff359932ac8ad6a4baec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac31d93c962f0ff359932ac8ad6a4baec">&#9670;&nbsp;</a></span>Cy_SMIF_SetRxFifoTriggerLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SMIF_SetRxFifoTriggerLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set a trigger level for the RX FIFO. </p>
<p>This value must be an integer between 0 and 7. For the normal mode only. The triggering is active when RX_DATA_FIFOSTATUS &gt; level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">level</td><td>The trigger level to set(0-8). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e0da7a14fb7bdc9ee054f87239b38e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e0da7a14fb7bdc9ee054f87239b38e7">&#9670;&nbsp;</a></span>Cy_SMIF_GetCmdFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SMIF_GetCmdFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the status of the CMD FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of the entries in the CMD FIFO. </dd></dl>

</div>
</div>
<a id="ga10662c147b39a1b71a2f2221b0e3f59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10662c147b39a1b71a2f2221b0e3f59f">&#9670;&nbsp;</a></span>Cy_SMIF_GetTxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SMIF_GetTxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the status of the TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of the entries in the TX FIFO. </dd></dl>

</div>
</div>
<a id="ga54e4c5a29449fabe546b4770061f31b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e4c5a29449fabe546b4770061f31b7">&#9670;&nbsp;</a></span>Cy_SMIF_GetRxFifoStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SMIF_GetRxFifoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the status of the RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of the entries in the RX FIFO. </dd></dl>

</div>
</div>
<a id="ga91a32005b94591adb8fd7daa1068ddbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91a32005b94591adb8fd7daa1068ddbc">&#9670;&nbsp;</a></span>Cy_SMIF_Encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_Encrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the Encryption engine to create an encrypted result when the input, key and data arrays are provided. </p>
<p>The AES-128 encryption of the address with the key, fetching the result and XOR with the data array are all done in the function. The operational scheme is the following: data = XOR(AES128(address, key), data) Decryption is done using the input data-array identically to the encryption. In the XIP mode, encryption and decryption are done without calling this function. The operational scheme in the XIP mode is the same. The address parameter in the XIP mode equals the actual address in the PSoC memory map. The SMIF encryption engine is designed for code storage. For data storage, the encryption key can be changed. For sensitive data, the Crypto block is used.</p>
<dl class="section note"><dt>Note</dt><dd>The API does not have access to the encryption key. The key must be placed in the register before calling this API. The crypto routine that can access the key storage area is recommended. This crypto routine is typically a protection context 0 function.</dd>
<dd>
This is a blocking API. The API waits for encryption completion. Will exit if a timeout is set (not equal to 0) and expired.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">address</td><td>The address that gets encrypted is a masked 16-byte block address. The 32-bit address with the last 4 bits masked is placed as the last 4 bytes in the 128-bit input. The rest of the higher bit for the 128 bits are padded zeros. PA[127:0]: PA[3:0] = 0 PA[7:4] = ADDR[7:4]. PA[15:8] = ADDR[15:8]. PA[23:16] = ADDR[23:16]. PA[31:24] = ADDR[31:24]. The other twelve of the sixteen plain text address bytes of PA[127:0] are "0": PA[127:32] = "0".</td></tr>
    <tr><td class="paramname">data</td><td>This is the location where the input data-array is passed while the function is called. This array gets populated with the result after encryption is completed.</td></tr>
    <tr><td class="paramname">size</td><td>Provides a size of the array.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of the command transmit.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41acec88a667ae4eb2db47acfc63492ac7d">CY_SMIF_EXCEED_TIMEOUT</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario:  Encrypt data in the txBuffer[] before writing data into the memory at the address=0x2000. */</span></div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> SMIF_context;  <span class="comment">/* This is a shared context structure.</span></div><div class="line"><span class="comment">                                          * It must be global</span></div><div class="line"><span class="comment">                                          */</span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define MEMTEST_AES_KEY_SIZE (16U)   </span><span class="comment">/* The AES key length */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define PACKET_SIZE          (32U)   </span><span class="comment">/* The memory Read/Write packet */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <span class="comment">/* Data to encrypt */</span></div><div class="line">    uint8_t txBuffer[PACKET_SIZE] = {1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U,</div><div class="line">                                     9U, 10U, 11U, 12U, 13U, 14U, 15U, 16U,</div><div class="line">                                     17U, 18U, 19U, 20U, 21U, 22U, 23U, 24U,</div><div class="line">                                     25U, 26U, 27U, 28U, 29U, 30U, 31U, 32U};</div><div class="line">    uint32_t address = 0x2000UL;  <span class="comment">/* The address to write data to  */</span></div><div class="line"></div><div class="line">    <span class="comment">/* The AES key.</span></div><div class="line"><span class="comment">    * Writing of the AES key should be from secure area of the code   </span></div><div class="line"><span class="comment">    */</span></div><div class="line">    uint8_t key[MEMTEST_AES_KEY_SIZE] = {0x54U, 0x68U, 0x61U, 0x74U, 0x73U, 0x20U, 0x6DU, 0x79U,</div><div class="line">                                         0x20U, 0x4BU, 0x75U, 0x6EU, 0x67U, 0x20U, 0x46U, 0x75U};</div><div class="line"></div><div class="line">    <span class="comment">/* Fill the key field in secure area of the code. */</span></div><div class="line">    SMIF-&gt;CRYPTO_KEY0 = Cy_SMIF_PackBytesArray(&amp;key[CY_SMIF_CRYPTO_FIRST_WORD], <span class="keyword">true</span>);</div><div class="line">    SMIF-&gt;CRYPTO_KEY1 = Cy_SMIF_PackBytesArray(&amp;key[CY_SMIF_CRYPTO_SECOND_WORD], <span class="keyword">true</span>);</div><div class="line">    SMIF-&gt;CRYPTO_KEY2 = Cy_SMIF_PackBytesArray(&amp;key[CY_SMIF_CRYPTO_THIRD_WORD], <span class="keyword">true</span>);</div><div class="line">    SMIF-&gt;CRYPTO_KEY3 = Cy_SMIF_PackBytesArray(&amp;key[CY_SMIF_CRYPTO_FOURTH_WORD], <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Encrypt data in txBuffer */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a> != <a class="code" href="group__group__smif__low__level__functions.html#ga91a32005b94591adb8fd7daa1068ddbc">Cy_SMIF_Encrypt</a>(SMIF, address, txBuffer, <span class="keyword">sizeof</span>(txBuffer), &amp;SMIF_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">/* The second call of Cy_SMIF_Encrypt() decrypts data in txBuffer */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a> != <a class="code" href="group__group__smif__low__level__functions.html#ga91a32005b94591adb8fd7daa1068ddbc">Cy_SMIF_Encrypt</a>(SMIF, address, txBuffer, <span class="keyword">sizeof</span>(txBuffer), &amp;SMIF_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line">    </div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga58e965697047847ce906329eb6b5341c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e965697047847ce906329eb6b5341c">&#9670;&nbsp;</a></span>Cy_SMIF_BusyCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SMIF_BusyCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the status of the IP block (False - not busy, True - busy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an IP block status. </dd></dl>

</div>
</div>
<a id="gaedbec6f968745b8f594dd4b32e91ceba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedbec6f968745b8f594dd4b32e91ceba">&#9670;&nbsp;</a></span>Cy_SMIF_Interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SMIF_Interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__smif__context__t.html">cy_stc_smif_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Interrupt Service Routine for the SMIF. </p>
<p>The interrupt code will be responsible for the FIFO operations on FIFO interrupts during ongoing transfers. The user must place a call to this interrupt function in the interrupt routine corresponding to the interrupt attached to the SMIF. If the user does not do this, will break: the functionality of all the API functions in the SMIF driver that use SMIF interrupts to affect transfers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">context</td><td>Passes a configuration structure that contains the transfer parameters of the SMIF block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Global Variables</dt><dd><ul>
<li>context-&gt;txBufferAddress - The pointer to the data to be transferred.</li>
<li>context-&gt;txBufferSize - The size of txBuffer.</li>
<li>context-&gt;txBufferCounter - The number of data entries left to be transferred.</li>
</ul>
</dd></dl>
<p>All the Global variables described above are used when the Software Buffer is used. </p>

</div>
</div>
<a id="ga28f06f761c260849fa8e37d7a3f858dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28f06f761c260849fa8e37d7a3f858dc">&#9670;&nbsp;</a></span>Cy_SMIF_CacheEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_CacheEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a>&#160;</td>
          <td class="paramname"><em>cacheType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to enable the fast cache, the slow cache or both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">cacheType</td><td>Holds the type of the cache to be modified. <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of function completion.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacb0c1e80c19ef607a1efc70df6818ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb0c1e80c19ef607a1efc70df6818ccb">&#9670;&nbsp;</a></span>Cy_SMIF_CacheDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_CacheDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a>&#160;</td>
          <td class="paramname"><em>cacheType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to disable the fast cache, the slow cache or both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">cacheType</td><td>Holds the type of the cache to be modified. <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of function completion.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0ff445110c019e30b942fb87878b32c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ff445110c019e30b942fb87878b32c7">&#9670;&nbsp;</a></span>Cy_SMIF_CachePrefetchingEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_CachePrefetchingEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a>&#160;</td>
          <td class="paramname"><em>cacheType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to enable pre-fetching for the fast cache, the slow cache or both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">cacheType</td><td>Holds the type of the cache to be modified. <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of function completion.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabbb34fe2a90c311a2e1fa23c66a21c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbb34fe2a90c311a2e1fa23c66a21c81">&#9670;&nbsp;</a></span>Cy_SMIF_CachePrefetchingDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_CachePrefetchingDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a>&#160;</td>
          <td class="paramname"><em>cacheType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to disable pre-fetching for the fast cache, the slow cache or both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">cacheType</td><td>Holds the type of the cache to be modified. <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of function completion.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga72240c0ce8307c50b65c4fca45c9cd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72240c0ce8307c50b65c4fca45c9cd30">&#9670;&nbsp;</a></span>Cy_SMIF_CacheInvalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__smif__enums.html#ga75fb83c49239ece738cfba778165cb41">cy_en_smif_status_t</a> Cy_SMIF_CacheInvalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_f___type.html">SMIF_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a>&#160;</td>
          <td class="paramname"><em>cacheType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to invalidate/clear the fast cache, the slow cache or both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Holds the base address of the SMIF block registers.</td></tr>
    <tr><td class="paramname">cacheType</td><td>Holds the type of the cache to be modified. <a class="el" href="group__group__smif__enums.html#gaf7e001d5a1821a56324e8898913b21ef">cy_en_smif_cache_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status of function completion.<ul>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41af59dcc9751976e423239cac212df16cc">CY_SMIF_SUCCESS</a></li>
<li><a class="el" href="group__group__smif__enums.html#gga75fb83c49239ece738cfba778165cb41a858bf399de59819187ec0b3d8913107b">CY_SMIF_BAD_PARAM</a> </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
