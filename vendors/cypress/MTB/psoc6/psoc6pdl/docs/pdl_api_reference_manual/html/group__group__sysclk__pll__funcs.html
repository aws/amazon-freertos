<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__sysclk__pll__funcs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__sysclk.html">SysClk       (System Clock)</a> &raquo; <a class="el" href="group__group__sysclk__pll.html">Phase Locked Loop (PLL)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac5c498137bf7012e8e0f8b8e0dfba1f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a> (uint32_t clkPath, const <a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> *config)</td></tr>
<tr class="memdesc:gac5c498137bf7012e8e0f8b8e0dfba1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a given PLL.  <a href="#gac5c498137bf7012e8e0f8b8e0dfba1f0">More...</a><br /></td></tr>
<tr class="separator:gac5c498137bf7012e8e0f8b8e0dfba1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21ad8110bfc4506947fbd0fb163d055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gad21ad8110bfc4506947fbd0fb163d055">Cy_SysClk_PllManualConfigure</a> (uint32_t clkPath, const <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *config)</td></tr>
<tr class="memdesc:gad21ad8110bfc4506947fbd0fb163d055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually configures a PLL based on user inputs.  <a href="#gad21ad8110bfc4506947fbd0fb163d055">More...</a><br /></td></tr>
<tr class="separator:gad21ad8110bfc4506947fbd0fb163d055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc66dcae940c37c26bc7d8b840f83b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a> (uint32_t clkPath, <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *config)</td></tr>
<tr class="memdesc:ga1fc66dcae940c37c26bc7d8b840f83b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports configuration settings for a PLL.  <a href="#ga1fc66dcae940c37c26bc7d8b840f83b0">More...</a><br /></td></tr>
<tr class="separator:ga1fc66dcae940c37c26bc7d8b840f83b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5396ed00cc7ddeeb924bf00ee08311e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> (uint32_t clkPath, uint32_t timeoutus)</td></tr>
<tr class="memdesc:ga5396ed00cc7ddeeb924bf00ee08311e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the PLL.  <a href="#ga5396ed00cc7ddeeb924bf00ee08311e5">More...</a><br /></td></tr>
<tr class="separator:ga5396ed00cc7ddeeb924bf00ee08311e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d5bd082d1aef722d73394d53e9f6ad"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga03d5bd082d1aef722d73394d53e9f6ad">Cy_SysClk_PllLocked</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:ga03d5bd082d1aef722d73394d53e9f6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected PLL is locked.  <a href="#ga03d5bd082d1aef722d73394d53e9f6ad">More...</a><br /></td></tr>
<tr class="separator:ga03d5bd082d1aef722d73394d53e9f6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d5c55ce77796f41b1f9d55626e381c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga43d5c55ce77796f41b1f9d55626e381c">Cy_SysClk_PllIsEnabled</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:ga43d5c55ce77796f41b1f9d55626e381c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected PLL is enabled.  <a href="#ga43d5c55ce77796f41b1f9d55626e381c">More...</a><br /></td></tr>
<tr class="separator:ga43d5c55ce77796f41b1f9d55626e381c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd43bf372179a4967d3a579fb68a64a6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#gafd43bf372179a4967d3a579fb68a64a6">Cy_SysClk_PllLostLock</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:gafd43bf372179a4967d3a579fb68a64a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the selected PLL lost its lock since the last time this function was called.  <a href="#gafd43bf372179a4967d3a579fb68a64a6">More...</a><br /></td></tr>
<tr class="separator:gafd43bf372179a4967d3a579fb68a64a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf01399aad7f6f71e0fea977a918822"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysclk__pll__funcs.html#ga0cf01399aad7f6f71e0fea977a918822">Cy_SysClk_PllDisable</a> (uint32_t clkPath)</td></tr>
<tr class="memdesc:ga0cf01399aad7f6f71e0fea977a918822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the selected PLL.  <a href="#ga0cf01399aad7f6f71e0fea977a918822">More...</a><br /></td></tr>
<tr class="separator:ga0cf01399aad7f6f71e0fea977a918822"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac5c498137bf7012e8e0f8b8e0dfba1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5c498137bf7012e8e0f8b8e0dfba1f0">&#9670;&nbsp;</a></span>Cy_SysClk_PllConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures a given PLL. </p>
<p>The configuration formula used is: Fout = pll_clk * (P / Q / div_out), where: Fout is the desired output frequency pll_clk is the frequency of the input source P is the feedback divider. Its value is in bitfield FEEDBACK_DIV. Q is the reference divider. Its value is in bitfield REFERENCE_DIV. div_out is the reference divider. Its value is in bitfield OUTPUT_DIV.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to configure. 1 is the first PLL; 0 is invalid.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully configured <br />
CY_SYSCLK_INVALID_STATE - PLL not configured because it is enabled <br />
CY_SYSCLK_BAD_PARAM - Invalid clock path number, or input or desired output frequency is out of valid range</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call this function after changing the PLL input frequency, for example if <a class="el" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource()</a> is called.</dd>
<dd>
Do not call this function when the PLL is enabled. If it is called, then this function returns immediately with an error return value and no register updates.</dd>
<dd>
Call <a class="el" href="group__group__system__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is decreasing.</dd>
<dd>
On PSoC 64 devices the configuration on the PRA driver will be reflected after <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> call. Any call to <a class="el" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> returns old configuration values.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: PLL needs to source HFCLK0, which must operate at 100 MHz.</span></div><div class="line"><span class="comment">                 The IMO sources the PLL at 8MHz. Startup time is not an issue</span></div><div class="line"><span class="comment">                 and manual configuration of the PLL is not needed. */</span></div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> pllConfig =</div><div class="line">    {</div><div class="line">        <span class="comment">/*.inputFreq  =*/</span> 8000000UL,                    <span class="comment">/* PLL input: 8 MHz IMO */</span></div><div class="line">        <span class="comment">/*.outputFreq =*/</span> 100000000UL,                  <span class="comment">/* PLL output: 100 MHz */</span></div><div class="line">        <span class="comment">/*.lfMode     =*/</span> <span class="keyword">true</span>,                         <span class="comment">/* Enable low frequency mode (VCO = 170~200 MHz) */</span></div><div class="line">        <span class="comment">/*.outputMode =*/</span> <a class="code" href="group__group__sysclk__fll__enums.html#gga777e08424e26c9cd8c2602b2114e716bacd71b0d705fcb6d646c7f439e6de3cf0">CY_SYSCLK_FLLPLL_OUTPUT_AUTO</a>  <span class="comment">/* Output 100 MHz when locked. Otherwise 8 MHz */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Set the PLL source (path 1 mux) to be the IMO.</span></div><div class="line"><span class="comment">       Note: Path 0 is not valid for PLL. */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource</a>(1UL, <a class="code" href="group__group__sysclk__path__src__enums.html#gga8ddaf9023a02dee0d1f9a5629d6ccfe6a01c7cbab413a99daa41d2fb7a0340955">CY_SYSCLK_CLKPATH_IN_IMO</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure Path 1 PLL with the settings in pllConfig struct */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a>(1UL, &amp;pllConfig))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the Path 1 PLL with 2000 microsecond timeout */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>(1UL, 2000UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set the HFCLK0 source to clock path 1 */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__clk__hf__funcs.html#ga4d090b2e9716939fe4689fac77b05679">Cy_SysClk_ClkHfSetSource</a>(0UL, <a class="code" href="group__group__sysclk__clk__hf__enums.html#ggabac2d6b9124a00860dcd781a922788d6a69197ee41c916c6e61d81dbe9be1825f">CY_SYSCLK_CLKHF_IN_CLKPATH1</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gad21ad8110bfc4506947fbd0fb163d055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad21ad8110bfc4506947fbd0fb163d055">&#9670;&nbsp;</a></span>Cy_SysClk_PllManualConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllManualConfigure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually configures a PLL based on user inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to configure. 1 is the first PLL; 0 is invalid.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully configured <br />
CY_SYSCLK_INVALID_STATE - PLL not configured because it is enabled <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call this function after changing the PLL input frequency; for example if <a class="el" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource()</a> is called.</dd>
<dd>
Do not call this function when the PLL is enabled. If it is called, then this function returns immediately with an error return value and no register updates.</dd>
<dd>
Call <a class="el" href="group__group__system__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the PLL frequency is decreasing.</dd>
<dd>
On PSoC 64 devices the configuration on the PRA driver will be reflected after <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> call. Any call to <a class="el" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> returns old configuration values.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: PLL needs to source HFCLK0, which must operate at 100 MHz.</span></div><div class="line"><span class="comment">                 The IMO sources the PLL at 8MHz. The characteristics of the</span></div><div class="line"><span class="comment">                 PLL lock parameters are already known and the startup time</span></div><div class="line"><span class="comment">                 for the PLL configuration must be minimized. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Refer to the TRM for the full set of equations used to calculate the parameters */</span></div><div class="line">    <a class="code" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> pllConfig =</div><div class="line">    {</div><div class="line">        <span class="comment">/*.feedbackDiv  =*/</span> 25u,                            <span class="comment">/* Feedback divider */</span></div><div class="line">        <span class="comment">/*.referenceDiv =*/</span> 1u,                             <span class="comment">/* Reference divider */</span></div><div class="line">        <span class="comment">/*.outputDiv    =*/</span> 2u,                             <span class="comment">/* Output divider */</span></div><div class="line">        <span class="comment">/*.lfMode       =*/</span> <span class="keyword">true</span>,                           <span class="comment">/* Enable low frequency mode (VCO = 170~200 MHz) */</span></div><div class="line">        <span class="comment">/*.outputMode   =*/</span> CY_SYSCLK_FLLPLL_OUTPUT_AUTO    <span class="comment">/* Output 100 MHz when locked. Otherwise 8 MHz */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Set the PLL source (path 1 mux) to be the IMO.</span></div><div class="line"><span class="comment">       Note: Path 0 is not valid for PLL. */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__path__src__funcs.html#ga517f603266062d0013947ea950ed5b60">Cy_SysClk_ClkPathSetSource</a>(1UL, <a class="code" href="group__group__sysclk__path__src__enums.html#gga8ddaf9023a02dee0d1f9a5629d6ccfe6a01c7cbab413a99daa41d2fb7a0340955">CY_SYSCLK_CLKPATH_IN_IMO</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure Path 1 PLL with the settings in pllConfig struct */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#gad21ad8110bfc4506947fbd0fb163d055">Cy_SysClk_PllManualConfigure</a>(1UL, &amp;pllConfig))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the path 1 PLL with 2000 microsecond timeout */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>(1UL, 2000UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Set the HFCLK0 source to clock path 1 */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__clk__hf__funcs.html#ga4d090b2e9716939fe4689fac77b05679">Cy_SysClk_ClkHfSetSource</a>(0UL, <a class="code" href="group__group__sysclk__clk__hf__enums.html#ggabac2d6b9124a00860dcd781a922788d6a69197ee41c916c6e61d81dbe9be1825f">CY_SYSCLK_CLKHF_IN_CLKPATH1</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga1fc66dcae940c37c26bc7d8b840f83b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fc66dcae940c37c26bc7d8b840f83b0">&#9670;&nbsp;</a></span>Cy_SysClk_PllGetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllGetConfiguration </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports configuration settings for a PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to report. 1 is the first PLL; 0 is invalid.</td></tr>
    <tr><td class="paramname">config</td><td><a class="el" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL data successfully reported <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On PSoC 64 devices the configuration on the PRA driver will be reflected after <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> call. Any call to <a class="el" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a> before calling <a class="el" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a> returns old configuration values.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: The calculated PLL parameters need to be checked. */</span></div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__pll__config__t.html">cy_stc_pll_config_t</a> autoPllConfig =</div><div class="line">    {</div><div class="line">        <span class="comment">/*.inputFreq  =*/</span> 8000000UL,                    <span class="comment">/* PLL input: 8 MHz IMO */</span></div><div class="line">        <span class="comment">/*.outputFreq =*/</span> 100000000UL,                  <span class="comment">/* PLL output: 100 MHz */</span></div><div class="line">        <span class="comment">/*.lfMode     =*/</span> <span class="keyword">true</span>,                         <span class="comment">/* Enable low frequency mode (VCO = 170~200 MHz) */</span></div><div class="line">        <span class="comment">/*.outputMode =*/</span> CY_SYSCLK_FLLPLL_OUTPUT_AUTO  <span class="comment">/* Output 100 MHz when locked. Otherwise 8 MHz */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__pll__manual__config__t.html">cy_stc_pll_manual_config_t</a> getPllParams;</div><div class="line"></div><div class="line">    <span class="comment">/* Configure Path 1 PLL with the settings in pllConfig struct */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#gac5c498137bf7012e8e0f8b8e0dfba1f0">Cy_SysClk_PllConfigure</a>(1UL, &amp;autoPllConfig))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Retrieve the calculated parameters of Path 1 PLL */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__pll__funcs.html#ga1fc66dcae940c37c26bc7d8b840f83b0">Cy_SysClk_PllGetConfiguration</a>(1UL, &amp;getPllParams);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga5396ed00cc7ddeeb924bf00ee08311e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5396ed00cc7ddeeb924bf00ee08311e5">&#9670;&nbsp;</a></span>Cy_SysClk_PllEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeoutus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the PLL. </p>
<p>The PLL should be configured before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to enable. 1 is the first PLL; 0 is invalid.</td></tr>
    <tr><td class="paramname">timeoutus</td><td>amount of time in microseconds to wait for the PLL to lock. If the lock doesn't occur, PLL is stopped. To avoid waiting for lock, set this to 0 and manually check for lock using <a class="el" href="group__group__sysclk__pll__funcs.html#ga03d5bd082d1aef722d73394d53e9f6ad">Cy_SysClk_PllLocked</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully enabled <br />
CY_SYSCLK_TIMEOUT - Timeout waiting for PLL lock <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call <a class="el" href="group__group__system__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is decreasing.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: PLL is configured and needs to be enabled within 2 ms */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the Path 1 PLL with a timeout of 2000 microsecond */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>(1UL, 2000UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga03d5bd082d1aef722d73394d53e9f6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d5bd082d1aef722d73394d53e9f6ad">&#9670;&nbsp;</a></span>Cy_SysClk_PllLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SysClk_PllLocked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected PLL is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to check. 1 is the first PLL; 0 is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = not locked <br />
true = locked</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: PLL is configured and needs to be enabled in a non-blocking way */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the Path 1 PLL without timeout */</span></div><div class="line">    (void)<a class="code" href="group__group__sysclk__pll__funcs.html#ga5396ed00cc7ddeeb924bf00ee08311e5">Cy_SysClk_PllEnable</a>(1UL, 0UL);</div><div class="line"></div><div class="line">    <span class="comment">/* Check the status of the lock */</span></div><div class="line">    <span class="keywordflow">while</span>(<a class="code" href="group__group__sysclk__pll__funcs.html#ga03d5bd082d1aef722d73394d53e9f6ad">Cy_SysClk_PllLocked</a>(1UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Perform other actions while the PLL is locking */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* PLL Locked. Proceed with further configuration */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga43d5c55ce77796f41b1f9d55626e381c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43d5c55ce77796f41b1f9d55626e381c">&#9670;&nbsp;</a></span>Cy_SysClk_PllIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SysClk_PllIsEnabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected PLL is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to check. 1 is the first PLL; 0 is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = disabled <br />
true = enabled</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Path 1 PLL failed to enable and must be reconfigured. Or the</span></div><div class="line"><span class="comment">                 PLL is no longer used and hence needs to be disabled. */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__pll__funcs.html#ga43d5c55ce77796f41b1f9d55626e381c">Cy_SysClk_PllIsEnabled</a>(1UL))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga0cf01399aad7f6f71e0fea977a918822">Cy_SysClk_PllDisable</a>(1UL))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Insert error handling */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* The clocks that relied on the PLL will now run off of the clock that</span></div><div class="line"><span class="comment">       was used to source the FLL (e.g. IMO or ECO). */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gafd43bf372179a4967d3a579fb68a64a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd43bf372179a4967d3a579fb68a64a6">&#9670;&nbsp;</a></span>Cy_SysClk_PllLostLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SysClk_PllLostLock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether or not the selected PLL lost its lock since the last time this function was called. </p>
<p>Clears the lost lock indicator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to check. 1 is the first PLL; 0 is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false = did not lose lock <br />
true = lost lock</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Suspicious change in Path 1 clock frequency was encountered</span></div><div class="line"><span class="comment">                 in the application. Check if the Path 1 PLL lost the lock. */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__sysclk__pll__funcs.html#gafd43bf372179a4967d3a579fb68a64a6">Cy_SysClk_PllLostLock</a>(1UL))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert error handling */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga0cf01399aad7f6f71e0fea977a918822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf01399aad7f6f71e0fea977a918822">&#9670;&nbsp;</a></span>Cy_SysClk_PllDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__sysclk__returns.html#gad6699a184e2e3c01433251b0981558f3">cy_en_sysclk_status_t</a> Cy_SysClk_PllDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the selected PLL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkPath</td><td>Selects which PLL to disable. 1 is the first PLL; 0 is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error / status code: <br />
CY_SYSCLK_SUCCESS - PLL successfully disabled <br />
CY_SYSCLK_BAD_PARAM - invalid clock path number CY_SYSCLK_INVALID_STATE - ECO already enabled For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Call <a class="el" href="group__group__system__config__system__functions.html#gae0c36a9591fe6e9c45ecb21a794f0f0f">SystemCoreClockUpdate</a> after this function calling if it affects the CLK_HF0 frequency.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> before calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is increasing.</dd>
<dd>
Call <a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> after calling this function if the PLL is the source of CLK_HF0 and the CLK_HF0 frequency is decreasing.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Path 1 PLL failed to enable and must be reconfigured. Or the</span></div><div class="line"><span class="comment">                 PLL is no longer used and hence needs to be disabled. */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__pll__funcs.html#ga43d5c55ce77796f41b1f9d55626e381c">Cy_SysClk_PllIsEnabled</a>(1UL))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__sysclk__returns.html#ggad6699a184e2e3c01433251b0981558f3a1563f761f963757b339ff05eb5a690ec">CY_SYSCLK_SUCCESS</a> != <a class="code" href="group__group__sysclk__pll__funcs.html#ga0cf01399aad7f6f71e0fea977a918822">Cy_SysClk_PllDisable</a>(1UL))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Insert error handling */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* The clocks that relied on the PLL will now run off of the clock that</span></div><div class="line"><span class="comment">       was used to source the FLL (e.g. IMO or ECO). */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
