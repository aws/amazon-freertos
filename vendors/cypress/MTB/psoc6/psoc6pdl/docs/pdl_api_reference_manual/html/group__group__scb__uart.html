<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: UART (SCB)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__uart.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">UART (SCB)<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Driver API for UART. </p>
<p>The functions and other declarations used in this part of the driver are in cy_scb_uart.h. You can also include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>The Universal Asynchronous Receiver/Transmitter (UART) protocol is an asynchronous serial interface protocol. UART communication is typically point-to-point. The UART interface consists of two signals:</p><ul>
<li>TX: Transmitter output</li>
<li>RX: Receiver input</li>
</ul>
<p>Additionally, two side-band signals are used to implement flow control in UART. Note that the flow control applies only to TX functionality.</p><ul>
<li>Clear to Send (CTS): This is an input signal to the transmitter. When active, it indicates that the slave is ready for the master to transmit data.</li>
<li>Ready to Send (RTS): This is an output signal from the receiver. When active, it indicates that the receiver is ready to receive data</li>
</ul>
<p>Features:</p><ul>
<li>Supports UART protocol<ul>
<li>Standard UART</li>
<li>Multi-processor mode</li>
</ul>
</li>
<li>SmartCard (ISO7816) reader</li>
<li>IrDA</li>
<li>Data frame size programmable from 4 to 16 bits</li>
<li>Programmable number of STOP bits, which can be set in terms of half bit periods between 1 and 4</li>
<li>Parity support (odd and even parity)</li>
<li>Median filter on Rx input</li>
<li>Programmable oversampling</li>
<li>Start skipping</li>
</ul>
<h1><a class="anchor" id="group_scb_uart_configuration"></a>
Configuration Considerations</h1>
<p>The UART driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__uart.html#group_scb_uart_config">Configure UART</a></li>
<li><a class="el" href="group__group__scb__uart.html#group_scb_uart_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__uart.html#group_scb_uart_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__uart.html#group_scb_uart_data_rate">Configure Baud Rate</a></li>
<li><a class="el" href="group__group__scb__uart.html#group_scb_uart_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__uart.html#group_scb_uart_enable">Enable UART</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>UART driver is built on top of the SCB hardware block. The SCB5 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_uart_config"></a>
Configure UART</h2>
<p>To set up the UART driver, provide the configuration parameters in the <a class="el" href="structcy__stc__scb__uart__config__t.html">cy_stc_scb_uart_config_t</a> structure. For example: provide uartMode, oversample, dataWidth, enableMsbFirst, parity, and stopBits. The other parameters are optional. To initialize the driver, call <a class="el" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a> function providing a pointer to the populated <a class="el" href="structcy__stc__scb__uart__config__t.html">cy_stc_scb_uart_config_t</a> structure and the allocated <a class="el" href="structcy__stc__scb__uart__context__t.html">cy_stc_scb_uart_context_t</a> structure.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate context for UART operation */</span></div><div class="line"><a class="code" href="structcy__stc__scb__uart__context__t.html">cy_stc_scb_uart_context_t</a> uartContext;</div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__scb__uart__config__t.html">cy_stc_scb_uart_config_t</a> uartConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__scb__uart__config__t.html#ae3ffcd78ef51b5dd068bd87ef129d78e">uartMode</a>                   = <a class="code" href="group__group__scb__uart__enums.html#ggaff3a50e4dbd1e0efe1550b05816e1a65a039e9ca2ab60fb9e0d2226bd21e4787c">CY_SCB_UART_STANDARD</a>,</div><div class="line">    .enableMutliProcessorMode   = <span class="keyword">false</span>,</div><div class="line">    .smartCardRetryOnNack       = <span class="keyword">false</span>,</div><div class="line">    .irdaInvertRx               = <span class="keyword">false</span>,</div><div class="line">    .irdaEnableLowPowerReceiver = <span class="keyword">false</span>,</div><div class="line"></div><div class="line">    .oversample                 = 12UL,</div><div class="line"></div><div class="line">    .enableMsbFirst             = <span class="keyword">false</span>,</div><div class="line">    .dataWidth                  = 8UL,</div><div class="line">    .parity                     = <a class="code" href="group__group__scb__uart__enums.html#gga5ee6d587ef3399954d609f17775a3f42a4684fcd6cd3d48bf9372f5947af95f0d">CY_SCB_UART_PARITY_NONE</a>,</div><div class="line">    .stopBits                   = <a class="code" href="group__group__scb__uart__enums.html#gga980f6c273a50db8f6b6fa7f703b1a7f9ac35384addc6b2590f3ec209ae4541394">CY_SCB_UART_STOP_BITS_1</a>,</div><div class="line">    .enableInputFilter          = <span class="keyword">false</span>,</div><div class="line">    .breakWidth                 = 11UL,</div><div class="line">    .dropOnFrameError           = <span class="keyword">false</span>,</div><div class="line">    .dropOnParityError          = <span class="keyword">false</span>,</div><div class="line"></div><div class="line">    .receiverAddress            = 0UL,</div><div class="line">    .receiverAddressMask        = 0UL,</div><div class="line">    .acceptAddrInFifo           = <span class="keyword">false</span>,</div><div class="line"></div><div class="line">    .enableCts                  = <span class="keyword">false</span>,</div><div class="line">    .ctsPolarity                = <a class="code" href="group__group__scb__uart__enums.html#ggadd7a3cc34b487e9898095db7b1638098a61a976af6edbc286fc87ee17b3809f36">CY_SCB_UART_ACTIVE_LOW</a>,</div><div class="line">    .rtsRxFifoLevel             = 0UL,</div><div class="line">    .rtsPolarity                = <a class="code" href="group__group__scb__uart__enums.html#ggadd7a3cc34b487e9898095db7b1638098a61a976af6edbc286fc87ee17b3809f36">CY_SCB_UART_ACTIVE_LOW</a>,</div><div class="line"></div><div class="line">    .rxFifoTriggerLevel  = 0UL,</div><div class="line">    .rxFifoIntEnableMask = 0UL,</div><div class="line">    .txFifoTriggerLevel  = 0UL,</div><div class="line">    .txFifoIntEnableMask = 0UL,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Configure UART to operate */</span></div><div class="line">(void) <a class="code" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a>(SCB5, &amp;uartConfig, &amp;uartContext);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_uart_pins"></a>
Assign and Configure Pins</h2>
<p>Only dedicated SCB pins can be used for UART operation. The HSIOM register must be configured to connect dedicated SCB UART pins to the SCB block. Also, the UART output pins must be configured in Strong Drive Input Off mode and UART input pins in Digital High-Z:</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign pins for UART on SCB5: P5[0], P5[1] */</span></div><div class="line"><span class="preprocessor">#define UART_PORT       P5_0_PORT</span></div><div class="line"><span class="preprocessor">#define UART_RX_NUM     P5_0_NUM</span></div><div class="line"><span class="preprocessor">#define UART_TX_NUM     P5_1_NUM</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect SCB5 UART function to pins */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(UART_PORT, UART_RX_NUM, P5_0_SCB5_UART_RX);</div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(UART_PORT, UART_TX_NUM, P5_1_SCB5_UART_TX);</div><div class="line"></div><div class="line"><span class="comment">/* Configure pins for UART operation */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(UART_PORT, UART_RX_NUM, <a class="code" href="group__group__gpio__drive_modes.html#gaf2fe5dc00ba1770b37e620a01169485c">CY_GPIO_DM_HIGHZ</a>);</div><div class="line"><a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(UART_PORT, UART_TX_NUM, <a class="code" href="group__group__gpio__drive_modes.html#gacebd8bea6222d742bdfbfd86dabab940">CY_GPIO_DM_STRONG_IN_OFF</a>);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_uart_clock"></a>
Assign Clock Divider</h2>
<p>A clock source must be connected to the SCB block to oversample input and output signals, in this document this clock will be referred as clk_scb. You must use one of available integer or fractional dividers. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign divider type and number for UART */</span></div><div class="line"><span class="preprocessor">#define UART_CLK_DIV_TYPE     (CY_SYSCLK_DIV_8_BIT)</span></div><div class="line"><span class="preprocessor">#define UART_CLK_DIV_NUMBER   (0U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect assigned divider to be a clock source for UART */</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gacb66324e3191006f6d1cee8b29238fb2">Cy_SysClk_PeriphAssignDivider</a>(PCLK_SCB5_CLOCK, UART_CLK_DIV_TYPE, UART_CLK_DIV_NUMBER);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_uart_data_rate"></a>
Configure Baud Rate</h2>
<p>To get the UART to operate with the desired baud rate, the clk_scb frequency and the oversample must be configured. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to configure clk_scb frequency. Set the <em><b>oversample parameter in configuration structure</b></em> to define the number of the SCB clocks within one UART bit-time.</p>
<div class="fragment"><div class="line"><span class="comment">/* UART desired baud rate is 115200 bps (Standard mode).</span></div><div class="line"><span class="comment">* The UART baud rate = (clk_scb / Oversample).</span></div><div class="line"><span class="comment">* For clk_peri = 50 MHz, select divider value 36 and get SCB clock = (50 MHz / 36) = 1,389 MHz.</span></div><div class="line"><span class="comment">* Select Oversample = 12. These setting results UART data rate = 1,389 MHz / 12 = 115750 bps.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gac67931844e6ec06b5ff88f4f3119e127">Cy_SysClk_PeriphSetDivider</a>   (UART_CLK_DIV_TYPE, UART_CLK_DIV_NUMBER, 35UL);</div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga8c626f11b583d8296516bbcf4a22f98e">Cy_SysClk_PeriphEnableDivider</a>(UART_CLK_DIV_TYPE, UART_CLK_DIV_NUMBER);</div></div><!-- fragment --><p> <b>Refer to the technical reference manual (TRM) section UART sub-section Clocking and Oversampling to get information about how to configure the UART to run with desired baud rate.</b></p>
<h2><a class="anchor" id="group_scb_uart_intr"></a>
Configure Interrupt</h2>
<p>The interrupt is optional for the UART operation. To configure interrupt the <a class="el" href="group__group__scb__uart__interrupt__functions.html#ga3e1928d8f20b2685aad02df29b658e3f">Cy_SCB_UART_Interrupt</a> function must be called in the interrupt handler for the selected SCB instance. Also, this interrupt must be enabled in the NVIC. The interrupt must be configured when <a class="el" href="group__group__scb__uart.html#group_scb_uart_hl">High-Level API</a> will be used.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> UART_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__scb__uart__interrupt__functions.html#ga3e1928d8f20b2685aad02df29b658e3f">Cy_SCB_UART_Interrupt</a>(SCB5, &amp;uartContext);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Assign UART interrupt number and priority */</span></div><div class="line"><span class="preprocessor">#define UART_INTR_NUM        ((IRQn_Type) scb_5_interrupt_IRQn)</span></div><div class="line"><span class="preprocessor">#define UART_INTR_PRIORITY   (7U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure (code specific for CM4) */</span></div><div class="line"><a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> uartIntrConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = UART_INTR_NUM,</div><div class="line">    .intrPriority = UART_INTR_PRIORITY,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div><div class="line">(void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;uartIntrConfig, &amp;UART_Isr);</div><div class="line">NVIC_EnableIRQ(UART_INTR_NUM);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_uart_enable"></a>
Enable UART</h2>
<p>Finally, enable the UART operation by calling <a class="el" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905">Cy_SCB_UART_Enable</a>.</p>
<div class="fragment"><div class="line"><span class="comment">/* Enable UART to operate */</span></div><div class="line"><a class="code" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905">Cy_SCB_UART_Enable</a>(SCB5);</div><div class="line"></div><div class="line"><span class="comment">/* Enable global interrupts */</span></div><div class="line">__enable_irq();</div></div><!-- fragment --><h1><a class="anchor" id="group_scb_uart_use_cases"></a>
Common Use Cases</h1>
<p>The UART API is divided into two categories: <a class="el" href="group__group__scb__uart__low__level__functions.html">Low-Level</a> and <a class="el" href="group__group__scb__uart__high__level__functions.html">High-Level</a>. <br />
<em>Do not mix <b>High-Level</b> and <b>Low-Level</b> API because a Low-Level API can adversely affect the operation of a High-Level API.</em></p>
<h2><a class="anchor" id="group_scb_uart_ll"></a>
Low-Level API</h2>
<p>The <a class="el" href="group__group__scb__uart__low__level__functions.html">Low-Level</a> functions allow interacting directly with the hardware and do not use <a class="el" href="group__group__scb__uart__interrupt__functions.html#ga3e1928d8f20b2685aad02df29b658e3f">Cy_SCB_UART_Interrupt</a>. These functions do not require context for operation. Thus, NULL can be passed for context parameter in <a class="el" href="group__group__scb__uart__general__functions.html#gacbc061f623d2fafbcfffcb58c5f2db51">Cy_SCB_UART_Init</a> and <a class="el" href="group__group__scb__uart__general__functions.html#ga2a07f58f9a898202d43bc3b14caab2de">Cy_SCB_UART_Disable</a> instead of a pointer to the context structure.</p>
<ul>
<li>To write data into the TX FIFO, use one of the provided functions: <a class="el" href="group__group__scb__uart__low__level__functions.html#gae8eba8924ed4b8add6e7cabdf25a18fe">Cy_SCB_UART_Put</a>, <a class="el" href="group__group__scb__uart__low__level__functions.html#ga242ad51b987fa6ccfc23f3471182ce36">Cy_SCB_UART_PutArray</a>, <a class="el" href="group__group__scb__uart__low__level__functions.html#gac709dbaa61ae25a05086124f1ffaa0d7">Cy_SCB_UART_PutArrayBlocking</a> or <a class="el" href="group__group__scb__uart__low__level__functions.html#ga4092c34575a47087e08a58529451914b">Cy_SCB_UART_PutString</a>. Note that putting data into the TX FIFO starts data transfer.</li>
<li>To read data from the RX FIFO, use one of the provided functions: <a class="el" href="group__group__scb__uart__low__level__functions.html#ga86ab3686a98a0e215c1f2eeed3ce254f">Cy_SCB_UART_Get</a>, <a class="el" href="group__group__scb__uart__low__level__functions.html#ga509c3f8c4acd406d4253019d28a0eb3a">Cy_SCB_UART_GetArray</a> or <a class="el" href="group__group__scb__uart__low__level__functions.html#ga7d45f3f8f625e2f16341a03a4078698e">Cy_SCB_UART_GetArrayBlocking</a>.</li>
<li>The statuses can be polled using: <a class="el" href="group__group__scb__uart__low__level__functions.html#gaa2d783e45d8b8a9803bb5b667d71f3b9">Cy_SCB_UART_GetRxFifoStatus</a> and <a class="el" href="group__group__scb__uart__low__level__functions.html#ga76218bc016256d8525c9d779a4c2e9aa">Cy_SCB_UART_GetTxFifoStatus</a>. <em>The statuses are <b>W1C (Write 1 to Clear)</b> and after a status is set, it must be cleared.</em> Note that there are statuses evaluated as level. These statuses remain set until an event is true. Therefore, after the clear operation, the status is cleared but then it is restored (if event is still true). Also, the following functions can be used for polling as well <a class="el" href="group__group__scb__uart__low__level__functions.html#ga81aff78dcdc266d6cac81e714afef6c3">Cy_SCB_UART_IsTxComplete</a>, <a class="el" href="group__group__scb__uart__low__level__functions.html#gabc4b66b875dbc70d52adf19170d3a530">Cy_SCB_UART_GetNumInRxFifo</a> and <a class="el" href="group__group__scb__uart__low__level__functions.html#ga0f264dad00ca5fcdf668f20e35e4fcab">Cy_SCB_UART_GetNumInTxFifo</a>.</li>
</ul>
<div class="fragment"><div class="line">uint8_t txBuffer[BUFFER_SIZE];</div><div class="line"></div><div class="line"><span class="comment">/* Initialize txBuffer with command to transfer */</span></div><div class="line">txBuffer[0] = CMD_START_TRANSFER;</div><div class="line">txBuffer[1] = 0x00U;</div><div class="line">txBuffer[2] = 0x01U;</div><div class="line"></div><div class="line"><span class="comment">/* Master: start a transfer. Slave: prepare for a transfer. */</span></div><div class="line"><a class="code" href="group__group__scb__uart__low__level__functions.html#gac709dbaa61ae25a05086124f1ffaa0d7">Cy_SCB_UART_PutArrayBlocking</a>(SCB5, txBuffer, <span class="keyword">sizeof</span>(txBuffer));</div><div class="line"></div><div class="line"><span class="comment">/* Blocking wait for transfer completion */</span></div><div class="line"><span class="keywordflow">while</span> (!<a class="code" href="group__group__scb__uart__low__level__functions.html#ga81aff78dcdc266d6cac81e714afef6c3">Cy_SCB_UART_IsTxComplete</a>(SCB5))</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_uart_hl"></a>
High-Level API</h2>
<p>The <a class="el" href="group__group__scb__uart__high__level__functions.html">High-Level</a> API use <a class="el" href="group__group__scb__uart__interrupt__functions.html#ga3e1928d8f20b2685aad02df29b658e3f">Cy_SCB_UART_Interrupt</a> to execute the transfer. Call <a class="el" href="group__group__scb__uart__high__level__functions.html#ga12cc7712f9cb5e26b28d1d9a3a9576b4">Cy_SCB_UART_Transmit</a> to start transmission. Call <a class="el" href="group__group__scb__uart__high__level__functions.html#gace7421c664f582ab4ad4bade0683f209">Cy_SCB_UART_Receive</a> to start receive operation. After the operation is started the <a class="el" href="group__group__scb__uart__interrupt__functions.html#ga3e1928d8f20b2685aad02df29b658e3f">Cy_SCB_UART_Interrupt</a> handles the data transfer until its completion. Therefore <a class="el" href="group__group__scb__uart__interrupt__functions.html#ga3e1928d8f20b2685aad02df29b658e3f">Cy_SCB_UART_Interrupt</a> must be called inside the user interrupt handler to make the High-Level API work. To monitor status of transmit operation, use <a class="el" href="group__group__scb__uart__high__level__functions.html#ga92ea29d41db81f995b0ff442d6639191">Cy_SCB_UART_GetTransmitStatus</a> and <a class="el" href="group__group__scb__uart__high__level__functions.html#ga4cc7bd2f28ef5e170e663414dba66f8c">Cy_SCB_UART_GetReceiveStatus</a> to monitor receive status appropriately. Alternatively use <a class="el" href="group__group__scb__uart__interrupt__functions.html#gaa14dc3c4f0e5680fbc543d3115eac839">Cy_SCB_UART_RegisterCallback</a> to register callback function to be notified about <a class="el" href="group__group__scb__uart__macros__callback__events.html">UART Callback Events</a>.</p>
<p><b>Receive Operation</b> </p><div class="fragment"><div class="line">uint8_t rxBuffer[BUFFER_SIZE];</div><div class="line"></div><div class="line"><span class="comment">/* Start receive operation (do not check status) */</span></div><div class="line">(void) <a class="code" href="group__group__scb__uart__high__level__functions.html#gace7421c664f582ab4ad4bade0683f209">Cy_SCB_UART_Receive</a>(SCB5, rxBuffer, <span class="keyword">sizeof</span>(rxBuffer), &amp;uartContext);</div><div class="line"></div><div class="line"><span class="comment">/* Blocking wait until buffer is full */</span></div><div class="line"><span class="keywordflow">while</span> (0UL != (<a class="code" href="group__group__scb__uart__macros__receive__status.html#ga5ddb60f6cf8432fb0e2bc15b1a353902">CY_SCB_UART_RECEIVE_ACTIVE</a> &amp; <a class="code" href="group__group__scb__uart__high__level__functions.html#ga4cc7bd2f28ef5e170e663414dba66f8c">Cy_SCB_UART_GetReceiveStatus</a>(SCB5, &amp;uartContext)))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Handle received data */</span></div></div><!-- fragment --><p> <b>Transmit Operation</b> </p><div class="fragment"><div class="line">uint8_t txBuffer[BUFFER_SIZE];</div><div class="line"></div><div class="line"><span class="comment">/* Initialize txBuffer with data to transfer */</span></div><div class="line">txBuffer[0] = CMD_START_TRANSFER;</div><div class="line">txBuffer[1] = 0x00U;</div><div class="line">txBuffer[2] = 0x01U;</div><div class="line"></div><div class="line"><span class="comment">/* Start transmit operation (do not check status) */</span></div><div class="line">(void) <a class="code" href="group__group__scb__uart__high__level__functions.html#ga12cc7712f9cb5e26b28d1d9a3a9576b4">Cy_SCB_UART_Transmit</a>(SCB5, txBuffer, <span class="keyword">sizeof</span>(txBuffer), &amp;uartContext);</div><div class="line"></div><div class="line"><span class="comment">/* Blocking wait for transmission completion */</span></div><div class="line"><span class="keywordflow">while</span> (0UL != (<a class="code" href="group__group__scb__uart__macros__transmit__status.html#gaa640df2a6637fd851cfcce6665ba93f1">CY_SCB_UART_TRANSMIT_ACTIVE</a> &amp; <a class="code" href="group__group__scb__uart__high__level__functions.html#ga92ea29d41db81f995b0ff442d6639191">Cy_SCB_UART_GetTransmitStatus</a>(SCB5, &amp;uartContext)))</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> There is also capability to insert a receive ring buffer that operates between the RX FIFO and the user buffer. The received data is copied into the ring buffer from the RX FIFO. This process runs in the background after the ring buffer operation is started by <a class="el" href="group__group__scb__uart__high__level__functions.html#gaf31baac4127fbab570f27bde1df9c622">Cy_SCB_UART_StartRingBuffer</a>. When <a class="el" href="group__group__scb__uart__high__level__functions.html#gace7421c664f582ab4ad4bade0683f209">Cy_SCB_UART_Receive</a> is called, it first reads data from the ring buffer and then sets up an interrupt to receive more data if the required amount has not yet been read.</p>
<h1><a class="anchor" id="group_scb_uart_dma_trig"></a>
DMA Trigger</h1>
<p>The SCB provides TX and RX output trigger signals that can be routed to the DMA controller inputs. These signals are assigned based on the data availability in the TX and RX FIFOs appropriately.</p>
<ul>
<li>The RX trigger signal is active while the number of data elements in the RX FIFO is greater than the value of RX FIFO level. Use function <a class="el" href="group__group__scb__common__functions.html#ga64d034531ea5eb2695ed018d6a75da68">Cy_SCB_SetRxFifoLevel</a> or set configuration structure rxFifoTriggerLevel parameter to configure RX FIFO level value. <br />
 <em>For example, the RX FIFO has 8 data elements and the RX FIFO level is 0. The RX trigger signal is active until DMA reads all data from the RX FIFO.</em></li>
<li>The TX trigger signal is active while the number of data elements in the TX FIFO is less than the value of TX FIFO level. Use function <a class="el" href="group__group__scb__common__functions.html#ga36285e337c94df91a4ebe5b1ee0fd43d">Cy_SCB_SetTxFifoLevel</a> or set configuration structure txFifoTriggerLevel parameter to configure TX FIFO level value. <br />
 <em>For example, the TX FIFO has 0 data elements (empty) and the TX FIFO level is 7. The TX trigger signal is active until DMA loads TX FIFO with 8 data elements (note that after the first TX load operation, the data element goes to the shift register and TX FIFO is empty).</em></li>
</ul>
<p>To route SCB TX or RX trigger signals to DMA controller use <a class="el" href="group__group__trigmux.html">TrigMux (Trigger Multiplexer)</a> driver API.</p>
<dl class="section note"><dt>Note</dt><dd>To properly handle DMA level request signal activation and de-activation from the SCB peripheral block the DMA Descriptor typically must be configured to re-trigger after 16 Clk_Slow cycles.</dd></dl>
<h1><a class="anchor" id="group_scb_uart_lp"></a>
Low Power Support</h1>
<p>The UART driver provides callback functions to handle power mode transition. The callback <a class="el" href="group__group__scb__uart__low__power__functions.html#gaa26ee4aa1c2ac9fb98daddbfe6e151aa">Cy_SCB_UART_DeepSleepCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca">Cy_SysPm_CpuEnterDeepSleep</a> <a class="el" href="group__group__scb__uart__low__power__functions.html#gad72ab6609be39108f73aea440d229bce">Cy_SCB_UART_HibernateCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#gae97647a28c370674ba57d451d21d1c51">Cy_SysPm_SystemEnterHibernate</a>. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration.</p>
<p>The UART is disabled during Deep Sleep and Hibernate and stops driving the output pins. The state of the UART output pins TX and RTS is High-Z, which can cause unexpected behavior of the UART receiver due to possible glitches on these lines. These pins must be set to the inactive state before entering Deep Sleep or Hibernate mode. These pins must keep the inactive level (the same state when UART TX is enabled and does not transfer data) before entering Deep Sleep or Hibernate mode. To do that, write the GPIO data register of each pin to the inactive level for each output pin. Then configure High-Speed Input Output Multiplexer (HSIOM) of each pin to be controlled by the GPIO (use <a class="el" href="group__group__gpio.html">GPIO (General Purpose Input Output)</a> driver API). After exiting Deep Sleep mode the UART must be enabled and the pins configuration restored to return the UART control of the pins (after exiting Hibernate mode, the system initialization code does the same). Copy either or both <a class="el" href="group__group__scb__uart__low__power__functions.html#gaa26ee4aa1c2ac9fb98daddbfe6e151aa">Cy_SCB_UART_DeepSleepCallback</a> and <a class="el" href="group__group__scb__uart__low__power__functions.html#gad72ab6609be39108f73aea440d229bce">Cy_SCB_UART_HibernateCallback</a> as appropriate, and make the changes described above inside the function. Alternately, external pull-up or pull-down resistors can be connected to the appropriate UART lines to keep them inactive during Deep-Sleep or Hibernate. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__uart__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__uart__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__uart__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__uart__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__uart__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
