<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__syslib__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__syslib.html">SysLib       (System Library)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaad1c32546fdb0e3c6fa8b46fb95843b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a> (uint32_t milliseconds)</td></tr>
<tr class="memdesc:gaad1c32546fdb0e3c6fa8b46fb95843b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function delays by the specified number of milliseconds.  <a href="#gaad1c32546fdb0e3c6fa8b46fb95843b5">More...</a><br /></td></tr>
<tr class="separator:gaad1c32546fdb0e3c6fa8b46fb95843b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2ffe4829c636ad78eaae5043fd6ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga9d2ffe4829c636ad78eaae5043fd6ae6">Cy_SysLib_DelayUs</a> (uint16_t microseconds)</td></tr>
<tr class="memdesc:ga9d2ffe4829c636ad78eaae5043fd6ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function delays by the specified number of microseconds.  <a href="#ga9d2ffe4829c636ad78eaae5043fd6ae6">More...</a><br /></td></tr>
<tr class="separator:ga9d2ffe4829c636ad78eaae5043fd6ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e78e8abc25b8b598fb0b7d50e18c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga58e78e8abc25b8b598fb0b7d50e18c69">Cy_SysLib_DelayCycles</a> (uint32_t cycles)</td></tr>
<tr class="memdesc:ga58e78e8abc25b8b598fb0b7d50e18c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays for the specified number of cycles.  <a href="#ga58e78e8abc25b8b598fb0b7d50e18c69">More...</a><br /></td></tr>
<tr class="separator:ga58e78e8abc25b8b598fb0b7d50e18c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5ef74a64fe1abbc195da55e4acf075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaaf5ef74a64fe1abbc195da55e4acf075">Cy_SysLib_Halt</a> (uint32_t reason)</td></tr>
<tr class="memdesc:gaaf5ef74a64fe1abbc195da55e4acf075"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function halts the CPU but only the CPU which calls the function.  <a href="#gaaf5ef74a64fe1abbc195da55e4acf075">More...</a><br /></td></tr>
<tr class="separator:gaaf5ef74a64fe1abbc195da55e4acf075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe70e0948f5d2b2fb1615b85b0d7d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga0fe70e0948f5d2b2fb1615b85b0d7d7a">Cy_SysLib_AssertFailed</a> (const <a class="el" href="group__group__syslib__macros.html#ga40bb5262bf908c328fbcfbe5d29d0201">char_t</a> *file, uint32_t line)</td></tr>
<tr class="memdesc:ga0fe70e0948f5d2b2fb1615b85b0d7d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores the ASSERT location of the file name (including path to file) and line number in a non-zero init area for debugging.  <a href="#ga0fe70e0948f5d2b2fb1615b85b0d7d7a">More...</a><br /></td></tr>
<tr class="separator:ga0fe70e0948f5d2b2fb1615b85b0d7d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1691f4df41994e7ed9c30ec6495d925f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga1691f4df41994e7ed9c30ec6495d925f">Cy_SysLib_ClearFlashCacheAndBuffer</a> (void)</td></tr>
<tr class="memdesc:ga1691f4df41994e7ed9c30ec6495d925f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function invalidates the flash cache and buffer.  <a href="#ga1691f4df41994e7ed9c30ec6495d925f">More...</a><br /></td></tr>
<tr class="separator:ga1691f4df41994e7ed9c30ec6495d925f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb2c8e123ba3a0376a14871e58230321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__enumerated__types.html#ga97d0b049220b931606e2ae2e144994e1">cy_en_syslib_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gadb2c8e123ba3a0376a14871e58230321">Cy_SysLib_ResetBackupDomain</a> (void)</td></tr>
<tr class="memdesc:gadb2c8e123ba3a0376a14871e58230321"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the backup domain power to avoid the ILO glitch.  <a href="#gadb2c8e123ba3a0376a14871e58230321">More...</a><br /></td></tr>
<tr class="separator:gadb2c8e123ba3a0376a14871e58230321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8aa61d2f8052886c676f4f592d1693d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gac8aa61d2f8052886c676f4f592d1693d">Cy_SysLib_GetResetReason</a> (void)</td></tr>
<tr class="memdesc:gac8aa61d2f8052886c676f4f592d1693d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the cause for the latest reset(s) that occurred in the system.  <a href="#gac8aa61d2f8052886c676f4f592d1693d">More...</a><br /></td></tr>
<tr class="separator:gac8aa61d2f8052886c676f4f592d1693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb4e952584f0c428f58f7b4dbd3ceff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaebb4e952584f0c428f58f7b4dbd3ceff">Cy_SysLib_ClearResetReason</a> (void)</td></tr>
<tr class="memdesc:gaebb4e952584f0c428f58f7b4dbd3ceff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the values of RES_CAUSE and RES_CAUSE2.  <a href="#gaebb4e952584f0c428f58f7b4dbd3ceff">More...</a><br /></td></tr>
<tr class="separator:gaebb4e952584f0c428f58f7b4dbd3ceff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8fb5b7a16fbdfd60cf44d5d8f2c977"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gaaa8fb5b7a16fbdfd60cf44d5d8f2c977">Cy_SysLib_GetUniqueId</a> (void)</td></tr>
<tr class="memdesc:gaaa8fb5b7a16fbdfd60cf44d5d8f2c977"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the silicon unique ID.  <a href="#gaaa8fb5b7a16fbdfd60cf44d5d8f2c977">More...</a><br /></td></tr>
<tr class="separator:gaaa8fb5b7a16fbdfd60cf44d5d8f2c977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7497a4146c1881fe54b655b4324297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gadc7497a4146c1881fe54b655b4324297">Cy_SysLib_SoftResetCM4</a> (void)</td></tr>
<tr class="memdesc:gadc7497a4146c1881fe54b655b4324297"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a CM4 Core software reset using the CM4_PWR_CTL register.  <a href="#gadc7497a4146c1881fe54b655b4324297">More...</a><br /></td></tr>
<tr class="separator:gadc7497a4146c1881fe54b655b4324297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c11de4d75e326dfc00938d95c957fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga5c11de4d75e326dfc00938d95c957fd4">Cy_SysLib_FaultHandler</a> (uint32_t const *faultStackAddr)</td></tr>
<tr class="memdesc:ga5c11de4d75e326dfc00938d95c957fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores the ARM Cortex registers into a non-zero init area for debugging.  <a href="#ga5c11de4d75e326dfc00938d95c957fd4">More...</a><br /></td></tr>
<tr class="separator:ga5c11de4d75e326dfc00938d95c957fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0852597c5a10b76413a7063711043fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga0852597c5a10b76413a7063711043fef">Cy_SysLib_ProcessingFault</a> (void)</td></tr>
<tr class="memdesc:ga0852597c5a10b76413a7063711043fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines how to process the current fault state.  <a href="#ga0852597c5a10b76413a7063711043fef">More...</a><br /></td></tr>
<tr class="separator:ga0852597c5a10b76413a7063711043fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b897f8554957f9393f645d5ab1106c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga8b897f8554957f9393f645d5ab1106c9">Cy_SysLib_SetWaitStates</a> (bool ulpMode, uint32_t clkHfMHz)</td></tr>
<tr class="memdesc:ga8b897f8554957f9393f645d5ab1106c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of clock cycles the cache will wait for, before it samples data coming back from ROM, SRAM, and Flash.  <a href="#ga8b897f8554957f9393f645d5ab1106c9">More...</a><br /></td></tr>
<tr class="separator:ga8b897f8554957f9393f645d5ab1106c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae679f15a1702c159c105b596a8801105"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105">Cy_SysLib_EnterCriticalSection</a> (void)</td></tr>
<tr class="memdesc:gae679f15a1702c159c105b596a8801105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cy_SysLib_EnterCriticalSection disables interrupts and returns a value indicating whether the interrupts were previously enabled.  <a href="#gae679f15a1702c159c105b596a8801105">More...</a><br /></td></tr>
<tr class="separator:gae679f15a1702c159c105b596a8801105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c16343c075610b2888b0693f972b555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syslib__functions.html#ga8c16343c075610b2888b0693f972b555">Cy_SysLib_ExitCriticalSection</a> (uint32_t savedIntrStatus)</td></tr>
<tr class="memdesc:ga8c16343c075610b2888b0693f972b555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enables the interrupts if they were enabled before <a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105" title="Cy_SysLib_EnterCriticalSection disables interrupts and returns a value indicating whether the interru...">Cy_SysLib_EnterCriticalSection()</a> was called.  <a href="#ga8c16343c075610b2888b0693f972b555">More...</a><br /></td></tr>
<tr class="separator:ga8c16343c075610b2888b0693f972b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaad1c32546fdb0e3c6fa8b46fb95843b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad1c32546fdb0e3c6fa8b46fb95843b5">&#9670;&nbsp;</a></span>Cy_SysLib_Delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_Delay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function delays by the specified number of milliseconds. </p>
<p>By default, the number of cycles to delay is calculated based on the <a class="el" href="group__group__system__config__globals.html#gaa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function calls <a class="el" href="group__group__syslib__functions.html#ga58e78e8abc25b8b598fb0b7d50e18c69">Cy_SysLib_DelayCycles()</a> API to generate a delay. If the function parameter (milliseconds) is bigger than CY_DELAY_MS_OVERFLOW constant, then an additional loop runs to prevent an overflow in parameter passed to <a class="el" href="group__group__syslib__functions.html#ga58e78e8abc25b8b598fb0b7d50e18c69">Cy_SysLib_DelayCycles()</a> API. </dd></dl>

</div>
</div>
<a id="ga9d2ffe4829c636ad78eaae5043fd6ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d2ffe4829c636ad78eaae5043fd6ae6">&#9670;&nbsp;</a></span>Cy_SysLib_DelayUs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_DelayUs </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function delays by the specified number of microseconds. </p>
<p>By default, the number of cycles to delay is calculated based on the <a class="el" href="group__group__system__config__globals.html#gaa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microseconds</td><td>The number of microseconds to delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the CPU frequency is a small non-integer number, the actual delay can be up to twice as long as the nominal value. The actual delay cannot be shorter than the nominal one. </dd></dl>

</div>
</div>
<a id="ga58e78e8abc25b8b598fb0b7d50e18c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e78e8abc25b8b598fb0b7d50e18c69">&#9670;&nbsp;</a></span>Cy_SysLib_DelayCycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_DelayCycles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cycles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delays for the specified number of cycles. </p>
<p>The function is implemented in the assembler for each supported compiler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The number of cycles to delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf5ef74a64fe1abbc195da55e4acf075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf5ef74a64fe1abbc195da55e4acf075">&#9670;&nbsp;</a></span>Cy_SysLib_Halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_Halt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function halts the CPU but only the CPU which calls the function. </p>
<p>It doesn't affect other CPUs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The value to be used during debugging.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function executes the BKPT instruction for halting CPU and is intended to be used for the debug purpose. A regular use case requires Debugger attachment before the function call. The BKPT instruction causes the CPU to enter the Debug state. Debug tools can use this to investigate the system state, when the instruction at a particular address is reached.</dd>
<dd>
Execution of a BKPT instruction without a debugger attached produces a fault. The fault results in the HardFault exception being taken or causes a Lockup state if it occurs in the NMI or HardFault handler. The default HardFault handler make a software reset if the build option is the release mode (NDEBUG). If the build option is the debug mode, the system will stay in the infinite loop of the <a class="el" href="group__group__syslib__functions.html#ga0852597c5a10b76413a7063711043fef">Cy_SysLib_ProcessingFault()</a> function. </dd></dl>

</div>
</div>
<a id="ga0fe70e0948f5d2b2fb1615b85b0d7d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe70e0948f5d2b2fb1615b85b0d7d7a">&#9670;&nbsp;</a></span>Cy_SysLib_AssertFailed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_AssertFailed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__syslib__macros.html#ga40bb5262bf908c328fbcfbe5d29d0201">char_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stores the ASSERT location of the file name (including path to file) and line number in a non-zero init area for debugging. </p>
<p>Also it calls the <a class="el" href="group__group__syslib__functions.html#gaaf5ef74a64fe1abbc195da55e4acf075">Cy_SysLib_Halt()</a> function to halt the processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file name of the ASSERT location. </td></tr>
    <tr><td class="paramname">line</td><td>The line number of the ASSERT location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A stored file name and line number could be accessed by cy_assertFileName and cy_assertLine global variables. </dd>
<dd>
This function has the WEAK option, so the user can redefine the function for a custom processing. </dd></dl>

</div>
</div>
<a id="ga1691f4df41994e7ed9c30ec6495d925f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1691f4df41994e7ed9c30ec6495d925f">&#9670;&nbsp;</a></span>Cy_SysLib_ClearFlashCacheAndBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_ClearFlashCacheAndBuffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function invalidates the flash cache and buffer. </p>
<p>It ensures the valid data is read from flash instead of using outdated data from the cache. The caches' LRU structure is also reset to their default state.</p>
<dl class="section note"><dt>Note</dt><dd>The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks. </dd></dl>

</div>
</div>
<a id="gadb2c8e123ba3a0376a14871e58230321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb2c8e123ba3a0376a14871e58230321">&#9670;&nbsp;</a></span>Cy_SysLib_ResetBackupDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__enumerated__types.html#ga97d0b049220b931606e2ae2e144994e1">cy_en_syslib_status_t</a> Cy_SysLib_ResetBackupDomain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the backup domain power to avoid the ILO glitch. </p>
<p>The glitch can occur when the device is reset due to POR/BOD/XRES while the backup voltage is supplied into the system.</p>
<dl class="section note"><dt>Note</dt><dd>Writing 1 to BACKUP-&gt;RESET resets the backup logic. Hardware clears it when the reset is complete. After setting the register, this function reads the register immediately for returning the result of the backup domain reset state. The reading register is important because the Read itself takes multiple AHB clock cycles, and the reset is actually finishing during that time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>CY_SYSLIB_SUCCESS, if BACKUP-&gt;RESET read-back is 0. Otherwise returns CY_SYSLIB_INVALID_STATE. </dd></dl>

</div>
</div>
<a id="gac8aa61d2f8052886c676f4f592d1693d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8aa61d2f8052886c676f4f592d1693d">&#9670;&nbsp;</a></span>Cy_SysLib_GetResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SysLib_GetResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the cause for the latest reset(s) that occurred in the system. </p>
<p>The reset causes include an HFCLK error, system faults, and device reset on a wakeup from Hibernate mode. The return results are consolidated reset causes from reading RES_CAUSE, RES_CAUSE2 and PWR_HIBERNATE token registers.</p>
<dl class="section return"><dt>Returns</dt><dd>The cause of a system reset.</dd></dl>
<table class="doxtable">
<tr>
<th>Name </th><th>Value  </th></tr>
<tr>
<td>CY_SYSLIB_RESET_HWWDT </td><td>0x00001 (bit0) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_ACT_FAULT </td><td>0x00002 (bit1) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_DPSLP_FAULT </td><td>0x00004 (bit2) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_CSV_WCO_LOSS </td><td>0x00008 (bit3) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_SOFT </td><td>0x00010 (bit4) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_SWWDT0 </td><td>0x00020 (bit5) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_SWWDT1 </td><td>0x00040 (bit6) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_SWWDT2 </td><td>0x00080 (bit7) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_SWWDT3 </td><td>0x00100 (bit8) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_HFCLK_LOSS </td><td>0x10000 (bit16) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_HFCLK_ERR </td><td>0x20000 (bit17) </td></tr>
<tr>
<td>CY_SYSLIB_RESET_HIB_WAKEUP </td><td>0x40000 (bit18) </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>CY_SYSLIB_RESET_CSV_WCO_LOSS, CY_SYSLIB_RESET_HFCLK_LOSS and CY_SYSLIB_RESET_HFCLK_ERR causes of a system reset available only if WCO CSV present in the device. </dd></dl>

</div>
</div>
<a id="gaebb4e952584f0c428f58f7b4dbd3ceff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebb4e952584f0c428f58f7b4dbd3ceff">&#9670;&nbsp;</a></span>Cy_SysLib_ClearResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_ClearResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the values of RES_CAUSE and RES_CAUSE2. </p>
<p>Also it clears PWR_HIBERNATE token, which indicates reset event on waking up from HIBERNATE. </p>

</div>
</div>
<a id="gaaa8fb5b7a16fbdfd60cf44d5d8f2c977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8fb5b7a16fbdfd60cf44d5d8f2c977">&#9670;&nbsp;</a></span>Cy_SysLib_GetUniqueId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Cy_SysLib_GetUniqueId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the silicon unique ID. </p>
<p>The ID includes Die lot[3]#, Die Wafer#, Die X, Die Y, Die Sort#, Die Minor and Die Year.</p>
<dl class="section return"><dt>Returns</dt><dd>A combined 64-bit unique ID. [63:57] - DIE_YEAR [56:56] - DIE_MINOR [55:48] - DIE_SORT [47:40] - DIE_Y [39:32] - DIE_X [31:24] - DIE_WAFER [23:16] - DIE_LOT[2] [15: 8] - DIE_LOT[1] [ 7: 0] - DIE_LOT[0] </dd></dl>

</div>
</div>
<a id="gadc7497a4146c1881fe54b655b4324297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc7497a4146c1881fe54b655b4324297">&#9670;&nbsp;</a></span>Cy_SysLib_SoftResetCM4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_SoftResetCM4 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a CM4 Core software reset using the CM4_PWR_CTL register. </p>
<p>The register is accessed by CM0 Core by using a command transferred to SROM API through the IPC channel. When the command is sent, the API waits for the IPC channel release.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only when the CM4 core is in Deep Sleep mode. </dd>
<dd>
This function will not reset CM0+ Core. </dd>
<dd>
This function waits for an IPC channel release state. </dd></dl>

</div>
</div>
<a id="ga5c11de4d75e326dfc00938d95c957fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c11de4d75e326dfc00938d95c957fd4">&#9670;&nbsp;</a></span>Cy_SysLib_FaultHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_FaultHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t const *&#160;</td>
          <td class="paramname"><em>faultStackAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stores the ARM Cortex registers into a non-zero init area for debugging. </p>
<p>This function calls <a class="el" href="group__group__syslib__functions.html#ga0852597c5a10b76413a7063711043fef" title="This function determines how to process the current fault state. ">Cy_SysLib_ProcessingFault()</a> after storing all information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faultStackAddr</td><td>The address of the stack pointer, indicates the lowest address in the fault stack frame to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function stores the fault stack frame only for the first occurred fault. </dd>
<dd>
The PDL doesn't provide an API to analyze the stored register values. The user has to add additional functions for the analysis, if necessary. </dd>
<dd>
The CY_ARM_FAULT_DEBUG macro defines if the Fault Handler is enabled. By default it is set to CY_ARM_FAULT_DEBUG_ENABLED and enables the Fault Handler. If there is a necessity to save memory or have some specific custom handler, etc. then CY_ARM_FAULT_DEBUG should be redefined as CY_ARM_FAULT_DEBUG_DISABLED. To do this, the following definition should be added to the compiler Command Line (through the project Build Settings): "-D CY_ARM_FAULT_DEBUG=0". </dd></dl>

</div>
</div>
<a id="ga0852597c5a10b76413a7063711043fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0852597c5a10b76413a7063711043fef">&#9670;&nbsp;</a></span>Cy_SysLib_ProcessingFault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_ProcessingFault </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines how to process the current fault state. </p>
<p>By default in case of exception the system will stay in the infinite loop of this function.</p>
<dl class="section note"><dt>Note</dt><dd>This function has the WEAK option, so the user can redefine the function behavior for a custom processing. For example, the function redefinition could be constructed from fault stack processing and NVIC_SystemReset() function call. </dd></dl>

</div>
</div>
<a id="ga8b897f8554957f9393f645d5ab1106c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b897f8554957f9393f645d5ab1106c9">&#9670;&nbsp;</a></span>Cy_SysLib_SetWaitStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_SetWaitStates </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ulpMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clkHfMHz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of clock cycles the cache will wait for, before it samples data coming back from ROM, SRAM, and Flash. </p>
<p>Call this function before increasing the HFClk0 High Frequency clock. Call this function optionally after lowering the HFClk0 High Frequency clock in order to improve the CPU performance.</p>
<p>Also, call this function before switching the core supply regulator voltage (LDO or SIMO Buck) from 1.1V to 0.9V. Call this function optionally after switching the core supply regulator voltage from 0.9V to 1.1V in order to improve the CPU performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulpMode</td><td>The device power mode. true if the device should be switched to the ULP mode (nominal voltage of the core supply regulator should be switched to 0.9V); false if the device should be switched to the LP mode (nominal voltage of the core supply regulator should be switched to 1.1V).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Refer to the device TRM for the low power modes description.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clkHfMHz</td><td>The HFClk0 clock frequency in MHz. Specifying a frequency above the supported maximum will set the wait states as for the maximum frequency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae679f15a1702c159c105b596a8801105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae679f15a1702c159c105b596a8801105">&#9670;&nbsp;</a></span>Cy_SysLib_EnterCriticalSection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SysLib_EnterCriticalSection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cy_SysLib_EnterCriticalSection disables interrupts and returns a value indicating whether the interrupts were previously enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current interrupt status. Returns 0 if the interrupts were previously enabled or 1 if the interrupts were previously disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Implementation of Cy_SysLib_EnterCriticalSection manipulates the IRQ enable bit with interrupts still enabled. </dd></dl>

</div>
</div>
<a id="ga8c16343c075610b2888b0693f972b555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c16343c075610b2888b0693f972b555">&#9670;&nbsp;</a></span>Cy_SysLib_ExitCriticalSection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysLib_ExitCriticalSection </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>savedIntrStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-enables the interrupts if they were enabled before <a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105" title="Cy_SysLib_EnterCriticalSection disables interrupts and returns a value indicating whether the interru...">Cy_SysLib_EnterCriticalSection()</a> was called. </p>
<p>The argument should be the value returned from <a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105">Cy_SysLib_EnterCriticalSection()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">savedIntrStatus</td><td>Puts the saved interrupts status returned by the <a class="el" href="group__group__syslib__functions.html#gae679f15a1702c159c105b596a8801105">Cy_SysLib_EnterCriticalSection()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
