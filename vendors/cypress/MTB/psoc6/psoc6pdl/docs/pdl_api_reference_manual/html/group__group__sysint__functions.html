<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__sysint__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__sysint.html">SysInt       (System Interrupt)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab2ff6820a898e9af3f780000054eea5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a> (const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *config, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:gab2ff6820a898e9af3f780000054eea5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the referenced interrupt by setting the priority and the interrupt vector.  <a href="#gab2ff6820a898e9af3f780000054eea5d">More...</a><br /></td></tr>
<tr class="separator:gab2ff6820a898e9af3f780000054eea5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6628d90db5d0e0e8801535e2f1519266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga6628d90db5d0e0e8801535e2f1519266">Cy_SysInt_SetVector</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn, <a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> userIsr)</td></tr>
<tr class="memdesc:ga6628d90db5d0e0e8801535e2f1519266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the ISR vector for the interrupt.  <a href="#ga6628d90db5d0e0e8801535e2f1519266">More...</a><br /></td></tr>
<tr class="separator:ga6628d90db5d0e0e8801535e2f1519266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3feeb7969667eebe109ecab98dbfbb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gac3feeb7969667eebe109ecab98dbfbb2">Cy_SysInt_GetVector</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn)</td></tr>
<tr class="memdesc:gac3feeb7969667eebe109ecab98dbfbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the current ISR vector for the interrupt.  <a href="#gac3feeb7969667eebe109ecab98dbfbb2">More...</a><br /></td></tr>
<tr class="separator:gac3feeb7969667eebe109ecab98dbfbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e3d1e09d83aa163865bcf5f363d7c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn, <a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> devIntrSrc)</td></tr>
<tr class="memdesc:ga59e3d1e09d83aa163865bcf5f363d7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the interrupt selection for the specified NVIC channel.  <a href="#ga59e3d1e09d83aa163865bcf5f363d7c3">More...</a><br /></td></tr>
<tr class="separator:ga59e3d1e09d83aa163865bcf5f363d7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc962aa9f81be5df394ccf2ff746270b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b">Cy_SysInt_GetInterruptSource</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn)</td></tr>
<tr class="memdesc:gacc962aa9f81be5df394ccf2ff746270b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interrupt source of the NVIC channel.  <a href="#gacc962aa9f81be5df394ccf2ff746270b">More...</a><br /></td></tr>
<tr class="separator:gacc962aa9f81be5df394ccf2ff746270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7caa3ebc40ed414983d1330e01dbb932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a> (<a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> devIntrSrc)</td></tr>
<tr class="memdesc:ga7caa3ebc40ed414983d1330e01dbb932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the NVIC channel to which the interrupt source is connected.  <a href="#ga7caa3ebc40ed414983d1330e01dbb932">More...</a><br /></td></tr>
<tr class="separator:ga7caa3ebc40ed414983d1330e01dbb932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e42b44b1946290e12f25ff5042f1fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga9e42b44b1946290e12f25ff5042f1fc0">Cy_SysInt_GetInterruptActive</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn)</td></tr>
<tr class="memdesc:ga9e42b44b1946290e12f25ff5042f1fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the highest priority active interrupt for the selected NVIC channel.  <a href="#ga9e42b44b1946290e12f25ff5042f1fc0">More...</a><br /></td></tr>
<tr class="separator:ga9e42b44b1946290e12f25ff5042f1fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be24fe4952cebbba78e612463981287"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga7be24fe4952cebbba78e612463981287">Cy_SysInt_DisconnectInterruptSource</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn, <a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> devIntrSrc)</td></tr>
<tr class="memdesc:ga7be24fe4952cebbba78e612463981287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the interrupt source from the specified NVIC channel.  <a href="#ga7be24fe4952cebbba78e612463981287">More...</a><br /></td></tr>
<tr class="separator:ga7be24fe4952cebbba78e612463981287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82208c7a076f5f0f750986e84c3d5df0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga82208c7a076f5f0f750986e84c3d5df0">Cy_SysInt_SetNmiSource</a> (<a class="el" href="group__group__sysint__enums.html#ga07f7e918a4abcd8e1da910e9642e6ccb">cy_en_sysint_nmi_t</a> nmiNum, <a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> intrSrc)</td></tr>
<tr class="memdesc:ga82208c7a076f5f0f750986e84c3d5df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt source of the CPU core NMI.  <a href="#ga82208c7a076f5f0f750986e84c3d5df0">More...</a><br /></td></tr>
<tr class="separator:ga82208c7a076f5f0f750986e84c3d5df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb19f0ef37e4b807fc33bd446a185b83"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#gabb19f0ef37e4b807fc33bd446a185b83">Cy_SysInt_GetNmiSource</a> (<a class="el" href="group__group__sysint__enums.html#ga07f7e918a4abcd8e1da910e9642e6ccb">cy_en_sysint_nmi_t</a> nmiNum)</td></tr>
<tr class="memdesc:gabb19f0ef37e4b807fc33bd446a185b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interrupt source of the CPU core NMI for the given NMI source number.  <a href="#gabb19f0ef37e4b807fc33bd446a185b83">More...</a><br /></td></tr>
<tr class="separator:gabb19f0ef37e4b807fc33bd446a185b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61649b025d228f5f2db2e65e5b10e2c6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sysint__functions.html#ga61649b025d228f5f2db2e65e5b10e2c6">Cy_SysInt_SoftwareTrig</a> (<a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> IRQn)</td></tr>
<tr class="memdesc:ga61649b025d228f5f2db2e65e5b10e2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers an interrupt using software (Not applicable for CM0+).  <a href="#ga61649b025d228f5f2db2e65e5b10e2c6">More...</a><br /></td></tr>
<tr class="separator:ga61649b025d228f5f2db2e65e5b10e2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab2ff6820a898e9af3f780000054eea5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2ff6820a898e9af3f780000054eea5d">&#9670;&nbsp;</a></span>Cy_SysInt_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a> Cy_SysInt_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the referenced interrupt by setting the priority and the interrupt vector. </p>
<p>Use the CMSIS core function NVIC_EnableIRQ(config.intrSrc) to enable the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Interrupt configuration structure</td></tr>
    <tr><td class="paramname">userIsr</td><td>Address of the ISR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialization status</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt vector will be relocated only if the vector table was moved to __ramVectors in SRAM. Otherwise it is ignored.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[] */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0 */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line">    <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> intrCfg =</div><div class="line">    {</div><div class="line"><span class="preprocessor">        #if (CY_CPU_CORTEX_M0P)</span></div><div class="line">            <span class="comment">/*.intrSrc =*/</span> NvicMux7_IRQn,               <span class="comment">/* CM0+ interrupt is NVIC #7 */</span></div><div class="line">            <span class="comment">/*.cm0pSrc =*/</span> ioss_interrupts_gpio_0_IRQn, <span class="comment">/* Source of NVIC #7 is GPIO port 0 interrupt */</span></div><div class="line">            <span class="comment">/*.intrPriority =*/</span> 2UL                     <span class="comment">/* Interrupt priority is 2 */</span></div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <span class="comment">/*.intrSrc =*/</span> ioss_interrupts_gpio_0_IRQn, <span class="comment">/* Interrupt source is GPIO port 0 interrupt */</span></div><div class="line">            <span class="comment">/*.intrPriority =*/</span> 4UL                     <span class="comment">/* Interrupt priority is 4 */</span></div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the interrupt with vector at Interrupt_Handler_Port0() */</span></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;intrCfg, &amp;Interrupt_Handler_Port0);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the interrupt */</span></div><div class="line">    NVIC_EnableIRQ(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga6628d90db5d0e0e8801535e2f1519266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6628d90db5d0e0e8801535e2f1519266">&#9670;&nbsp;</a></span>Cy_SysInt_SetVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> Cy_SysInt_SetVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a>&#160;</td>
          <td class="paramname"><em>userIsr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the ISR vector for the interrupt. </p>
<p>This function relies on the assumption that the vector table is relocated to __ramVectors[RAM_VECTORS_SIZE] in SRAM. Otherwise it will return the address of the default ISR location in the flash vector table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>Interrupt source</td></tr>
    <tr><td class="paramname">userIsr</td><td>Address of the ISR to set in the interrupt vector table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous address of the ISR in the interrupt vector table</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For CM0+, this function sets the interrupt vector for the interrupt channel on the NVIC.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[]. The interrupt</span></div><div class="line"><span class="comment">                 was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0 */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(&amp;Interrupt_Handler_Port0 != <a class="code" href="group__group__sysint__functions.html#gac3feeb7969667eebe109ecab98dbfbb2">Cy_SysInt_GetVector</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the port0 interrupt vector to be at Interrupt_Handler_Port0() */</span></div><div class="line">        (void)<a class="code" href="group__group__sysint__functions.html#ga6628d90db5d0e0e8801535e2f1519266">Cy_SysInt_SetVector</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, &amp;Interrupt_Handler_Port0);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gac3feeb7969667eebe109ecab98dbfbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3feeb7969667eebe109ecab98dbfbb2">&#9670;&nbsp;</a></span>Cy_SysInt_GetVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syslib__macros.html#ga71c09beda7671d1f69c8f06a546e2ae6">cy_israddress</a> Cy_SysInt_GetVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the address of the current ISR vector for the interrupt. </p>
<p>This function relies on the assumption that the vector table is relocated to __ramVectors[RAM_VECTORS_SIZE] in SRAM. Otherwise it will return the address of the default ISR location in the flash vector table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>Interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the ISR in the interrupt vector table</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For CM0+, this function returns the interrupt vector for the interrupt channel on the NVIC.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Vector table is relocated to RAM in __ramVectors[]. The interrupt</span></div><div class="line"><span class="comment">                 was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Prototype of ISR function for port interrupt 0 */</span></div><div class="line">    <span class="keywordtype">void</span> Interrupt_Handler_Port0 (<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(&amp;Interrupt_Handler_Port0 != <a class="code" href="group__group__sysint__functions.html#gac3feeb7969667eebe109ecab98dbfbb2">Cy_SysInt_GetVector</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the port0 interrupt vector to be at Interrupt_Handler_Port0() */</span></div><div class="line">        (void)<a class="code" href="group__group__sysint__functions.html#ga6628d90db5d0e0e8801535e2f1519266">Cy_SysInt_SetVector</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, &amp;Interrupt_Handler_Port0);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga59e3d1e09d83aa163865bcf5f363d7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e3d1e09d83aa163865bcf5f363d7c3">&#9670;&nbsp;</a></span>Cy_SysInt_SetInterruptSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_SetInterruptSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>devIntrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the interrupt selection for the specified NVIC channel. </p>
<p>To disconnect the interrupt source from the NVIC channel use the <a class="el" href="group__group__sysint__functions.html#ga7be24fe4952cebbba78e612463981287">Cy_SysInt_DisconnectInterruptSource</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>NVIC channel number connected to the CPU core.</td></tr>
    <tr><td class="paramname">devIntrSrc</td><td>Device interrupt to be routed to the NVIC channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+ core only.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reconfigure the interrupt source of the NVIC input on the CM0+</span></div><div class="line"><span class="comment">                 core at run-time. The interrupt was initialized with the</span></div><div class="line"><span class="comment">                 &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_M4CPUSS_VERSION == 1)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b">Cy_SysInt_GetInterruptSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CY_IP_M4CPUSS_VERSION == 2 */</span><span class="preprocessor"></span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6b8e5744e04c2bb15c10afdb8a96d6b7">cm0pSrc</a>))</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_IP_M4CPUSS_VERSION */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt source for intrCfg.intrSrc on CM0+ */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6b8e5744e04c2bb15c10afdb8a96d6b7">cm0pSrc</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gacc962aa9f81be5df394ccf2ff746270b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc962aa9f81be5df394ccf2ff746270b">&#9670;&nbsp;</a></span>Cy_SysInt_GetInterruptSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> Cy_SysInt_GetInterruptSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the interrupt source of the NVIC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>NVIC channel number connected to the CPU core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device interrupt connected to the NVIC channel. A returned value of "disconnected_IRQn" indicates that the interrupt source is disconnected.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+ core only.</dd>
<dd>
This function supports only devices using CPUSS_ver1. For all other devices, use the <a class="el" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932" title="Gets the NVIC channel to which the interrupt source is connected. ">Cy_SysInt_GetNvicConnection()</a> function.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reconfigure the interrupt source of the NVIC input on the CM0+</span></div><div class="line"><span class="comment">                 core at run-time. The interrupt was initialized with the</span></div><div class="line"><span class="comment">                 &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_M4CPUSS_VERSION == 1)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b">Cy_SysInt_GetInterruptSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CY_IP_M4CPUSS_VERSION == 2 */</span><span class="preprocessor"></span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6b8e5744e04c2bb15c10afdb8a96d6b7">cm0pSrc</a>))</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_IP_M4CPUSS_VERSION */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt source for intrCfg.intrSrc on CM0+ */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6b8e5744e04c2bb15c10afdb8a96d6b7">cm0pSrc</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7caa3ebc40ed414983d1330e01dbb932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7caa3ebc40ed414983d1330e01dbb932">&#9670;&nbsp;</a></span>Cy_SysInt_GetNvicConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> Cy_SysInt_GetNvicConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>devIntrSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the NVIC channel to which the interrupt source is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devIntrSrc</td><td>Device interrupt that is potentially connected to the NVIC channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NVIC channel number connected to the CPU core. A returned value of "unconnected_IRQn" indicates that the interrupt source is disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+ core only.</dd>
<dd>
This function supports only devices using CPUSS_ver2 or higher.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Reconfigure the interrupt source of the NVIC input on the CM0+</span></div><div class="line"><span class="comment">                 core at run-time. The interrupt was initialized with the</span></div><div class="line"><span class="comment">                 &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_IP_M4CPUSS_VERSION == 1)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gacc962aa9f81be5df394ccf2ff746270b">Cy_SysInt_GetInterruptSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CY_IP_M4CPUSS_VERSION == 2 */</span><span class="preprocessor"></span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#ga7caa3ebc40ed414983d1330e01dbb932">Cy_SysInt_GetNvicConnection</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6b8e5744e04c2bb15c10afdb8a96d6b7">cm0pSrc</a>))</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_IP_M4CPUSS_VERSION */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the interrupt source for intrCfg.intrSrc on CM0+ */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga59e3d1e09d83aa163865bcf5f363d7c3">Cy_SysInt_SetInterruptSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6b8e5744e04c2bb15c10afdb8a96d6b7">cm0pSrc</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga9e42b44b1946290e12f25ff5042f1fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e42b44b1946290e12f25ff5042f1fc0">&#9670;&nbsp;</a></span>Cy_SysInt_GetInterruptActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a> Cy_SysInt_GetInterruptActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the highest priority active interrupt for the selected NVIC channel. </p>
<p>The priority of the interrupt in a given channel is determined by the index value of the interrupt in the cy_en_intr_t enum. The lower the index, the higher the priority. E.g. Consider a case where an interrupt source with value 29 and an interrupt source with value 46 both source the same NVIC channel. If both are active (triggered) at the same time, calling <a class="el" href="group__group__sysint__functions.html#ga9e42b44b1946290e12f25ff5042f1fc0" title="Gets the highest priority active interrupt for the selected NVIC channel. ">Cy_SysInt_GetInterruptActive()</a> will return 29 as the active interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>NVIC channel number connected to the CPU core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device interrupt connected to the NVIC channel. A returned value of "disconnected_IRQn" indicates that there are no active (pending) interrupts on this NVIC channel.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+ core only.</dd>
<dd>
This function supports only devices using CPUSS_ver2 or higher.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Inside the interrupt service routine for NvicMux7_IRQn: */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6b8e5744e04c2bb15c10afdb8a96d6b7">cm0pSrc</a> == <a class="code" href="group__group__sysint__functions.html#ga9e42b44b1946290e12f25ff5042f1fc0">Cy_SysInt_GetInterruptActive</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle the ioss_interrupts_gpio_0_IRQn interrupt */</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7be24fe4952cebbba78e612463981287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7be24fe4952cebbba78e612463981287">&#9670;&nbsp;</a></span>Cy_SysInt_DisconnectInterruptSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysInt_DisconnectInterruptSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga8010dee187715cab833c8564fccedc20">cy_en_intr_t</a>&#160;</td>
          <td class="paramname"><em>devIntrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the interrupt source from the specified NVIC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>NVIC channel number connected to the CPU core. This parameter is ignored for devices using CPUSS_ver2.</td></tr>
    <tr><td class="paramname">devIntrSrc</td><td>Device interrupt routed to the NVIC channel. This parameter is ignored for devices using CPUSS_ver1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is available for CM0+ core only.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Disconnect the previously connected interrupt source */</span></div><div class="line"></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#ga7be24fe4952cebbba78e612463981287">Cy_SysInt_DisconnectInterruptSource</a>(intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>, intrCfg.<a class="code" href="structcy__stc__sysint__t.html#a6b8e5744e04c2bb15c10afdb8a96d6b7">cm0pSrc</a>);</div><div class="line">    </div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga82208c7a076f5f0f750986e84c3d5df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82208c7a076f5f0f750986e84c3d5df0">&#9670;&nbsp;</a></span>Cy_SysInt_SetNmiSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SysInt_SetNmiSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga07f7e918a4abcd8e1da910e9642e6ccb">cy_en_sysint_nmi_t</a>&#160;</td>
          <td class="paramname"><em>nmiNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt source of the CPU core NMI. </p>
<p>The interrupt source must be a positive number. Setting the value to "unconnected_IRQn" or "disconnected_IRQn" disconnects the interrupt source from the NMI. Depending on the device, the number of interrupt sources that can provide the NMI trigger signal to the core can vary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmiNum</td><td>NMI source number. CPUSS_ver2 allows up to 4 sources to trigger the core NMI. CPUSS_ver1 allows only one source to trigger the core NMI and the specified NMI number is ignored.</td></tr>
    <tr><td class="paramname">intrSrc</td><td>Interrupt source. This parameter can either be of type cy_en_intr_t or IRQn_Type based on the selected core.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>CM0+ may call this function only at PC=0, CM4 may set its NMI handler at any PC. </dd>
<dd>
The CM0+ NMI is used for performing system calls that execute out of ROM.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Set the NMI trigger source for the processor of interest. The</span></div><div class="line"><span class="comment">                 interrupt was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_CPU_CORTEX_M0P)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gabb19f0ef37e4b807fc33bd446a185b83">Cy_SysInt_GetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CM4 */</span><span class="preprocessor"></span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gabb19f0ef37e4b807fc33bd446a185b83">Cy_SysInt_GetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>))</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_CPU_CORTEX_M0P */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the NMI source to GPIO port 0 interrupt */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga82208c7a076f5f0f750986e84c3d5df0">Cy_SysInt_SetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>, ioss_interrupts_gpio_0_IRQn);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gabb19f0ef37e4b807fc33bd446a185b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb19f0ef37e4b807fc33bd446a185b83">&#9670;&nbsp;</a></span>Cy_SysInt_GetNmiSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a> Cy_SysInt_GetNmiSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga07f7e918a4abcd8e1da910e9642e6ccb">cy_en_sysint_nmi_t</a>&#160;</td>
          <td class="paramname"><em>nmiNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the interrupt source of the CPU core NMI for the given NMI source number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmiNum</td><td>NMI source number. CPUSS_ver2 allows up to 4 sources to trigger the core NMI (i.e. #1, 2, 3, 4). CPUSS_ver1 allows only 1 source to trigger the core NMI (i.e #1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt Source. This parameter can either be of type cy_en_intr_t or IRQn_Type based on the selected core.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Set the NMI trigger source for the processor of interest. The</span></div><div class="line"><span class="comment">                 interrupt was initialized with the &quot;intrCfg&quot; configuration struct. */</span></div><div class="line"><span class="preprocessor">#if (CY_CPU_CORTEX_M0P)</span></div><div class="line">    <span class="keywordflow">if</span>(disconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gabb19f0ef37e4b807fc33bd446a185b83">Cy_SysInt_GetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>))</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* CM4 */</span><span class="preprocessor"></span></div><div class="line">    <span class="keywordflow">if</span>(unconnected_IRQn == <a class="code" href="group__group__sysint__functions.html#gabb19f0ef37e4b807fc33bd446a185b83">Cy_SysInt_GetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>))</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* CY_CPU_CORTEX_M0P */</span><span class="preprocessor"></span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the NMI source to GPIO port 0 interrupt */</span></div><div class="line">        <a class="code" href="group__group__sysint__functions.html#ga82208c7a076f5f0f750986e84c3d5df0">Cy_SysInt_SetNmiSource</a>(<a class="code" href="group__group__sysint__enums.html#gga07f7e918a4abcd8e1da910e9642e6ccbafc6fdeffd7f2d0d790358985ecd3d997">CY_SYSINT_NMI1</a>, ioss_interrupts_gpio_0_IRQn);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga61649b025d228f5f2db2e65e5b10e2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61649b025d228f5f2db2e65e5b10e2c6">&#9670;&nbsp;</a></span>Cy_SysInt_SoftwareTrig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SysInt_SoftwareTrig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers an interrupt using software (Not applicable for CM0+). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IRQn</td><td>Interrupt source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Scenario: Trigger the CM4 interrupt line connected to the GPIO port 0</span></div><div class="line"><span class="comment">                 interrupt from software. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enter processor privileged mode */</span></div><div class="line">    __set_CONTROL(0);</div><div class="line"></div><div class="line">    <span class="comment">/* Trigger the ioss_interrupts_gpio_0_IRQn interrupt using software */</span></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#ga61649b025d228f5f2db2e65e5b10e2c6">Cy_SysInt_SoftwareTrig</a>(ioss_interrupts_gpio_0_IRQn);</div><div class="line"></div><div class="line">    <span class="comment">/* Enter processor user mode */</span></div><div class="line">    __set_CONTROL(1);</div><div class="line"></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only privileged software can enable unprivileged access to the Software Trigger Interrupt Register (STIR). </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
