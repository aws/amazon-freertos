<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Flash        (Flash System Routine)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__flash.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">Flash (Flash System Routine)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Internal flash memory programming. </p>
<p>The functions and other declarations used in this driver are in cy_flash.h. You can include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>Flash memory in PSoC devices provides non-volatile storage for user firmware, user configuration data, and bulk data storage.</p>
<p>Flash operations are implemented as system calls. System calls are executed out of SROM in the privileged mode of operation. Users have no access to read or modify the SROM code. The driver API requests the system call by acquiring the Inter-processor communication (IPC) and writing the SROM function opcode and parameters to its input registers. As a result, an NMI interrupt is invoked and the requested SROM function is executed. The operation status is returned to the driver context and a release interrupt is triggered.</p>
<p>Writing to flash can take up to 20 milliseconds. During this time, the device should not be reset (including XRES pin, software reset, and watchdog) or unexpected changes may be made to portions of the flash. Also, the low-voltage detect circuits should be configured to generate an interrupt instead of a reset.</p>
<p>A Read while Write violation occurs when a flash Read operation is initiated in the same or neighboring (neighboring restriction is applicable just for the CY8C6xx6, CY8C6xx7 devices) flash sector where the flash Write, Erase, or Program operation is working. This violation may cause a HardFault exception. To avoid the Read while Write violation, carefully split the Read and Write operation on flash sectors which are not neighboring, considering both cores in the multi-processor device. If the flash is divided into four equal sectors, you may edit the linker script to place the code into neighboring sectors. For example, use sectors number 0 and 1 for code and sectors 2 and 3 for data storage.</p>
<h1><a class="anchor" id="group_flash_configuration"></a>
Configuration Considerations</h1>
<h2><a class="anchor" id="group_flash_config_intro"></a>
Introduction:</h2>
<p>The PSoC 6 MCU user-programmable Flash consists of:</p><ul>
<li>Application flash memory (from 2 to 8 sectors) - 128KB/256KB each.</li>
<li>EE emulation flash memory - 32KB.</li>
</ul>
<p>Write operation may be done as Blocking or Partially Blocking, defined as follows:</p>
<h2><a class="anchor" id="group_flash_config_blocking"></a>
Blocking:</h2>
<p>In this case, the entire Flash block is not available for the duration of the Write (&sim;16ms). Therefore, no Flash accesses (from any Bus Master) can occur during that time. CPU execution can be performed from SRAM. All pre-fetching must be disabled. Code execution from Flash is blocked for the Flash Write duration for both cores.</p>
<h2><a class="anchor" id="group_flash_config_block_const"></a>
Constraints for Blocking Flash operations:</h2>
<ol type="1">
<li>During write to flash, the device should not be reset (including XRES pin, software reset, and watchdog), or unexpected changes may be made to portions of the flash.</li>
<li>The low-voltage detect circuits should be configured to generate an interrupt instead of a reset.</li>
<li>Flash rite operation is allowed only in one of the following CM4 states:<ol type="a">
<li>CM4 is Active and initialized:<br />
 call <a class="el" href="group__group__system__config__cm4__functions.html#gac44c12fdb0562403fc055e4e8966b557">Cy_SysEnableCM4(CY_CORTEX_M4_APPL_ADDR)</a>. <b>Note:</b> If desired user may put CM4 core in Deep Sleep any time after calling <a class="el" href="group__group__system__config__cm4__functions.html#gac44c12fdb0562403fc055e4e8966b557" title="Sets vector table base address and enables the Cortex-M4 core. ">Cy_SysEnableCM4()</a>.</li>
<li>CM4 is Off and disabled:<br />
 call <a class="el" href="group__group__system__config__cm4__functions.html#ga4df7e46b2841b62a00ab856e5a6f098f" title="Disables the Cortex-M4 core and waits for the mode to take the effect. ">Cy_SysDisableCM4()</a>. <b>Note:</b> In this state Debug mode is not supported.</li>
</ol>
</li>
<li>Flash Write cannot be performed in Ultra Low Power (core voltage 0.9V) mode.</li>
<li>Interrupts must be enabled on both active cores. Do not enter a critical section during flash operation.</li>
<li>For the CY8C6xx6, CY8C6xx7 devices user must guarantee that system pipe interrupts (IPC interrupts 3 and 4) have the highest priority, or at least that pipe interrupts are not interrupted or in a pending state for more than 700 &micro;s.</li>
<li>User must guarantee that during flash write operation no flash read operations are performed by bus masters other than CM0+ and CM4 (DMA and Crypto).</li>
<li>If you do not use the default startup, perform the following steps before any flash write/erase operations: <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* 1. Allocate and initialize IPC semaphores for the system operations */</span></div><div class="line">    <span class="keyword">static</span> uint32_t ipcSemaArray[<a class="code" href="group__group__system__config__user__settings__macro.html#gaba78bac52ffcbd69ab531467fa3caa6d">CY_IPC_SEMA_COUNT</a> / <a class="code" href="group__group__ipc__sema__macros.html#ga7c011c5126248439921e442aab3c6b23">CY_IPC_SEMA_PER_WORD</a>];</div><div class="line"></div><div class="line">    (void) <a class="code" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd">Cy_IPC_Sema_Init</a>(CY_IPC_CHAN_SEMA, <a class="code" href="group__group__system__config__user__settings__macro.html#gaba78bac52ffcbd69ab531467fa3caa6d">CY_IPC_SEMA_COUNT</a>, ipcSemaArray);</div><div class="line"></div><div class="line">    <span class="comment">/* 2. Create an array of endpoint structures and configure an IPC pipe infrastructure */</span></div><div class="line">    <span class="keyword">static</span> <a class="code" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> ipcPipeEpArray[<a class="code" href="group__group__system__config__user__settings__macro.html#ga26b976c68c4fc4e45bc7f400e97c8495">CY_IPC_MAX_ENDPOINTS</a>];</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640">Cy_IPC_Pipe_Config</a>(ipcPipeEpArray);</div><div class="line"></div><div class="line">    <span class="comment">/* 3. Create an array of client callbacks and initialize a system pipe by a configuration structure */</span></div><div class="line">    <span class="keyword">static</span> cy_ipc_pipe_callback_ptr_t sysIpcPipeCbArray[CY_SYS_CYPIPE_CLIENT_CNT];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structcy__stc__ipc__pipe__config__t.html">cy_stc_ipc_pipe_config_t</a> systemIpcPipeConfig =</div><div class="line">    {</div><div class="line">    <span class="comment">/* .ep0ConfigData */</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* .ipcNotifierNumber    */</span>  CY_IPC_INTR_CYPIPE_EP0,</div><div class="line">            <span class="comment">/* .ipcNotifierPriority  */</span>  CY_SYS_INTR_CYPIPE_PRIOR_EP0,</div><div class="line">            <span class="comment">/* .ipcNotifierMuxNumber */</span>  CY_SYS_INTR_CYPIPE_MUX_EP0,</div><div class="line">            <span class="comment">/* .epAddress            */</span>  CY_IPC_EP_CYPIPE_CM0_ADDR,</div><div class="line">            <span class="comment">/* .epConfig             */</span>  CY_SYS_CYPIPE_CONFIG_EP0</div><div class="line">        },</div><div class="line">    <span class="comment">/* .ep1ConfigData */</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* .ipcNotifierNumber    */</span>  CY_IPC_INTR_CYPIPE_EP1,</div><div class="line">            <span class="comment">/* .ipcNotifierPriority  */</span>  CY_SYS_INTR_CYPIPE_PRIOR_EP1,</div><div class="line">            <span class="comment">/* .ipcNotifierMuxNumber */</span>  0u,</div><div class="line">            <span class="comment">/* .epAddress            */</span>  CY_IPC_EP_CYPIPE_CM4_ADDR,</div><div class="line">            <span class="comment">/* .epConfig             */</span>  CY_SYS_CYPIPE_CONFIG_EP1</div><div class="line">        },</div><div class="line">    <span class="comment">/* .endpointClientsCount     */</span>  CY_SYS_CYPIPE_CLIENT_CNT,</div><div class="line">    <span class="comment">/* .endpointsCallbacksArray  */</span>  sysIpcPipeCbArray,</div><div class="line">    <span class="comment">/* .systemPipeIsrHandler     */</span>  &amp;SysIpcPipeIsr</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c">Cy_IPC_Pipe_Init</a>(&amp;systemIpcPipeConfig);</div><div class="line"></div><div class="line">    <span class="comment">/* 4. And finally initialize the flash */</span></div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19">Cy_Flash_Init</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Ensure to run these steps on all the MCU cores */</span></div><div class="line"></div></div><!-- fragment --> </li>
</ol>
<h2><a class="anchor" id="group_flash_config_rww"></a>
Partially Blocking:</h2>
<p>This method has a much shorter time window during which Flash accesses are not allowed. Application code execution from Flash is blocked for only a part of Flash Write duration, for both cores. Blocking duration depends upon the API sequence used.</p>
<p>For API sequence <a class="el" href="group__group__flash__functions.html#ga36c8da8da155cd73eaf3359f3f81af02" title="Starts erasing a single row of flash. ">Cy_Flash_StartEraseRow()</a> + <a class="el" href="group__group__flash__functions.html#gafc57348bb2e6922a65826bccad961fed" title="Starts writing an array of data to a single row of flash. ">Cy_Flash_StartProgram()</a> there are four block-out regions during which Read is blocked. See <b>Figure 1</b>.</p>
<center> <a class="anchor" id=""></a>
<table class="doxtable">
<caption>Table 1 - Block-out periods (timing values are valid just for the CY8C6xx6, CY8C6xx7 devices) </caption>
<tr>
<th>Block-out </th><th>Phase </th><th>Duration  </th></tr>
<tr>
<td>A </td><td>The beginning of the Erase operation </td><td>2ms + 9500 SlowClk cycles  </td></tr>
<tr>
<td>B </td><td>The end of the Erase operation </td><td>0.13ms + 1000 SlowClk cycles  </td></tr>
<tr>
<td>C </td><td>The beginning of the Program operation </td><td>0.8ms + 6000 SlowClk cycles  </td></tr>
<tr>
<td>D </td><td>The end of the Program operation </td><td>0.13ms + 1000 SlowClk cycles  </td></tr>
</table>
</center><p>This allows both cores to execute for about 80% of Flash Write operation - see <b>Figure 1</b>. This capability is important for communication protocols that rely on fast response.</p>
<div class="image">
<img src="flash-rww-diagram.png" alt="flash-rww-diagram.png"/>
<div class="caption">
Figure 1 - Blocking Intervals in Flash Write operation</div></div>
<p> For the <a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292" title="Performs pre-program, erase and then starts programming the flash row with the input data...">Cy_Flash_StartWrite()</a> function, the block-out period is different for the two cores. The core that initiates <a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292" title="Performs pre-program, erase and then starts programming the flash row with the input data...">Cy_Flash_StartWrite()</a> is blocked for two periods:</p><ul>
<li>From start of Erase operation (start of A on Figure 1) till the start of Program operation (end of C on Figure 1).</li>
<li>During D period on <b>Figure 1</b>.</li>
</ul>
<p>The core that performs read/execute is blocked identically to the previous scenario - see <b>Figure 1</b>.</p>
<p>This allows the core that initiates <a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292" title="Performs pre-program, erase and then starts programming the flash row with the input data...">Cy_Flash_StartWrite()</a> to execute for about 20% of Flash Write operation. The other core executes for about 80% of Flash Write operation.</p>
<p>Some constraints must be planned for in the Partially Blocking mode which are described in detail below.</p>
<h2><a class="anchor" id="group_flash_config_rww_const"></a>
Constraints for Partially Blocking Flash operations:</h2>
<ol type="1">
<li>During write to flash, the device should not be reset (including XRES pin, software reset, and watchdog) or unexpected changes may be made to portions of the flash.</li>
<li>The low-voltage detect circuits should be configured to generate an interrupt instead of a reset.</li>
<li>During write to flash, application code should not change the clock settings. Use <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> to ensure flash write operation is finished.</li>
<li>During write to flash, application code should not start the clock measurements (should not call <a class="el" href="group__group__sysclk__calclk__funcs.html#ga0a87e123411d5711344780ddfa492f37" title="Assigns clocks to the clock measurement counters, and starts counting. ">Cy_SysClk_StartClkMeasurementCounters()</a>).</li>
<li>Flash write operation is allowed only in one of the following CM4 states:<ol type="a">
<li>CM4 is Active and initialized:<br />
 call <a class="el" href="group__group__system__config__cm4__functions.html#gac44c12fdb0562403fc055e4e8966b557">Cy_SysEnableCM4(CY_CORTEX_M4_APPL_ADDR)</a>. <b>Note:</b> If desired user may put CM4 core in Deep Sleep any time after calling <a class="el" href="group__group__system__config__cm4__functions.html#gac44c12fdb0562403fc055e4e8966b557" title="Sets vector table base address and enables the Cortex-M4 core. ">Cy_SysEnableCM4()</a>.</li>
<li>CM4 is Off and disabled:<br />
 call <a class="el" href="group__group__system__config__cm4__functions.html#ga4df7e46b2841b62a00ab856e5a6f098f" title="Disables the Cortex-M4 core and waits for the mode to take the effect. ">Cy_SysDisableCM4()</a>. <b>Note:</b> In this state Debug mode is not supported.</li>
</ol>
</li>
<li>Use the following rules for split by sectors. (In this context, read means read of any bus master: CM0+, CM4, DMA, Crypto, etc.)<ol type="a">
<li>Do not write to and read/execute from the same flash sector at the same time. This is true for all sectors.</li>
<li><p class="startli">Writing rules in application flash (this restriction is applicable just for CY8C6xx6, CY8C6xx7 devices):</p><ol type="i">
<li>Any bus master can read/execute from UFLASH S0 and/or S1, during flash write to UFLASH S2 or S3.</li>
<li>Any bus master can read/execute from UFLASH S2 and/or S3, during flash write to UFLASH S0 or S1.</li>
</ol>
<p class="startli"><b>Suggestion:</b> in case of bootloading, it is recommended to place code for CM4 in either S0 or S1. CM0+ code resides in S0. Write data to S2 and S3 sections.</p>
</li>
</ol>
</li>
<li>Flash Write cannot be performed in Ultra Low Power mode (core voltage 0.9V).</li>
<li>Interrupts must be enabled on both active cores. Do not enter a critical section during flash operation.</li>
<li>For the CY8C6xx6, CY8C6xx7 devices user must guarantee that system pipe interrupts (IPC interrupts 3 and 4) have the highest priority, or at least that pipe interrupts are not interrupted or in a pending state for more than 700 &micro;s.</li>
<li>If you do not use the default startup, perform the following steps before any flash write/erase operations: <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* 1. Allocate and initialize IPC semaphores for the system operations */</span></div><div class="line">    <span class="keyword">static</span> uint32_t ipcSemaArray[<a class="code" href="group__group__system__config__user__settings__macro.html#gaba78bac52ffcbd69ab531467fa3caa6d">CY_IPC_SEMA_COUNT</a> / <a class="code" href="group__group__ipc__sema__macros.html#ga7c011c5126248439921e442aab3c6b23">CY_IPC_SEMA_PER_WORD</a>];</div><div class="line"></div><div class="line">    (void) <a class="code" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd">Cy_IPC_Sema_Init</a>(CY_IPC_CHAN_SEMA, <a class="code" href="group__group__system__config__user__settings__macro.html#gaba78bac52ffcbd69ab531467fa3caa6d">CY_IPC_SEMA_COUNT</a>, ipcSemaArray);</div><div class="line"></div><div class="line">    <span class="comment">/* 2. Create an array of endpoint structures and configure an IPC pipe infrastructure */</span></div><div class="line">    <span class="keyword">static</span> <a class="code" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> ipcPipeEpArray[<a class="code" href="group__group__system__config__user__settings__macro.html#ga26b976c68c4fc4e45bc7f400e97c8495">CY_IPC_MAX_ENDPOINTS</a>];</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640">Cy_IPC_Pipe_Config</a>(ipcPipeEpArray);</div><div class="line"></div><div class="line">    <span class="comment">/* 3. Create an array of client callbacks and initialize a system pipe by a configuration structure */</span></div><div class="line">    <span class="keyword">static</span> cy_ipc_pipe_callback_ptr_t sysIpcPipeCbArray[CY_SYS_CYPIPE_CLIENT_CNT];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structcy__stc__ipc__pipe__config__t.html">cy_stc_ipc_pipe_config_t</a> systemIpcPipeConfig =</div><div class="line">    {</div><div class="line">    <span class="comment">/* .ep0ConfigData */</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* .ipcNotifierNumber    */</span>  CY_IPC_INTR_CYPIPE_EP0,</div><div class="line">            <span class="comment">/* .ipcNotifierPriority  */</span>  CY_SYS_INTR_CYPIPE_PRIOR_EP0,</div><div class="line">            <span class="comment">/* .ipcNotifierMuxNumber */</span>  CY_SYS_INTR_CYPIPE_MUX_EP0,</div><div class="line">            <span class="comment">/* .epAddress            */</span>  CY_IPC_EP_CYPIPE_CM0_ADDR,</div><div class="line">            <span class="comment">/* .epConfig             */</span>  CY_SYS_CYPIPE_CONFIG_EP0</div><div class="line">        },</div><div class="line">    <span class="comment">/* .ep1ConfigData */</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* .ipcNotifierNumber    */</span>  CY_IPC_INTR_CYPIPE_EP1,</div><div class="line">            <span class="comment">/* .ipcNotifierPriority  */</span>  CY_SYS_INTR_CYPIPE_PRIOR_EP1,</div><div class="line">            <span class="comment">/* .ipcNotifierMuxNumber */</span>  0u,</div><div class="line">            <span class="comment">/* .epAddress            */</span>  CY_IPC_EP_CYPIPE_CM4_ADDR,</div><div class="line">            <span class="comment">/* .epConfig             */</span>  CY_SYS_CYPIPE_CONFIG_EP1</div><div class="line">        },</div><div class="line">    <span class="comment">/* .endpointClientsCount     */</span>  CY_SYS_CYPIPE_CLIENT_CNT,</div><div class="line">    <span class="comment">/* .endpointsCallbacksArray  */</span>  sysIpcPipeCbArray,</div><div class="line">    <span class="comment">/* .systemPipeIsrHandler     */</span>  &amp;SysIpcPipeIsr</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c">Cy_IPC_Pipe_Init</a>(&amp;systemIpcPipeConfig);</div><div class="line"></div><div class="line">    <span class="comment">/* 4. And finally initialize the flash */</span></div><div class="line">    <a class="code" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19">Cy_Flash_Init</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Ensure to run these steps on all the MCU cores */</span></div><div class="line"></div></div><!-- fragment --> </li>
</ol>
<h2><a class="anchor" id="group_flash_config_emeeprom"></a>
EEPROM section use:</h2>
<p>If you plan to use "cy_em_eeprom" section for different purposes for both of device cores or use <b>Em_EEPROM Middleware</b> together with flash driver write operations you must modify the linker scripts.<br />
 For more information, refer to the <b>Middleware/Cypress Em_EEPROM Middleware Library</b> section of the PDL documentation.</p>
<h1><a class="anchor" id="group_flash_more_information"></a>
More Information</h1>
<p>See the technical reference manual (TRM) for more information about the Flash architecture.</p>
<h1><a class="anchor" id="group_flash_MISRA"></a>
MISRA-C Compliance</h1>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th style="width: 50%;">Description of Deviation(s)  </th></tr>
<tr>
<td>11.4 </td><td>A </td><td>Casting to different object pointer type. </td><td><p class="starttd">The cast of the uint32_t pointer to pipe message structure pointer is used to get transmitted data via the <a class="el" href="group__group__ipc.html">IPC (Inter Process Communication)</a> channel. We cast only one pointer, so there is no way to avoid this cast. </p>
<p class="endtd"></p>
</td></tr>
</table>
<h1><a class="anchor" id="group_flash_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th style="width: 52%;">Changes</th><th>Reason for Change </th></tr>
<tr>
<td rowspan="1">3.40 </td><td>Updated Cy_Flash_OperationStatus() to access protected registers. </td><td>Added PSoC 64 device support.  </td></tr>
<tr>
<td rowspan="1">3.30.4 </td><td>Improved documentation. </td><td>User experience enhancement.  </td></tr>
<tr>
<td rowspan="1">3.30.3 </td><td>Updated documentation to limit devices with the restrictions. Improved calculation of the CY_FLASH_DELAY_CORRECTIVE macro. </td><td>User experience enhancement.  </td></tr>
<tr>
<td rowspan="1">3.30.2 </td><td>Updated documentation to limit devices with the neighboring restriction. </td><td>User experience enhancement.  </td></tr>
<tr>
<td rowspan="1">3.30.1 </td><td>Used the CY_RAMFUNC_BEGIN and CY_RAMFUNC_END macros that allocate the function in RAM instead of using the CY_SECTION(".cy_ramfunc") macros. </td><td>Removed the code duplication.  </td></tr>
<tr>
<td rowspan="3">3.30 </td><td>Moved ipcWaitMessageStc structure to the RAM section called ".cy_sharedmem". </td><td>Support Secure Boot devices.  </td></tr>
<tr>
<td>Renamed Function Cy_Flash_StartErase() to <a class="el" href="group__group__flash__functions.html#ga36c8da8da155cd73eaf3359f3f81af02" title="Starts erasing a single row of flash. ">Cy_Flash_StartEraseRow()</a>. </td><td>The driver improvements based on the usability feedback.  </td></tr>
<tr>
<td>Added new API functions <a class="el" href="group__group__flash__functions.html#ga23e040ae57d5c4f717b1918eda77ecc5">Cy_Flash_EraseSector</a>, <a class="el" href="group__group__flash__functions.html#ga42900a5b1b692efc825083c262cc2d7d">Cy_Flash_StartEraseSector</a>, <a class="el" href="group__group__flash__functions.html#gadb9cf4bec4ce4202604823cf0feb70ac">Cy_Flash_EraseSubsector</a>, <a class="el" href="group__group__flash__functions.html#ga732a0c229dd1acee3b36f1bba0045976">Cy_Flash_StartEraseSubsector</a>  </td><td>The driver improvements based on the usability feedback.  </td></tr>
<tr>
<td rowspan="3">3.20 </td><td>Flattened the organization of the driver source code into the single source directory and the single include directory. </td><td>Driver library directory-structure simplification.  </td></tr>
<tr>
<td>Added new API function <a class="el" href="group__group__flash__functions.html#ga3daa482b7696dcb6e06f0776e0ca725a">Cy_Flash_InitExt</a> </td><td>The driver improvements based on the usability feedback  </td></tr>
<tr>
<td>Added register access layer. Use register access macros instead of direct register access using dereferenced pointers. </td><td>Makes register access device-independent, so that the PDL does not need to be recompiled for each supported part number.  </td></tr>
<tr>
<td>3.11 </td><td>Updated driver functionality to correctly use the SysClk measurement counters while partially blocking flash operations </td><td>Added arbiter mechanism for correct usage of the SysClk measurement counters  </td></tr>
<tr>
<td>3.10 </td><td>Updated Cy_Flash_SendCmd() code to support single core devices. </td><td>Support new devices  </td></tr>
<tr>
<td>3.0 </td><td>New function - <a class="el" href="group__group__flash__functions.html#ga5218274c43e64791cf28f902d15a355a" title="This function writes an array of data to a single row of flash. ">Cy_Flash_ProgramRow()</a>;<br />
 Updated <a class="el" href="group__group__flash__functions.html#ga29ac711091186d8a7790be298fb6148b" title="Returns a checksum value of the specified flash row. ">Cy_Flash_RowChecksum()</a>: changed input parameter to take the <b>row address</b> (rowAddr) instead of the <b>row number</b> (rowNum);<br />
 Renamed macro for disabling RWW support in driver to <b>CY_FLASH_RWW_DRV_SUPPORT_DISABLED</b>.<br />
 Updated <a class="el" href="group__group__flash.html#group_flash_configuration">Configuration Considerations</a> documentation section with flash usage constraints. </td><td>Improvements made based on usability feedback to use a common interface  </td></tr>
<tr>
<td rowspan="3">2.0 </td><td>Added non-blocking erase function - Cy_Flash_StartErase(). Removed the clear cache function call. </td><td>The clear cache operation is removed from the blocking Write/Erase function because in this case it is performed by the hardware. Otherwise it is documented that it is the user's responsibility to clear the cache after executing the non-blocking Write/Erase flash operation.  </td></tr>
<tr>
<td>Added new <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d" title="Reports a successful operation result, reason of failure or busy status ( CY_FLASH_DRV_OPCODE_BUSY )...">Cy_Flash_IsOperationComplete()</a> function to check completeness. Obsoleted Cy_Flash_IsWriteComplete(), Cy_Flash_IsProgramComplete(), and Cy_Flash_IsEraseComplete() functions.<br />
 Added <a class="el" href="group__group__flash__functions.html#ga607931427f2d4a2147c7c97ce96577e0" title="This function handles the case where a module such as security image captures a system call from this...">Cy_Flash_GetExternalStatus()</a> function to get unparsed status where flash driver will be used in security applications with other modules as SecureImage.<br />
 Added <a class="el" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19" title="Initiates all needed prerequisites to support flash erase/write. ">Cy_Flash_Init()</a> function to initialize all needed prerequisites for Erase/Write operations. </td><td>Updated driver design to improve user experience.  </td></tr>
<tr>
<td>Updated driver implementation to remove MISRA rules deviations. </td><td>Driver implementation quality improvement.  </td></tr>
<tr>
<td>1.0 </td><td>Initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__flash__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__flash__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__flash__enumerated__types"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__enumerated__types.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
