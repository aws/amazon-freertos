<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Slave</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__i2c__slave__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Slave<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a> &raquo; <a class="el" href="group__group__scb__i2c.html">I2C (SCB)</a> &raquo; <a class="el" href="group__group__scb__i2c__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga179b4495d7255567bb8b166e16e5a073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, uint8_t *buffer, uint32_t size, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:ga179b4495d7255567bb8b166e16e5a073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the buffer pointer and the read buffer size.  <a href="#ga179b4495d7255567bb8b166e16e5a073">More...</a><br /></td></tr>
<tr class="separator:ga179b4495d7255567bb8b166e16e5a073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9f6c807f4758016bf90cc8f69f96b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#ga1c9f6c807f4758016bf90cc8f69f96b3">Cy_SCB_I2C_SlaveAbortRead</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1c9f6c807f4758016bf90cc8f69f96b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the configured slave read buffer to be read by the master.  <a href="#ga1c9f6c807f4758016bf90cc8f69f96b3">More...</a><br /></td></tr>
<tr class="separator:ga1c9f6c807f4758016bf90cc8f69f96b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2d216e9cb246dd2256521cb7f50170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, uint8_t *buffer, uint32_t size, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:gaaf2d216e9cb246dd2256521cb7f50170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the buffer pointer and size of the write buffer.  <a href="#gaaf2d216e9cb246dd2256521cb7f50170">More...</a><br /></td></tr>
<tr class="separator:gaaf2d216e9cb246dd2256521cb7f50170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50157a71ba992433bd4fde948d25d44e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#ga50157a71ba992433bd4fde948d25d44e">Cy_SCB_I2C_SlaveAbortWrite</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:ga50157a71ba992433bd4fde948d25d44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the configured slave write buffer to be written by the master.  <a href="#ga50157a71ba992433bd4fde948d25d44e">More...</a><br /></td></tr>
<tr class="separator:ga50157a71ba992433bd4fde948d25d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e1c474d6a5c7c5547ea08aa5d59e22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#gab3e1c474d6a5c7c5547ea08aa5d59e22">Cy_SCB_I2C_SlaveGetStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *context)</td></tr>
<tr class="memdesc:gab3e1c474d6a5c7c5547ea08aa5d59e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current I2C slave status.  <a href="#gab3e1c474d6a5c7c5547ea08aa5d59e22">More...</a><br /></td></tr>
<tr class="separator:gab3e1c474d6a5c7c5547ea08aa5d59e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9499272c3ec7013ec130291239793199"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#ga9499272c3ec7013ec130291239793199">Cy_SCB_I2C_SlaveClearReadStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:ga9499272c3ec7013ec130291239793199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the read status and error conditions flags and returns their values.  <a href="#ga9499272c3ec7013ec130291239793199">More...</a><br /></td></tr>
<tr class="separator:ga9499272c3ec7013ec130291239793199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73636c22f0db8c09d790f387aa35e6be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#ga73636c22f0db8c09d790f387aa35e6be">Cy_SCB_I2C_SlaveClearWriteStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:ga73636c22f0db8c09d790f387aa35e6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the write status flags and error condition flags and returns their values.  <a href="#ga73636c22f0db8c09d790f387aa35e6be">More...</a><br /></td></tr>
<tr class="separator:ga73636c22f0db8c09d790f387aa35e6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8f2f880c12a526b2e459f3137c45d5c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#gaf8f2f880c12a526b2e459f3137c45d5c">Cy_SCB_I2C_SlaveGetReadTransferCount</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *context)</td></tr>
<tr class="memdesc:gaf8f2f880c12a526b2e459f3137c45d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes read by the master since the last time <a class="el" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> was called.  <a href="#gaf8f2f880c12a526b2e459f3137c45d5c">More...</a><br /></td></tr>
<tr class="separator:gaf8f2f880c12a526b2e459f3137c45d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf4dc1cc3f14c3ba9aa4679ca25c186"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html#ga3cf4dc1cc3f14c3ba9aa4679ca25c186">Cy_SCB_I2C_SlaveGetWriteTransferCount</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga3cf4dc1cc3f14c3ba9aa4679ca25c186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes written by the master since the last time <a class="el" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a> was called.  <a href="#ga3cf4dc1cc3f14c3ba9aa4679ca25c186">More...</a><br /></td></tr>
<tr class="separator:ga3cf4dc1cc3f14c3ba9aa4679ca25c186"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga179b4495d7255567bb8b166e16e5a073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga179b4495d7255567bb8b166e16e5a073">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveConfigReadBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_I2C_SlaveConfigReadBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the buffer pointer and the read buffer size. </p>
<p>This is the buffer from which the master reads data. After this function is called, data transfer from the read buffer to the master is handled by <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a>.</p>
<p>When the Read transaction is completed (master generated Stop, ReStart or error occurred), the <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga2e400c423f7250710ddda059ff554c10">CY_SCB_I2C_SLAVE_RD_BUSY</a> status is cleared and the <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga8445a80c064b85b48f4cb89afa4880ae">CY_SCB_I2C_SLAVE_RD_CMPLT</a> is set. Also the <a class="el" href="group__group__scb__i2c__macros__callback__events.html#gae44345d38014821cc5d5c918dd074324">CY_SCB_I2C_SLAVE_RD_CMPLT_EVENT</a> event is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to the buffer with data to be read by the master.</td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The Read buffer must not be modified and stay allocated until it has been read by the master.</li>
<li>If this function has not been called, and the master tries to read data from the slave a <a class="el" href="group__group__scb__i2c__macros.html#gad56a26de596ed39516b91adc50db4bf9">CY_SCB_I2C_DEFAULT_TX</a> is returned to the master.</li>
<li>If the master tries to read more bytes than available in the Read buffer, a <a class="el" href="group__group__scb__i2c__macros__callback__events.html#gada6c481df3423c3c0d7db05fd626534a">CY_SCB_I2C_SLAVE_RD_BUF_EMPTY_EVENT</a> event occurs. The <a class="el" href="group__group__scb__i2c__macros.html#gad56a26de596ed39516b91adc50db4bf9">CY_SCB_I2C_DEFAULT_TX</a> is returned to the master if the buffer remains empty after an event notification. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1c9f6c807f4758016bf90cc8f69f96b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9f6c807f4758016bf90cc8f69f96b3">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveAbortRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_I2C_SlaveAbortRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the configured slave read buffer to be read by the master. </p>
<p>If the master reads and "abort operation" is requested, the <a class="el" href="group__group__scb__i2c__macros__callback__events.html#gada6c481df3423c3c0d7db05fd626534a">CY_SCB_I2C_SLAVE_RD_BUF_EMPTY_EVENT</a> event occurs. The <a class="el" href="group__group__scb__i2c__macros.html#gad56a26de596ed39516b91adc50db4bf9">CY_SCB_I2C_DEFAULT_TX</a> is returned to the master if the buffer remains empty after the event notification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Side Effects</dt><dd>If the TX FIFO is used, this function clears it. The TX FIFO clear operation also clears the shift register, thus the shifter can be cleared in the middle of a data element transfer, corrupting it. The data element corruption means that all bits that have not been transmitted are transmitted as "ones" on the bus. </dd></dl>

</div>
</div>
<a id="gaaf2d216e9cb246dd2256521cb7f50170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf2d216e9cb246dd2256521cb7f50170">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveConfigWriteBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_I2C_SlaveConfigWriteBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the buffer pointer and size of the write buffer. </p>
<p>This is the buffer that the master writes data to. After this function is called data transfer from the master into the write buffer is handled by <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a>.</p>
<p>When write transaction is completed (master generated Stop, ReStart or error occurred) the <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga53cab9166005ca6c89ed24a4871bb5bd">CY_SCB_I2C_SLAVE_WR_BUSY</a> status is cleared and the <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga0e917e7b1f8b297bb97716a0a742a14a">CY_SCB_I2C_SLAVE_WR_CMPLT</a> is set, also the <a class="el" href="group__group__scb__i2c__macros__callback__events.html#gaa509ff3cd20d1b1d31e3c22e7c28871f">CY_SCB_I2C_SLAVE_WR_CMPLT_EVENT</a> event is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to buffer to store data written by the master.</td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The write buffer must not be modified and must stay allocated until it has been written by the master.</li>
<li>If this function has not been called and the master tries to write data, the first byte is NAKed and discarded.</li>
<li>If the master writes more bytes than the slave can store in the write buffer, the <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga72fb4c9b77ebeb06e36f7b74eb9f0a6f">CY_SCB_I2C_SLAVE_WR_OVRFL</a> status is set and the slave will NACK last byte, unless the RX FIFO is used. Then the slave will NAK only after RX FIFO becomes full.</li>
<li>If the RX FIFO is used, the minimum write buffer size is automatically the size of the RX FIFO. If a write buffer is less than the RX FIFO size, extra bytes are ACKed and stored into RX FIFO but ignored by firmware. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga50157a71ba992433bd4fde948d25d44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50157a71ba992433bd4fde948d25d44e">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveAbortWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_I2C_SlaveAbortWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the configured slave write buffer to be written by the master. </p>
<p>If master writes and an "abort operation" is requested, the next incoming byte will be NAKed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the RX FIFO is used, the NAK will not be sent until RX FIFO becomes full, however bytes accepted after an abort request are ignored. </dd></dl>

</div>
</div>
<a id="gab3e1c474d6a5c7c5547ea08aa5d59e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3e1c474d6a5c7c5547ea08aa5d59e22">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveGetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SCB_I2C_SlaveGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current I2C slave status. </p>
<p>This status is a bit mask and the value returned may have multiple bits set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__i2c__macros__slave__status.html">I2C Slave Status</a>. </dd></dl>

</div>
</div>
<a id="ga9499272c3ec7013ec130291239793199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9499272c3ec7013ec130291239793199">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveClearReadStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SCB_I2C_SlaveClearReadStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the read status and error conditions flags and returns their values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__i2c__macros__slave__status.html">I2C Slave Status</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga2e400c423f7250710ddda059ff554c10">CY_SCB_I2C_SLAVE_RD_BUSY</a> flag is not cleared. </dd></dl>

</div>
</div>
<a id="ga73636c22f0db8c09d790f387aa35e6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73636c22f0db8c09d790f387aa35e6be">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveClearWriteStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SCB_I2C_SlaveClearWriteStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the write status flags and error condition flags and returns their values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__i2c__macros__slave__status.html">I2C Slave Status</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga53cab9166005ca6c89ed24a4871bb5bd">CY_SCB_I2C_SLAVE_WR_BUSY</a> flag is not cleared. </dd></dl>

</div>
</div>
<a id="gaf8f2f880c12a526b2e459f3137c45d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8f2f880c12a526b2e459f3137c45d5c">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveGetReadTransferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SCB_I2C_SlaveGetReadTransferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes read by the master since the last time <a class="el" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> was called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read by the master.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function returns an invalid value if a read transaction was aborted or any listed event occurs during the transaction: <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga63fcc61bddf39d12a85172f776a34d7b">CY_SCB_I2C_SLAVE_ARB_LOST</a>, <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga70d17df38c669816f83e69ac8ab02753">CY_SCB_I2C_SLAVE_BUS_ERR</a>.</li>
<li>This number is updated only when a transaction completes, either through an error or successfully. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3cf4dc1cc3f14c3ba9aa4679ca25c186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cf4dc1cc3f14c3ba9aa4679ca25c186">&#9670;&nbsp;</a></span>Cy_SCB_I2C_SlaveGetWriteTransferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SCB_I2C_SlaveGetWriteTransferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes written by the master since the last time <a class="el" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a> was called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written by the master.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function returns an invalid value if write transaction was aborted or any listed event occurs during the transaction: <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga63fcc61bddf39d12a85172f776a34d7b">CY_SCB_I2C_SLAVE_ARB_LOST</a>, <a class="el" href="group__group__scb__i2c__macros__slave__status.html#ga70d17df38c669816f83e69ac8ab02753">CY_SCB_I2C_SLAVE_BUS_ERR</a>.</li>
<li>This number is updated only when the transaction completes, either through an error or successfully. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
