<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: I2C (SCB)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__i2c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">I2C (SCB)<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Driver API for I2C Bus Peripheral. </p>
<p>I2C - The Inter-Integrated Circuit (I2C) bus is an industry-standard.</p>
<p>The functions and other declarations used in this part of the driver are in cy_scb_i2c.h. You can also include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>The I2C peripheral driver provides an API to implement I2C slave, master, or master-slave devices based on the SCB hardware block. I2C devices based on SCB hardware are compatible with I2C Standard-mode, Fast-mode, and Fast-mode Plus specifications as defined in the I2C-bus specification.</p>
<p>Features:</p><ul>
<li>An industry-standard I2C bus interface</li>
<li>Supports slave, master, and master-slave operation</li>
<li>Supports standard data rates of 100/400/1000 kbps</li>
<li>Hardware Address Match, multiple addresses</li>
<li>Wake from Deep Sleep on Address Match</li>
</ul>
<h1><a class="anchor" id="group_scb_i2c_configuration"></a>
Configuration Considerations</h1>
<p>The I2C driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_config">Configure I2C</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_data_rate">Configure Data Rate</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_enable">Enable I2C</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>I2C driver is built on top of the SCB hardware block. The SCB3 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_config"></a>
Configure I2C</h2>
<p>To set up the I2C driver, provide the configuration parameters in the <a class="el" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> structure. Provide i2cMode to the select operation mode slave, master or master-slave. The useRxFifo and useTxFifo parameters specify if RX and TX FIFO is used during operation. Typically, both FIFOs should be enabled to reduce possibility of clock stringing. However, using RX FIFO has side effects that needs to be taken into account (see useRxFifo field description in <a class="el" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> structure). For master modes, parameters lowPhaseDutyCycle, highPhaseDutyCycle and enableDigitalFilter can be used to define output data rate (refer to section <a class="el" href="group__group__scb__i2c.html#group_scb_i2c_data_rate">Configure Data Rate</a> for more information). For slave mode, provide the slaveAddress and slaveAddressMask. The other parameters are optional for operation.<br />
To initialize the driver, call <a class="el" href="group__group__scb__i2c__general__functions.html#ga91fbfb16a78c014fd88681b83544c2f7">Cy_SCB_I2C_Init</a> function providing a pointer to the populated <a class="el" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> structure and the allocated <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> structure.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate context for I2C operation */</span></div><div class="line"><a class="code" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> i2cContext;</div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure */</span></div><div class="line"><span class="preprocessor">#if (USE_I2C_SLAVE)</span></div><div class="line">    <span class="comment">/* Slave configuration */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> i2cConfig =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__scb__i2c__config__t.html#ab317c1252433320bfd76d2b8629dac23">i2cMode</a>   = <a class="code" href="group__group__scb__i2c__enums.html#gga848386100a4d9700bf5bb790b3db3ed2a9ceefa04abbb537720c9924350b5e179">CY_SCB_I2C_SLAVE</a>,</div><div class="line">        .useRxFifo = <span class="keyword">false</span>,</div><div class="line">        .useTxFifo = <span class="keyword">true</span>,</div><div class="line">        .slaveAddress     = 0x08U,</div><div class="line">        .slaveAddressMask = 0xFEU,</div><div class="line">        .acceptAddrInFifo = <span class="keyword">false</span>,</div><div class="line">        .ackGeneralAddr   = <span class="keyword">false</span>,</div><div class="line">        .enableWakeFromSleep = <span class="keyword">false</span>,</div><div class="line">        .enableDigitalFilter = <span class="keyword">false</span>,</div><div class="line">        .lowPhaseDutyCycle = 0U,</div><div class="line">        .highPhaseDutyCycle = 0U,</div><div class="line">    };</div><div class="line"><span class="preprocessor">#else </span><span class="comment">/* USE_I2C_MASTER */</span><span class="preprocessor"></span></div><div class="line">    <span class="comment">/* Master  configuration */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> i2cConfig =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__scb__i2c__config__t.html#ab317c1252433320bfd76d2b8629dac23">i2cMode</a>   = <a class="code" href="group__group__scb__i2c__enums.html#gga848386100a4d9700bf5bb790b3db3ed2ac1dc09a53d6852a737909498356978c6">CY_SCB_I2C_MASTER</a>,</div><div class="line">        .useRxFifo = <span class="keyword">false</span>,</div><div class="line">        .useTxFifo = <span class="keyword">true</span>,</div><div class="line">        .slaveAddress     = 0U,</div><div class="line">        .slaveAddressMask = 0U,</div><div class="line">        .acceptAddrInFifo = <span class="keyword">false</span>,</div><div class="line">        .ackGeneralAddr   = <span class="keyword">false</span>,</div><div class="line">        .enableWakeFromSleep = <span class="keyword">false</span>,</div><div class="line">        .enableDigitalFilter = <span class="keyword">false</span>,</div><div class="line">        .lowPhaseDutyCycle = 8U,</div><div class="line">        .highPhaseDutyCycle = 8U,</div><div class="line">    };</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">/* Configure I2C to operate */</span></div><div class="line">(void) <a class="code" href="group__group__scb__i2c__general__functions.html#ga91fbfb16a78c014fd88681b83544c2f7">Cy_SCB_I2C_Init</a>(SCB3, &amp;i2cConfig, &amp;i2cContext);</div></div><!-- fragment --><p> Set up I2C slave read and write buffer before enabling its operation using <a class="el" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> and <a class="el" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a> appropriately. Note that the master reads data from the slave read buffer and writes data into the slave write buffer.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate buffers for I2C slave operation */</span></div><div class="line"><span class="preprocessor">#define BUFFER_SIZE (128UL)</span></div><div class="line">uint8_t i2cReadBuffer[BUFFER_SIZE];</div><div class="line">uint8_t i2cWriteBuffer[BUFFER_SIZE];</div><div class="line"></div><div class="line"><span class="comment">/* Configure write and read buffers for communication with master */</span></div><div class="line"><a class="code" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> (SCB3, i2cReadBuffer,  BUFFER_SIZE, &amp;i2cContext);</div><div class="line"><a class="code" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a>(SCB3, i2cWriteBuffer, BUFFER_SIZE, &amp;i2cContext);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_pins"></a>
Assign and Configure Pins</h2>
<p>Only dedicated SCB pins can be used for I2C operation. The HSIOM register must be configured to connect dedicated SCB I2C pins to the SCB block. Also the I2C pins must be configured in Open-Drain, Drives Low mode (this pins configuration implies usage of external pull-up resistors):</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign pins for I2C on SCB3: P6[0] and P6[1] */</span></div><div class="line"><span class="preprocessor">#define I2C_PORT      (P6_0_PORT)</span></div><div class="line"><span class="preprocessor">#define I2C_SCL_NUM   (P6_0_NUM)</span></div><div class="line"><span class="preprocessor">#define I2C_SDA_NUM   (P6_1_NUM)</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect SCB3 I2C function to pins */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(I2C_PORT, I2C_SCL_NUM, P6_0_SCB3_I2C_SCL);</div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(I2C_PORT, I2C_SDA_NUM, P6_1_SCB3_I2C_SDA);</div><div class="line"></div><div class="line"><span class="comment">/* Configure pins for I2C operation */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(I2C_PORT, I2C_SCL_NUM, <a class="code" href="group__group__gpio__drive_modes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div><div class="line"><a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(I2C_PORT, I2C_SDA_NUM, <a class="code" href="group__group__gpio__drive_modes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The alternative pins configuration is Resistive Pull-ups which implies usage internal pull-up resistors. This configuration is not recommended because resistor value is fixed and cannot be used for all supported data rates. Refer to the device datasheet parameter RPULLUP for resistor value specifications.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_clock"></a>
Assign Clock Divider</h2>
<p>A clock source must be connected to the SCB block to oversample input and output signals, in this document this clock will be referred as clk_scb. You must use one of the 8-bit or 16-bit dividers. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign divider type and number for I2C */</span></div><div class="line"><span class="preprocessor">#define I2C_CLK_DIV_TYPE  (CY_SYSCLK_DIV_8_BIT)</span></div><div class="line"><span class="preprocessor">#define I2C_CLK_DIV_NUM   (0U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect assigned divider to be a clock source for I2C */</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gacb66324e3191006f6d1cee8b29238fb2">Cy_SysClk_PeriphAssignDivider</a>(PCLK_SCB3_CLOCK, I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUM);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_data_rate"></a>
Configure Data Rate</h2>
<p>To get I2C slave operation with the desired data rate, the clk_scb must be fast enough to provide sufficient oversampling. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"><div class="line"><span class="comment">/* I2C slave desired data rate is 400 kbps.</span></div><div class="line"><span class="comment">* To support this data rate the clk_scb frequency must be in range 7.82 – 15.38 MHz.</span></div><div class="line"><span class="comment">* Find clk_scb valid ranges in TRM section I2C sub-section Oversampling and Bit Rate.</span></div><div class="line"><span class="comment">* For clk_peri = 50 MHz, select divider value 4 and get clk_scb = (50 MHz / 4) = 12.5 MHz.</span></div><div class="line"><span class="comment">* This clock frequency meets requirements above.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gac67931844e6ec06b5ff88f4f3119e127">Cy_SysClk_PeriphSetDivider</a>   (I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER, 3u);</div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga8c626f11b583d8296516bbcf4a22f98e">Cy_SysClk_PeriphEnableDivider</a>(I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER);</div></div><!-- fragment --><p> To get I2C master operation with the desired data rate, the source clock frequency and SCL low and high phase duration must be configured. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to configure source clock frequency. Then call <a class="el" href="group__group__scb__i2c__general__functions.html#gae9d71372b84c9c799b55283fc475f223">Cy_SCB_I2C_SetDataRate</a> to set the SCL low, high phase duration and digital filter. This function sets SCL low and high phase settings based on source clock frequency.</p>
<div class="fragment"><div class="line">uint32_t dataRate;</div><div class="line"></div><div class="line"><span class="comment">/* I2C master desired data rate in Hz */</span></div><div class="line"><span class="preprocessor">#define I2C_DESIRED_DATA_RATE_HZ    (100000U)</span></div><div class="line"></div><div class="line"><span class="comment">/* I2C master desired data rate is 100 kbps.</span></div><div class="line"><span class="comment">* To support this data rate the clk_scb frequency must be in range 1.55 – 3.2 MHz.</span></div><div class="line"><span class="comment">* Find clk_scb valid ranges in TRM section I2C sub-section Oversampling and Bit Rate.</span></div><div class="line"><span class="comment">* For clk_peri = 50 MHz, select divider value 32 and get clk_scb = (50 MHz / 32) = 1.563 MHz.</span></div><div class="line"><span class="comment">* This clock frequency meets requirements above.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gac67931844e6ec06b5ff88f4f3119e127">Cy_SysClk_PeriphSetDivider</a>   (I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER, 31u);</div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga8c626f11b583d8296516bbcf4a22f98e">Cy_SysClk_PeriphEnableDivider</a>(I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER);</div><div class="line"></div><div class="line"><span class="comment">/* Configure master to operate with desired data rate */</span></div><div class="line">dataRate = <a class="code" href="group__group__scb__i2c__general__functions.html#gae9d71372b84c9c799b55283fc475f223">Cy_SCB_I2C_SetDataRate</a>(SCB3, I2C_DESIRED_DATA_RATE_HZ, <a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga366428a7c17da00f7a7ae025aeda2e23">Cy_SysClk_PeriphGetFrequency</a>(I2C_CLK_DIV_TYPE, I2C_CLK_DIV_NUMBER));</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> ((dataRate &gt; I2C_DESIRED_DATA_RATE_HZ) || (dataRate == 0U))</div><div class="line">{</div><div class="line">    <span class="comment">/* Can not reach desired data rate */</span></div><div class="line">    CY_ASSERT(0U);</div><div class="line">}</div></div><!-- fragment --><p> Alternatively, the low, high phase and digital filter can be set directly using configuration structure <a class="el" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> fields lowPhaseDutyCycle, highPhaseDutyCycle and enableDigitalFilter appropriately.<br />
<b>Refer to the technical reference manual (TRM) section I2C sub-section Oversampling and Bit Rate to get information how to configure I2C to run with the desired data rate.</b></p>
<dl class="section note"><dt>Note</dt><dd>For I2C slave, the analog filter is used for all supported data rates. <br />
For I2C master, the analog filter is used for Standard and Fast modes and the digital filter for Fast Plus mode.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_intr"></a>
Configure Interrupt</h2>
<p>The interrupt is mandatory for I2C operation. The exception is the when only the <a class="el" href="group__group__scb__i2c__master__low__level__functions.html">Master Low-Level</a> functions are used. The driver provides three interrupt functions: <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a>, <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga87512a96b0ae32bb624a5a960d64d23f">Cy_SCB_I2C_SlaveInterrupt</a>, and <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga3133d46624010df1c57a0800797aab01">Cy_SCB_I2C_MasterInterrupt</a>. One of these functions must be called in the interrupt handler for the selected SCB instance. Call <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga87512a96b0ae32bb624a5a960d64d23f">Cy_SCB_I2C_SlaveInterrupt</a> when I2C is configured to operate as a slave, <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga3133d46624010df1c57a0800797aab01">Cy_SCB_I2C_MasterInterrupt</a> when I2C is configured to operate as a master and <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> when I2C is configured to operate as master and slave. Using the slave- or master-specific interrupt function allows reducing the flash consumed by the I2C driver. Also this interrupt must be enabled in the NVIC otherwise it will not work. </p><dl class="section note"><dt>Note</dt><dd>The I2C driver documentation refers to the <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> function when interrupt processing is mandatory for the operation. This is done to simplify the readability of the driver's documentation. The application should call the slave- or master-specific interrupt functions <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga87512a96b0ae32bb624a5a960d64d23f">Cy_SCB_I2C_SlaveInterrupt</a> or <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga3133d46624010df1c57a0800797aab01">Cy_SCB_I2C_MasterInterrupt</a>, when appropriate.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> I2C_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a>(SCB3, &amp;i2cContext);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Assign I2C interrupt number and priority */</span></div><div class="line"><span class="preprocessor">#define I2C_INTR_NUM        scb_3_interrupt_IRQn</span></div><div class="line"><span class="preprocessor">#define I2C_INTR_PRIORITY   (7UL)</span></div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure (code specific for CM4) */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> i2cIntrConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = I2C_INTR_NUM,</div><div class="line">    .intrPriority = I2C_INTR_PRIORITY,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div><div class="line">(void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;i2cIntrConfig, &amp;I2C_Isr);</div><div class="line">NVIC_EnableIRQ(I2C_INTR_NUM);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_enable"></a>
Enable I2C</h2>
<p>Finally, enable the I2C operation by calling <a class="el" href="group__group__scb__i2c__general__functions.html#gad14d83faab69d2ac96feede664df3687">Cy_SCB_I2C_Enable</a>. Then I2C slave starts respond to the assigned address and I2C master ready to execute transfers.</p>
<div class="fragment"><div class="line"><span class="comment">/* Enable I2C to operate */</span></div><div class="line"><a class="code" href="group__group__scb__i2c__general__functions.html#gad14d83faab69d2ac96feede664df3687">Cy_SCB_I2C_Enable</a>(SCB3);</div><div class="line"></div><div class="line"><span class="comment">/* Enable global interrupts */</span></div><div class="line">__enable_irq();</div></div><!-- fragment --> <h1><a class="anchor" id="group_scb_i2c_use_cases"></a>
Common Use Cases</h1>
<h2><a class="anchor" id="group_scb_i2c_master_mode"></a>
Master Operation</h2>
<p>The master API is divided into two categories: <a class="el" href="group__group__scb__i2c__master__high__level__functions.html">Master High-Level</a> and <a class="el" href="group__group__scb__i2c__master__low__level__functions.html">Master Low-Level</a>. Therefore, there are two methods for initiating I2C master transactions using either <b>Low-Level or High-Level</b> API. These two methods are described below. Only one method should be used at a time. <b>They should not be mixed.</b></p>
<h3><a class="anchor" id="group_scb_i2c_master_hl"></a>
Use High-Level Functions</h3>
<p>Call <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a> or <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a> to communicate with the slave. These functions do not block and only start a transaction. After a transaction starts, the <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> handles further data transaction until its completion (successfully or with error occurring). To monitor the transaction, use <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a> or register callback function using <a class="el" href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a> to be notified about <a class="el" href="group__group__scb__i2c__macros__callback__events.html">I2C Callback Events</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="structcy__stc__scb__i2c__master__xfer__config__t.html">cy_stc_scb_i2c_master_xfer_config_t</a> transfer;</div><div class="line"></div><div class="line">uint8_t readBuffer [5UL];</div><div class="line">uint8_t writeBuffer[2UL] = {0U, 5U};</div><div class="line"></div><div class="line"><span class="comment">/* Configure write transaction */</span></div><div class="line">transfer.<a class="code" href="structcy__stc__scb__i2c__master__xfer__config__t.html#ad593c8662c67ee3d7b766d1bfac64639">slaveAddress</a> = 0x08U;</div><div class="line">transfer.<a class="code" href="structcy__stc__scb__i2c__master__xfer__config__t.html#a17fa9b9a817e002381f07c4982abaffa">buffer</a>       = writeBuffer;</div><div class="line">transfer.<a class="code" href="structcy__stc__scb__i2c__master__xfer__config__t.html#a4afeea04f622380e0c1113cc4bfbdea6">bufferSize</a>   = <span class="keyword">sizeof</span>(writeBuffer);</div><div class="line">transfer.<a class="code" href="structcy__stc__scb__i2c__master__xfer__config__t.html#a2e158df2a2854d193d589021c2128aa4">xferPending</a>  = <span class="keyword">true</span>; <span class="comment">/* Do not generate Stop condition at the end of transaction */</span></div><div class="line"></div><div class="line"><span class="comment">/* Initiate write transaction.</span></div><div class="line"><span class="comment">* The Start condition is generated to begin this transaction.</span></div><div class="line"><span class="comment">*/</span></div><div class="line">(void) <a class="code" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a>(SCB3, &amp;transfer, &amp;i2cContext);</div><div class="line"></div><div class="line"><span class="comment">/* Wait for transaction completion */</span></div><div class="line"><span class="keywordflow">while</span> (0UL != (<a class="code" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> &amp; <a class="code" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a>(SCB3, &amp;i2cContext)))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Configure read transaction */</span></div><div class="line">transfer.<a class="code" href="structcy__stc__scb__i2c__master__xfer__config__t.html#a17fa9b9a817e002381f07c4982abaffa">buffer</a>       = readBuffer;</div><div class="line">transfer.<a class="code" href="structcy__stc__scb__i2c__master__xfer__config__t.html#a4afeea04f622380e0c1113cc4bfbdea6">bufferSize</a>   = <span class="keyword">sizeof</span>(readBuffer);</div><div class="line">transfer.<a class="code" href="structcy__stc__scb__i2c__master__xfer__config__t.html#a2e158df2a2854d193d589021c2128aa4">xferPending</a>  = <span class="keyword">false</span>; <span class="comment">/* Generate Stop condition the end of transaction */</span></div><div class="line"></div><div class="line"><span class="comment">/* Initiate read transaction.</span></div><div class="line"><span class="comment">* The ReStart condition is generated to begin this transaction because</span></div><div class="line"><span class="comment">* previous transaction was completed without Stop.</span></div><div class="line"><span class="comment">*/</span></div><div class="line">(void) <a class="code" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a>(SCB3, &amp;transfer, &amp;i2cContext);</div><div class="line"></div><div class="line"><span class="comment">/* Wait for transaction completion */</span></div><div class="line"><span class="keywordflow">while</span> (0UL != (<a class="code" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> &amp; <a class="code" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a>(SCB3, &amp;i2cContext)))</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Process received data */</span></div><div class="line"></div></div><!-- fragment --><h3><a class="anchor" id="group_scb_i2c_master_ll"></a>
Use Low-Level Functions</h3>
<p>Call <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga15fa1a79148b846fd348ce39094876f0">Cy_SCB_I2C_MasterSendStart</a> to generate a start, send an address with the Read/Write direction bit, and receive acknowledgment. After the address is ACKed by the slave, the transaction can be continued by calling <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga0679a2b27cf3be4d1a6cd20246688fef">Cy_SCB_I2C_MasterReadByte</a> or <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga7eb0684e4d362668f0637d1e82405551">Cy_SCB_I2C_MasterWriteByte</a> depending on its direction. These functions handle one byte per call. Therefore, they should be called for each byte in the transaction. Note that for the Read transaction, the last byte must be NAKed. To complete the current transaction, call <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga4b098cd781eaa5cd287ae33e05c86a0d">Cy_SCB_I2C_MasterSendStop</a> or call <a class="el" href="group__group__scb__i2c__master__low__level__functions.html#ga2177b4fb74cf33e57e6fa59d04bdfa7a">Cy_SCB_I2C_MasterSendReStart</a> to complete the current transaction and start a new one. Typically, do a restart to change the transaction direction without releasing the bus from the master control. The Low-Level functions are blocking and do not require calling <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> inside the interrupt handler. Using these functions requires extensive knowledge of the I2C protocol to execute transactions correctly.</p>
<p><b>Master Write Operation</b> </p><div class="fragment"><div class="line"><a class="code" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a> status;</div><div class="line"></div><div class="line"><span class="comment">/* Buffer to write to the slave */</span></div><div class="line">uint8_t buffer[] = {0x55, 0x44, 0x33};</div><div class="line"></div><div class="line"><span class="comment">/* Wait 100 ms until operation completion */</span></div><div class="line">uint32_t timeout = 100UL;</div><div class="line"></div><div class="line"><span class="comment">/* Send Start condition, address and receive ACK/NACK response from slave */</span></div><div class="line">status = <a class="code" href="group__group__scb__i2c__master__low__level__functions.html#ga15fa1a79148b846fd348ce39094876f0">Cy_SCB_I2C_MasterSendStart</a>(SCB3, 0x08U, <a class="code" href="group__group__scb__i2c__enums.html#gga6a168a5e662ce781920027bebbab5d8da62791e1d00155a9693ceb8310aff2fee">CY_SCB_I2C_WRITE_XFER</a>, timeout, &amp;i2cContext);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a> == status)</div><div class="line">{</div><div class="line">    uint32_t cnt = 0UL;</div><div class="line"></div><div class="line">    <span class="comment">/* Write data into the slave from the buffer */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Write byte and receive ACK/NACK response */</span></div><div class="line">        status = <a class="code" href="group__group__scb__i2c__master__low__level__functions.html#ga7eb0684e4d362668f0637d1e82405551">Cy_SCB_I2C_MasterWriteByte</a>(SCB3, buffer[cnt], timeout, &amp;i2cContext);</div><div class="line">        ++cnt;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span>((status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>) &amp;&amp; (cnt &lt; <span class="keyword">sizeof</span>(buffer)));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Check status of transaction */</span></div><div class="line"><span class="keywordflow">if</span> ((status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>)           ||</div><div class="line">    (status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247ada7da6531ad390819f7fa40f41c8c8e2">CY_SCB_I2C_MASTER_MANUAL_NAK</a>) ||</div><div class="line">    (status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a779a11182cb3545ae0a7a615e5f322cb">CY_SCB_I2C_MASTER_MANUAL_ADDR_NAK</a>))</div><div class="line">{</div><div class="line">    <span class="comment">/* Send Stop condition on the bus */</span></div><div class="line">    status = <a class="code" href="group__group__scb__i2c__master__low__level__functions.html#ga4b098cd781eaa5cd287ae33e05c86a0d">Cy_SCB_I2C_MasterSendStop</a>(SCB3, timeout, &amp;i2cContext);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Data has been written into the slave */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="comment">/* Other statuses do not require any actions */</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> <b>Master Read Operation</b> </p><div class="fragment"><div class="line"><a class="code" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a> status;</div><div class="line"></div><div class="line"><span class="comment">/* Buffer to write to the slave */</span></div><div class="line">uint8_t buffer[5U];</div><div class="line"></div><div class="line"><span class="comment">/* Wait 100 ms until operation completion */</span></div><div class="line">uint32_t timeout = 100UL;</div><div class="line"></div><div class="line"><span class="comment">/* Send Start condition, address and receive ACK/NACK response from slave */</span></div><div class="line">status = <a class="code" href="group__group__scb__i2c__master__low__level__functions.html#ga15fa1a79148b846fd348ce39094876f0">Cy_SCB_I2C_MasterSendStart</a>(SCB3, 0x08U, <a class="code" href="group__group__scb__i2c__enums.html#gga6a168a5e662ce781920027bebbab5d8da62791e1d00155a9693ceb8310aff2fee">CY_SCB_I2C_WRITE_XFER</a>, timeout, &amp;i2cContext);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a> == status)</div><div class="line">{</div><div class="line">    uint32_t cnt = 0UL;</div><div class="line">    <a class="code" href="group__group__scb__i2c__enums.html#ga4600410051f7febf79d167ffbf85d7ef">cy_en_scb_i2c_command_t</a> cmd = <a class="code" href="group__group__scb__i2c__enums.html#gga4600410051f7febf79d167ffbf85d7efadd6046656aba93adef7c4823a25081fd">CY_SCB_I2C_ACK</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Read data from the slave into the buffer */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (cnt == (<span class="keyword">sizeof</span>(buffer) - 1UL))</div><div class="line">        {</div><div class="line">            <span class="comment">/* The last byte must be NACKed */</span></div><div class="line">            cmd = <a class="code" href="group__group__scb__i2c__enums.html#gga4600410051f7febf79d167ffbf85d7efa46363791a98697b7b015b3b64441bfc6">CY_SCB_I2C_NAK</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Read byte and generate ACK / or prepare for NACK */</span></div><div class="line">        status = <a class="code" href="group__group__scb__i2c__master__low__level__functions.html#ga0679a2b27cf3be4d1a6cd20246688fef">Cy_SCB_I2C_MasterReadByte</a>(SCB3, cmd, &amp;buffer[cnt], timeout, &amp;i2cContext);</div><div class="line">        ++cnt;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span>((status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>) &amp;&amp; (cnt &lt; <span class="keyword">sizeof</span>(buffer)));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Check status of transaction */</span></div><div class="line"><span class="keywordflow">if</span> ((status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>)           ||</div><div class="line">    (status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247ada7da6531ad390819f7fa40f41c8c8e2">CY_SCB_I2C_MASTER_MANUAL_NAK</a>) ||</div><div class="line">    (status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a779a11182cb3545ae0a7a615e5f322cb">CY_SCB_I2C_MASTER_MANUAL_ADDR_NAK</a>))</div><div class="line">{</div><div class="line">    <span class="comment">/* Send Stop condition on the bus */</span></div><div class="line">    status = <a class="code" href="group__group__scb__i2c__master__low__level__functions.html#ga4b098cd781eaa5cd287ae33e05c86a0d">Cy_SCB_I2C_MasterSendStop</a>(SCB3, timeout, &amp;i2cContext);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (status == <a class="code" href="group__group__scb__i2c__enums.html#ggaf621eb0719ad9ad7178d02268575b247a80d0133e4536adccb11defa72a9aa9b0">CY_SCB_I2C_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process received data */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">    <span class="comment">/* Other statuses do not require any actions.</span></div><div class="line"><span class="comment">    * The received data should dropped.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_slave"></a>
Slave Operation</h2>
<p>Slave operation requires the <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> be called inside the interrupt handler. The read and write buffers must be provided for the slave to enable communication with the master. Use <a class="el" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a> and <a class="el" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a> for this purpose. Note that after transaction completion the buffer must be configured again. Otherwise, the same buffer is used starting from the point where the master stopped a previous transaction. For example: The read buffer is configured to be 10 bytes and the master reads 8 bytes. If the read buffer is not configured again, the next master read will start from the 9th byte. To monitor the transaction status, use <a class="el" href="group__group__scb__i2c__slave__functions.html#gab3e1c474d6a5c7c5547ea08aa5d59e22">Cy_SCB_I2C_SlaveGetStatus</a> or use <a class="el" href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a> to register a callback function to be notified about <a class="el" href="group__group__scb__i2c__macros__callback__events.html">I2C Callback Events</a>.</p>
<p><b>Get Slave Events Notification</b> </p><div class="fragment"><div class="line"><span class="comment">/* Register callback for event notification.</span></div><div class="line"><span class="comment">* It is better to do this during initialization before I2C is enabled.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a>(SCB3, I2C_SlaveEventHandler, &amp;i2cContext);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Callback implementation */</span></div><div class="line"><span class="keywordtype">void</span> I2C_SlaveEventHandler(uint32_t events)</div><div class="line">{</div><div class="line">    <span class="comment">/* Slave sent data to master */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (events &amp; <a class="code" href="group__group__scb__i2c__macros__callback__events.html#gae44345d38014821cc5d5c918dd074324">CY_SCB_I2C_SLAVE_RD_CMPLT_EVENT</a>))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (0UL == (events &amp; <a class="code" href="group__group__scb__i2c__macros__callback__events.html#ga88e999437b51f24bdaf50c6dac83d81c">CY_SCB_I2C_SLAVE_ERR_EVENT</a>))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Read complete without errors: update buffer content */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Setup read buffer for the next read transaction */</span></div><div class="line">        <a class="code" href="group__group__scb__i2c__slave__functions.html#ga179b4495d7255567bb8b166e16e5a073">Cy_SCB_I2C_SlaveConfigReadBuf</a>(SCB3, i2cReadBuffer,  BUFFER_SIZE, &amp;i2cContext);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Slave received data from master */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (events &amp; <a class="code" href="group__group__scb__i2c__macros__callback__events.html#gaa509ff3cd20d1b1d31e3c22e7c28871f">CY_SCB_I2C_SLAVE_WR_CMPLT_EVENT</a>))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (0UL == (events &amp; <a class="code" href="group__group__scb__i2c__macros__callback__events.html#ga88e999437b51f24bdaf50c6dac83d81c">CY_SCB_I2C_SLAVE_ERR_EVENT</a>))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Write complete without errors: process received data */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Setup buffer for the next write transaction */</span></div><div class="line">        <a class="code" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a>(SCB3, i2cWriteBuffer, BUFFER_SIZE, &amp;i2cContext);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Ignore all other events */</span></div><div class="line">}</div></div><!-- fragment --><p> <b>Polling Slave Completion Events</b> </p><div class="fragment"><div class="line"><span class="comment">/* Disable I2C Interrupt: protect code from interruption */</span></div><div class="line">NVIC_DisableIRQ(I2C_INTR_NUM);</div><div class="line"></div><div class="line"><span class="comment">/* Check if write transaction completed */</span></div><div class="line"><span class="keywordflow">if</span> (0UL != (<a class="code" href="group__group__scb__i2c__macros__slave__status.html#ga0e917e7b1f8b297bb97716a0a742a14a">CY_SCB_I2C_SLAVE_WR_CMPLT</a> &amp; <a class="code" href="group__group__scb__i2c__slave__functions.html#gab3e1c474d6a5c7c5547ea08aa5d59e22">Cy_SCB_I2C_SlaveGetStatus</a>(SCB3, &amp;i2cContext)))</div><div class="line">{</div><div class="line">    <span class="comment">/* Process received data */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Configure buffer for the next write */</span></div><div class="line">    <a class="code" href="group__group__scb__i2c__slave__functions.html#gaaf2d216e9cb246dd2256521cb7f50170">Cy_SCB_I2C_SlaveConfigWriteBuf</a>(SCB3, i2cWriteBuffer, BUFFER_SIZE, &amp;i2cContext);</div><div class="line"></div><div class="line">    <span class="comment">/* Clear slave write status to capture following updates */</span></div><div class="line">    <a class="code" href="group__group__scb__i2c__slave__functions.html#ga73636c22f0db8c09d790f387aa35e6be">Cy_SCB_I2C_SlaveClearWriteStatus</a>(SCB3, &amp;i2cContext);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Enable I2C interrupt */</span></div><div class="line">NVIC_EnableIRQ(I2C_INTR_NUM);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>All slave API (except <a class="el" href="group__group__scb__i2c__slave__functions.html#ga1c9f6c807f4758016bf90cc8f69f96b3">Cy_SCB_I2C_SlaveAbortRead</a> and <a class="el" href="group__group__scb__i2c__slave__functions.html#ga50157a71ba992433bd4fde948d25d44e">Cy_SCB_I2C_SlaveAbortWrite</a>) <b>are not interrupt-protected</b> and to prevent a race condition, they should be protected from the I2C interruption in the place where they are called. The code snippet Polling Slave Completion Events above shows how to prevent a race condition when detect transfer completion and update I2C slave write buffer. The simple example of race condition is: application updates slave read buffer the I2C master starts read transfer. The I2C interrupts read buffer update and I2C interrupt loads current read buffer content in the TX FIFO . After I2C interrupt returns the application updates remaining part of the read buffer. As a result the mater read partly updated buffer.</dd></dl>
<h1><a class="anchor" id="group_scb_i2c_lp"></a>
Low Power Support</h1>
<p>The I2C driver provides callback functions to handle power mode transition. The callback <a class="el" href="group__group__scb__i2c__low__power__functions.html#gaf2044790a92ba63cb11616f2e80d3d1f">Cy_SCB_I2C_DeepSleepCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca">Cy_SysPm_CpuEnterDeepSleep</a> <a class="el" href="group__group__scb__i2c__low__power__functions.html#gaf480cdce47050c37a3558285d6a1c2a7">Cy_SCB_I2C_HibernateCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#gae97647a28c370674ba57d451d21d1c51">Cy_SysPm_SystemEnterHibernate</a>. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration.</p>
<dl class="section note"><dt>Note</dt><dd>Only applicable for <b>rev-08 of the CY8CKIT-062-BLE</b>. For proper operation, when the I2C slave is configured to be a wakeup source from Deep Sleep mode, the <a class="el" href="group__group__scb__i2c__low__power__functions.html#gaf2044790a92ba63cb11616f2e80d3d1f">Cy_SCB_I2C_DeepSleepCallback</a> must be copied and modified. Refer to the function description to get the details. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__i2c__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
