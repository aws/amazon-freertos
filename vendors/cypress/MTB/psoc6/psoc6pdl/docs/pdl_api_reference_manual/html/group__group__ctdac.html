<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: CTDAC        (Continuous Time Digital to Analog Converter)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__ctdac.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">CTDAC (Continuous Time Digital to Analog Converter)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The CTDAC driver provides APIs to configure the 12-bit Continuous-Time DAC. </p>
<p>The functions and other declarations used in this driver are in cy_ctdac.h. You can include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<ul>
<li>12-bit continuous time output</li>
<li>2 us settling time for a 25 pF load when output buffered through Opamp0 of <a class="el" href="group__group__ctb.html">CTB</a></li>
<li>Can be enabled in Deep Sleep power mode</li>
<li>Selectable voltage reference:<ul>
<li>VDDA</li>
<li>Internal analog reference buffered through Opamp1 of <a class="el" href="group__group__ctb.html">CTB</a></li>
<li>External reference buffered through Opamp1 of <a class="el" href="group__group__ctb.html">CTB</a></li>
</ul>
</li>
<li>Selectable output paths:<ul>
<li>Direct DAC output to a pin</li>
<li>Buffered DAC output through Opamp0 of <a class="el" href="group__group__ctb.html">CTB</a></li>
<li>Sample and hold output path through Opamp0 of <a class="el" href="group__group__ctb.html">CTB</a></li>
</ul>
</li>
<li>Selectable input modes:<ul>
<li>Unsigned 12-bit mode</li>
<li>Virtual signed 12-bit mode</li>
</ul>
</li>
<li>Configurable update rate using clock or strobe signal</li>
<li>Double buffered DAC voltage control register</li>
<li>Interrupt and DMA trigger on DAC buffer empty</li>
<li>Configurable as PGA along with Opamp1 of the <a class="el" href="group__group__ctb.html">CTB</a></li>
</ul>
<p>The CTDAC generates a 12-bit DAC output voltage from the reference. The DAC reference can come from VDDA or from any signal buffered through Opamp0 of the CTB. This can be an external signal through a GPIO or from the internal AREF. The CTDAC is closely integrated with the CTB block, which provides easy buffering of the DAC output voltage, buffered input reference voltage, and sample and hold for the DAC output. The CTDAC control interface provides control of the DAC output through CPU or DMA. This includes a double-buffered DAC voltage control register, clock input for programmable update rate, interrupt on DAC buffer empty, and trigger to DMA.</p>
<div class="image">
<img src="ctdac_block_diagram.png" alt="ctdac_block_diagram.png"/>
</div>
 <p>The CTDAC has two switches, CO6 for configuring the output path and CVD for the reference source.</p>
<div class="image">
<img src="ctdac_switches.png" alt="ctdac_switches.png"/>
</div>
 <h1><a class="anchor" id="group_ctdac_init"></a>
Initialization</h1>
<p>Configure the CTDAC hardware block by calling <a class="el" href="group__group__ctdac__functions__init.html#ga09e11de95212716c56148f93ba65df41">Cy_CTDAC_Init</a>. The base address of the CTDAC hardware can be found in the device-specific header file. If the buffers in the CTB are used for the reference source or the output, initialize the CTB hardware block. After both blocks are initialized, enable the CTB block before enabling the CTDAC block.</p>
<p>The driver also provides a <a class="el" href="group__group__ctdac__functions__init.html#ga66f44760b2a923f78135b20060c5700d">Cy_CTDAC_FastInit</a> function for fast and easy initialization of the CTDAC. The driver has pre-defined configuration structures for the four combinations of the reference and output buffers.</p>
<ul>
<li><a class="el" href="group__group__ctdac__globals.html#ga049a58c183e635b93a450976bf49660a">Cy_CTDAC_Fast_VddaRef_UnbufferedOut</a></li>
<li><a class="el" href="group__group__ctdac__globals.html#gaaac60a859d3b9f0235dbdbfe4346ef22">Cy_CTDAC_Fast_VddaRef_BufferedOut</a></li>
<li><a class="el" href="group__group__ctdac__globals.html#ga27c002738be38f380472ea16d1155051">Cy_CTDAC_Fast_OA1Ref_UnbufferedOut</a></li>
<li><a class="el" href="group__group__ctdac__globals.html#ga28e709a157ae32116c0eca332ef6fc65">Cy_CTDAC_Fast_OA1Ref_BufferedOut</a></li>
</ul>
<p>After initialization, call <a class="el" href="group__group__ctdac__functions__init.html#gaf11183d5debb690a8240f2ee4d304d44">Cy_CTDAC_Enable</a> to enable the hardware.</p>
<h1><a class="anchor" id="group_ctdac_updatemode"></a>
Update Modes</h1>
<p>The CTDAC contains two registers:</p><ol type="1">
<li><p class="startli">CTDAC_VAL</p>
<p class="startli">For direct firmware writes to update the current DAC value immediately. This register is written with <a class="el" href="group__group__ctdac__functions__basic.html#gad200575b1f2978c71744791e4a731d9b">Cy_CTDAC_SetValue</a>.</p>
</li>
<li><p class="startli">CTDAC_VAL_NXT</p>
<p class="startli">For buffered writes to update the DAC value at a periodic rate or with a strobe trigger input. This register is written with <a class="el" href="group__group__ctdac__functions__basic.html#ga1524565433728ffa19f773354b88f036">Cy_CTDAC_SetValueBuffered</a>.</p>
</li>
</ol>
<p>The update mode is selected during initialization with the <a class="el" href="structcy__stc__ctdac__config__t.html#a69522cfeec61c2287cd1a830d45c5d15">cy_stc_ctdac_config_t::updateMode</a>. Four of these modes require a dedicated clock resource and the driver can configure the clock during initialization (see <a class="el" href="structcy__stc__ctdac__config__t.html">cy_stc_ctdac_config_t</a>).</p>
<p>Three of these modes use a strobe signal through the digital signal interface (DSI). This allows control of the buffered update timing from an external source, for example, by another chip peripheral or from an off-chip source.</p>
<h2><a class="anchor" id="group_ctdac_updatemode_direct_write"></a>
Direct write</h2>
<p>In this mode, the user writes directly into the CTDAC_VAL register using <a class="el" href="group__group__ctdac__functions__basic.html#gad200575b1f2978c71744791e4a731d9b">Cy_CTDAC_SetValue</a>. The action of writing to this register will update the DAC output. This mode does not generate an interrupt or trigger signal. In this mode, a clock must not be configured. Additionally, calling <a class="el" href="group__group__ctdac__functions__basic.html#ga1524565433728ffa19f773354b88f036">Cy_CTDAC_SetValueBuffered</a> does not update the DAC output.</p>
<div class="image">
<img src="ctdac_update_mode_direct_write.png" alt="ctdac_update_mode_direct_write.png"/>
</div>
 <h2><a class="anchor" id="group_ctdac_updatemode_buffered_write"></a>
Buffered write</h2>
<p>In this mode, the user writes to the CTDAC_VAL_NXT register using <a class="el" href="group__group__ctdac__functions__basic.html#ga1524565433728ffa19f773354b88f036">Cy_CTDAC_SetValueBuffered</a>. The rising edge of the clock will update the DAC output and generate the interrupt and trigger signals.</p>
<p>Whenever data is transferred from the CTDAC_VAL_NXT register, an interrupt is asserted the same time as the trigger. But while the trigger is automatically cleared after two PeriClk cycles, the user must clear the interrupt with <a class="el" href="group__group__ctdac__functions__interrupts.html#ga751d89f67434f47770b39b211ac488be">Cy_CTDAC_ClearInterrupt</a>.</p>
<div class="image">
<img src="ctdac_update_mode_buffered_write.png" alt="ctdac_update_mode_buffered_write.png"/>
</div>
 <h2><a class="anchor" id="group_ctdac_updatemode_strobe_edge_sync"></a>
Strobe edge sync</h2>
<p>In this mode, the user writes to the CTDAC_VAL_NXT register using <a class="el" href="group__group__ctdac__functions__basic.html#ga1524565433728ffa19f773354b88f036">Cy_CTDAC_SetValueBuffered</a>. Each rising edge of the DSI strobe input enables one subsequent update from the next rising edge of the clock. The DSI input must remain high for two PeriClk cycles and go low for another two PeriClk cycles to allow for the next update. This restricts the DSI strobe input frequency to the PeriClk frequency divided by four.</p>
<div class="image">
<img src="ctdac_update_mode_strobe_edge_sync.png" alt="ctdac_update_mode_strobe_edge_sync.png"/>
</div>
 <h2><a class="anchor" id="group_ctdac_updatemode_strobe_edge_immediate"></a>
Strobe edge immediate</h2>
<p>In this mode, the user writes to the CTDAC_VAL_NXT register using <a class="el" href="group__group__ctdac__functions__basic.html#ga1524565433728ffa19f773354b88f036">Cy_CTDAC_SetValueBuffered</a>. The clock resource is used but set to a logic high. Therefore, each rising edge of the DSI strobe input immediately updates the DAC output.</p>
<div class="image">
<img src="ctdac_update_mode_strobe_edge_immediate.png" alt="ctdac_update_mode_strobe_edge_immediate.png"/>
</div>
 <h2><a class="anchor" id="group_ctdac_updatemode_strobe_level"></a>
Strobe level</h2>
<p>In this mode, the user writes to the CTDAC_VAL_NXT register using <a class="el" href="group__group__ctdac__functions__basic.html#ga1524565433728ffa19f773354b88f036">Cy_CTDAC_SetValueBuffered</a>. The DSI strobe input acts as a hardware enable signal. While the DSI strobe input is high, the mode behaves like the Buffered write mode. When the DSI strobe input is low, updates are disabled.</p>
<div class="image">
<img src="ctdac_update_mode_strobe_level.png" alt="ctdac_update_mode_strobe_level.png"/>
</div>
 <h1><a class="anchor" id="group_ctdac_dacmode"></a>
DAC Modes</h1>
<p>The format of code stored in the CTDAC_VAL register can either be unsigned or signed two's complemented. Only the first 12 bits of the register are used by the DAC so there is no need for sign extension. With the signed format, the DAC decodes the code in the register by adding 0x800. The DAC can output the register value or the register value plus 1 (see <a class="el" href="group__group__ctdac__functions__basic.html#gaf11a41cf842064d44f9f8cdaeea0a31e">Cy_CTDAC_SetOutputMode</a>).</p>
<table class="doxtable">
<tr>
<th>12-bit unsigned code </th><th>12-bit two's complement signed code </th><th>Vout (for <a class="el" href="group__group__ctdac__enums.html#gga151d4aa27fabb95182a2494782994ccbaa0eedb42bfda13365d835dcc21ef33e6">CY_CTDAC_OUTPUT_VALUE</a> ) </th><th>Vout (for <a class="el" href="group__group__ctdac__enums.html#gga151d4aa27fabb95182a2494782994ccba9d9e4e7c8dfcab9f6ef32358937709c8">CY_CTDAC_OUTPUT_VALUE_PLUS1</a> )  </th></tr>
<tr>
<td>0x000 </td><td>0x800 </td><td>0 </td><td>Vref/4096  </td></tr>
<tr>
<td>0x800 </td><td>0x000 </td><td>0.5 * Vref </td><td>Vref * 2049 / 4096  </td></tr>
<tr>
<td>0xFFF </td><td>0x7FF </td><td>Vref * 4095 / 4096 </td><td>Vref  </td></tr>
</table>
<p>The expressions in the above table are based on an unbuffered DAC output. When the output is buffered, the input and output range of the buffer will affect the output voltage. See <a class="el" href="group__group__ctb.html#group_ctb_opamp_range">Opamp Input and Output Range</a> in the CTB driver for more information.</p>
<h1><a class="anchor" id="group_ctdac_trigger"></a>
Interrupts and Trigger</h1>
<p>When data from the CTDAC_VAL_NXT is transferred to the CTDAC_VAL register, an interrupt and trigger output are generated. The trigger output can be used with a DMA block to update the CTDAC value register at high speeds without any CPU intervention. Alternatively, the interrupt output can be used when DMA is not available to update the CTDAC value register, but at a slower speed.</p>
<p>Recall with the <a class="el" href="group__group__ctdac.html#group_ctdac_updatemode">Update Modes</a>, the interrupt and trigger output are available in all modes except <a class="el" href="group__group__ctdac.html#group_ctdac_updatemode_direct_write">Direct write</a>.</p>
<h2><a class="anchor" id="group_ctdac_dma_trigger"></a>
DMA Trigger</h2>
<p>The CTDAC trigger output signal can be routed to a DMA block using the <a class="el" href="group__group__trigmux.html">TrigMux (Trigger Multiplexer)</a> to trigger an update to the CTDAC_VAL_NXT register. When making the required <a class="el" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a> calls, use the pre-defined enums, TRIG14_IN_PASS_TR_CTDAC_EMPTY and TRIGGER_TYPE_PASS_TR_CTDAC_EMPTY.</p>
<h2><a class="anchor" id="group_ctdac_handling_interrupts"></a>
Handling Interrupts</h2>
<p>The following code snippet demonstrates how to implement a routine to handle the interrupt. The routine gets called when any CTDAC on the device generates an interrupt.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* Scenario: An interrupt occurs when data is transferred from the CTDAC_VAL_NXT</span></div><div class="line"><span class="comment"> * register to the CTDAC_VAL register signaling that the CTDAC can accept a new value.</span></div><div class="line"><span class="comment"> * The ISR function should be used to update the CTDAC value. */</span></div><div class="line"></div><div class="line"><span class="comment">/* ISR function to handle the global CTDAC interrupt. */</span></div><div class="line"><span class="keywordtype">void</span> CTDAC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Clear the interrupt so that subsequent interrupts can be handled. */</span></div><div class="line">    <a class="code" href="group__group__ctdac__functions__interrupts.html#ga751d89f67434f47770b39b211ac488be">Cy_CTDAC_ClearInterrupt</a>(CTDAC0);</div><div class="line">    </div><div class="line">    uint8_t intrStatus;</div><div class="line">    </div><div class="line">    <span class="comment">/* Get the interrupt status for a specific CTDAC instance on the device. */</span></div><div class="line">    intrStatus = <a class="code" href="group__group__ctdac__functions__interrupts.html#ga5d848e8b2f4ebc0fa8112954ed57c7b5">Cy_CTDAC_GetInterruptStatus</a>(CTDAC0);</div><div class="line"></div><div class="line">    <span class="comment">/* If the interrupt status is 1, the CTDAC is ready to accept a new value. */</span></div><div class="line">    <span class="keywordflow">if</span> (1UL == intrStatus)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set the next value to output. */</span></div><div class="line">        <a class="code" href="group__group__ctdac__functions__basic.html#ga1524565433728ffa19f773354b88f036">Cy_CTDAC_SetValueBuffered</a>(CTDAC0, nextValue);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> The following code snippet demonstrates how to configure and enable the interrupt.</p>
<div class="fragment"><div class="line">    </div><div class="line">    <span class="comment">/* Scenario: Configure and enable the global CTDAC interrupt. */</span></div><div class="line">                </div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> DAC_IRQ_cfg = {</div><div class="line"><span class="preprocessor">        #if (CY_CPU_CORTEX_M0P)</span></div><div class="line">            <span class="comment">/* .intrSrc         = */</span> NvicMux8_IRQn,             <span class="comment">/* CM0+ interrupt is NVIC #8 */</span></div><div class="line">            <span class="comment">/* .cm0pSrc         = */</span> pass_interrupt_dacs_IRQn,  <span class="comment">/* Source of NVIC #8 is the global CTDAC interrupt */</span></div><div class="line">            <span class="comment">/* .intrPriority    = */</span> 7UL                        <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <span class="comment">/* .intrSrc         = */</span> pass_interrupt_dacs_IRQn,  <span class="comment">/* Interrupt source is the global CTDAC interrupt */</span></div><div class="line">            <span class="comment">/* .intrPriority    = */</span> 7UL                        <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configure the interrupt with vector at CTDAC_Interrupt() */</span></div><div class="line">    (void)<a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;DAC_IRQ_cfg, CTDAC_Interrupt);</div><div class="line">    </div><div class="line">    <span class="comment">/* Enable the interrupt */</span></div><div class="line">    NVIC_EnableIRQ(DAC_IRQ_cfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div></div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">/* Scenario: The DMA0 block is used to transfer data from a lookup table</span></div><div class="line"><span class="comment">     * to the DAC value register. This allows for high-speed data transfers without any CPU intervention. </span></div><div class="line"><span class="comment">     * For this to work, the CTDAC trigger output must be routed to the DMA0 trigger input using trigger muxes. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Route the CTDAC trigger output to the trigger input of DMA0. */</span></div><div class="line">    (void) <a class="code" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a>(TRIG14_IN_PASS_TR_CTDAC_EMPTY, TRIG14_OUT_TR_GROUP0_INPUT50, CY_TR_MUX_TR_INV_DISABLE, TRIGGER_TYPE_PASS_TR_CTDAC_EMPTY);</div><div class="line">    (void) <a class="code" href="group__group__trigmux__functions.html#ga3671fac144b75c3b3eddc5ab46ae96f6">Cy_TrigMux_Connect</a>(TRIG0_IN_TR_GROUP14_OUTPUT7, TRIG0_OUT_CPUSS_DW0_TR_IN1, CY_TR_MUX_TR_INV_DISABLE, TRIGGER_TYPE_TR_GROUP_OUTPUT__LEVEL);</div></div><!-- fragment --> <h1><a class="anchor" id="group_ctdac_deglitch"></a>
Deglitch</h1>
<p>The hardware has the ability to deglitch the output value every time it is updated. This prevents small glitches in the DAC output during an update to propagate to the pin or opamp input. When deglitch is enabled, a switch on the output path is forced open for a configurable number of PeriClk cycles. This deglitch time is calculated as: </p><pre class="fragment">  (DEGLITCH_CNT + 1) / PERI_CLOCK_FREQ
</pre><p>The optimal and recommended deglitch time is 700 ns. Call <a class="el" href="group__group__ctdac__functions__basic.html#ga1023b3cf97003859e12ced716a557d83">Cy_CTDAC_SetDeglitchCycles</a> to set DEGLITCH_CNT.</p>
<p>There are two switches used for deglitching.</p><ul>
<li>Switch COS in the CTB between the DAC output and the Opamp0 input</li>
<li>Switch CO6 in the CTDAC between the DAC output and external pin</li>
</ul>
<p>Call <a class="el" href="group__group__ctdac__functions__basic.html#gaa327e33f705cc55c86c9e4415d28b9ff">Cy_CTDAC_SetDeglitchMode</a> to set the deglitch path. Match this with the output buffer selection. If the output is buffered through the CTB, select <a class="el" href="group__group__ctdac__enums.html#ggaa5bbaaf21bda846a109573f84f1e2735af8e7f5867ccc07b69e7cbae59efb326e">CY_CTDAC_DEGLITCHMODE_BUFFERED</a>. If the output is unbuffered to a direct pin, select <a class="el" href="group__group__ctdac__enums.html#ggaa5bbaaf21bda846a109573f84f1e2735afc4a6c4c15e30a8c37456639ed6994d6">CY_CTDAC_DEGLITCHMODE_UNBUFFERED</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If deglitching is enabled, the hardware does not force the deglitch switches into a closed state during Deep Sleep mode. Therefore, there is a chance that the device enters Deep Sleep mode while the hardware is deglitching and the switches on the output path remain open. To ensure the DAC will operate properly in Deep Sleep when enabled, make sure to register the <a class="el" href="group__group__ctdac__functions__syspm__callback.html#gae3b956a4896232dd0a2e635e178db621">Cy_CTDAC_DeepSleepCallback</a> before entering Deep Sleep mode.</dd></dl>
<h1><a class="anchor" id="group_ctdac_sample_hold"></a>
Sample and Hold</h1>
<p>When buffering the DAC output, the CTB has a Sample and Hold (SH) feature that can be used for saving power. The DAC output voltage is retained on an internal capacitor for a duration of time while the DAC output can be turned off. The DAC hardware needs to be turned on in a periodic fashion to recharge the hold capacitor. This feature is firmware controlled using a sequence of function calls. See <a class="el" href="group__group__ctb__functions__sample__hold.html#ga08a0df606bea1204aa32ea5d343ac650">Cy_CTB_DACSampleAndHold</a> in the <a class="el" href="group__group__ctb.html#group_ctb_sample_hold">CTB</a> driver.</p>
<p>The hold time depends on the supply and reference voltages. The following hold times are based on the time it takes for the buffered output to change by 1 LSB.</p>
<ul>
<li>Hold time = 750 us @ Vref = VDDA , VDDA = 1.7 V</li>
<li>Hold time = 525 us @ Vref = VDDA , VDDA = 3.6 V</li>
<li>Hold time = 200 us @ Vref = 1.2 V, VDDA = 3.6 V</li>
</ul>
<h1><a class="anchor" id="group_ctdac_low_power"></a>
Low Power Support</h1>
<p>The CTDAC driver provides a callback function to handle power mode transitions. If the CTDAC is configured for Deep Sleep operation and <a class="el" href="group__group__ctdac.html#group_ctdac_deglitch">deglitching</a> is enabled, the callback <a class="el" href="group__group__ctdac__functions__syspm__callback.html#gae3b956a4896232dd0a2e635e178db621">Cy_CTDAC_DeepSleepCallback</a> must be registered before calling <a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca">Cy_SysPm_CpuEnterDeepSleep</a>. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration.</p>
<h1><a class="anchor" id="group_ctdac_more_information"></a>
More Information</h1>
<p>Refer to the technical reference manual (TRM) and the device datasheet.</p>
<h1><a class="anchor" id="group_ctdac_MISRA"></a>
MISRA-C Compliance]</h1>
<p>This driver has the following specific deviations:</p>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th>Description of Deviation(s)  </th></tr>
<tr>
<td>11.4 </td><td>Advisory </td><td>A cast should not be performed between a pointer to object type and a different pointer to object type. </td><td>The cy_syspm driver defines the pointer to void in the <a class="el" href="structcy__stc__syspm__callback__params__t.html#a56076e99358e2b7c99681312108b09af">cy_stc_syspm_callback_params_t::base</a> field. This CTDAC driver implements a Deep Sleep callback conforming to the cy_syspm driver requirements. When the callback is called, the base is cast to a pointer to <a class="el" href="struct_c_t_d_a_c___type.html" title="The struct type definition for the hardware register set contained in the block.  The address of a va...">CTDAC_Type</a>.   </td></tr>
</table>
<h1><a class="anchor" id="group_ctdac_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>2.0.1 </td><td>Minor documentation updates. </td><td>Documentation enhancement.  </td></tr>
<tr>
<td rowspan="2">2.0 </td><td>Flattened the organization of the driver source code into the single source directory and the single include directory.  </td><td>Driver library directory-structure simplification.  </td></tr>
<tr>
<td>Added register access layer. Use register access macros instead of direct register access using dereferenced pointers. </td><td>Makes register access device-independent, so that the PDL does not need to be recompiled for each supported part number.  </td></tr>
<tr>
<td>1.0.1 </td><td>Added low power support section. Minor documentation edits. </td><td>Documentation update and clarification  </td></tr>
<tr>
<td>1.0 </td><td>Initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__ctdac__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ctdac__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__ctdac__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ctdac__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__ctdac__globals"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ctdac__globals.html">Global Variables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__ctdac__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ctdac__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__ctdac__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ctdac__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
