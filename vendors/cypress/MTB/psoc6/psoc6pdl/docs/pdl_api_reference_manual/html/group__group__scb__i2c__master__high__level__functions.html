<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Master High-Level</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__i2c__master__high__level__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Master High-Level<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a> &raquo; <a class="el" href="group__group__scb__i2c.html">I2C (SCB)</a> &raquo; <a class="el" href="group__group__scb__i2c__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga91f7a32d2a20cf3deebe01cef8d9d000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="structcy__stc__scb__i2c__master__xfer__config__t.html">cy_stc_scb_i2c_master_xfer_config_t</a> *xferConfig, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:ga91f7a32d2a20cf3deebe01cef8d9d000"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the master to automatically write an entire buffer of data to a slave device.  <a href="#ga91f7a32d2a20cf3deebe01cef8d9d000">More...</a><br /></td></tr>
<tr class="separator:ga91f7a32d2a20cf3deebe01cef8d9d000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0815311112e61ca8c1268a6f637dc427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga0815311112e61ca8c1268a6f637dc427">Cy_SCB_I2C_MasterAbortWrite</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0815311112e61ca8c1268a6f637dc427"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requests the master to abort write operation by generating a Stop condition.  <a href="#ga0815311112e61ca8c1268a6f637dc427">More...</a><br /></td></tr>
<tr class="separator:ga0815311112e61ca8c1268a6f637dc427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83185adeefa83640ac09852c9d6cf426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="structcy__stc__scb__i2c__master__xfer__config__t.html">cy_stc_scb_i2c_master_xfer_config_t</a> *xferConfig, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:ga83185adeefa83640ac09852c9d6cf426"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the master to automatically read an entire buffer of data from the slave device.  <a href="#ga83185adeefa83640ac09852c9d6cf426">More...</a><br /></td></tr>
<tr class="separator:ga83185adeefa83640ac09852c9d6cf426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae25688c0c4f7434a6284c452c9ebd897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__master__high__level__functions.html#gae25688c0c4f7434a6284c452c9ebd897">Cy_SCB_I2C_MasterAbortRead</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *context)</td></tr>
<tr class="memdesc:gae25688c0c4f7434a6284c452c9ebd897"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function requests master to abort read operation by NAKing the next byte and generating a Stop condition.  <a href="#gae25688c0c4f7434a6284c452c9ebd897">More...</a><br /></td></tr>
<tr class="separator:gae25688c0c4f7434a6284c452c9ebd897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652a3b9da6db2424fed62c28c6347ef3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga652a3b9da6db2424fed62c28c6347ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current I2C master status.  <a href="#ga652a3b9da6db2424fed62c28c6347ef3">More...</a><br /></td></tr>
<tr class="separator:ga652a3b9da6db2424fed62c28c6347ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae70af483602c1b26248c5a74a72c74c7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__master__high__level__functions.html#gae70af483602c1b26248c5a74a72c74c7">Cy_SCB_I2C_MasterGetTransferCount</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base, <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *context)</td></tr>
<tr class="memdesc:gae70af483602c1b26248c5a74a72c74c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes transferred since the last call of <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a> or <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a> function.  <a href="#gae70af483602c1b26248c5a74a72c74c7">More...</a><br /></td></tr>
<tr class="separator:gae70af483602c1b26248c5a74a72c74c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga91f7a32d2a20cf3deebe01cef8d9d000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91f7a32d2a20cf3deebe01cef8d9d000">&#9670;&nbsp;</a></span>Cy_SCB_I2C_MasterWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a> Cy_SCB_I2C_MasterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__master__xfer__config__t.html">cy_stc_scb_i2c_master_xfer_config_t</a> *&#160;</td>
          <td class="paramname"><em>xferConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the master to automatically write an entire buffer of data to a slave device. </p>
<p>After the transaction is initiated by this function it returns and <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> manages further data transfer.</p>
<p>When a write transaction is completed (requested number of bytes are written or error occurred) the <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> status is cleared and the <a class="el" href="group__group__scb__i2c__macros__callback__events.html#gaf02c69c9cef5ecd87100df9d8ec9ea0f">CY_SCB_I2C_MASTER_WR_CMPLT_EVENT</a> event is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">xferConfig</td><td>Master transfer configuration structure <a class="el" href="structcy__stc__scb__i2c__master__xfer__config__t.html">cy_stc_scb_i2c_master_xfer_config_t</a>.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The buffer must not be modified and must stay allocated until data has been copied into the TX FIFO.</li>
<li><a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a> requests the SCB hardware to generate a start condition when there is no pending transfer and returns (does not wait until hardware generate a start condition). If the I2C bus is busy the hardware will not generate the until bus becomes free. The SCB hardware sets the busy status after the Start detection, and clears it on the Stop detection. Noise caused by the ESD or other events may cause an erroneous Start condition on the bus. Then, the master will never generate a Start condition because the hardware assumes the bus is busy. If this occurs, the <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a> returns <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> status and the transaction will never finish. The option is to implement a timeout to detect the transfer completion. If the transfer never completes, the SCB needs a reset by calling the <a class="el" href="group__group__scb__i2c__general__functions.html#ga914462cc121171d82335036e65d6ea78">Cy_SCB_I2C_Disable</a> and <a class="el" href="group__group__scb__i2c__general__functions.html#gad14d83faab69d2ac96feede664df3687">Cy_SCB_I2C_Enable</a> functions. The <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga0815311112e61ca8c1268a6f637dc427">Cy_SCB_I2C_MasterAbortWrite</a> function will not work, the block must be reset. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0815311112e61ca8c1268a6f637dc427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0815311112e61ca8c1268a6f637dc427">&#9670;&nbsp;</a></span>Cy_SCB_I2C_MasterAbortWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_I2C_MasterAbortWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requests the master to abort write operation by generating a Stop condition. </p>
<p>The function does not wait until this action is completed. Therefore next write operation can be initiated only after the <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Side Effects</dt><dd>If the TX FIFO is used, it is cleared before Stop generation. The TX FIFO clear operation also clears shift register. Thus, the shifter could be cleared in the middle of a data element transfer, corrupting it. The remaining bits to transfer within corrupted data element are complemented with ones.<br />
If the clear operation is requested while the master transmits the address, the direction of transaction is changed to read and one byte is read before Stop is issued. This byte is discarded. </dd></dl>

</div>
</div>
<a id="ga83185adeefa83640ac09852c9d6cf426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83185adeefa83640ac09852c9d6cf426">&#9670;&nbsp;</a></span>Cy_SCB_I2C_MasterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a> Cy_SCB_I2C_MasterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__master__xfer__config__t.html">cy_stc_scb_i2c_master_xfer_config_t</a> *&#160;</td>
          <td class="paramname"><em>xferConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the master to automatically read an entire buffer of data from the slave device. </p>
<p>After the transaction is initiated by this function it returns and <a class="el" href="group__group__scb__i2c__interrupt__functions.html#ga729b2fa4de4d44ea2e8995d7ca6a0c24">Cy_SCB_I2C_Interrupt</a> manages further data transfer.</p>
<p>When a read transaction is completed (requested number of bytes are read or error occurred) the <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> status is cleared and the <a class="el" href="group__group__scb__i2c__macros__callback__events.html#ga692e9cdd3ec1afa5950905558dc915d3">CY_SCB_I2C_MASTER_RD_CMPLT_EVENT</a> event is generated.</p>
<p>Note that the master must read at least one byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">xferConfig</td><td>Master transfer configuration structure <a class="el" href="structcy__stc__scb__i2c__master__xfer__config__t.html">cy_stc_scb_i2c_master_xfer_config_t</a>.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__i2c__enums.html#gaf621eb0719ad9ad7178d02268575b247">cy_en_scb_i2c_status_t</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The buffer must not be modified and must stay allocated until read operation completion.</li>
<li><a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a> requests the SCB hardware to generate a start condition when there is no pending transfer and returns (does not wait until hardware generate a start condition). If the I2C bus is busy the hardware will not generate the until bus becomes free. The SCB hardware sets the busy status after the Start detection, and clears it on the Stop detection. Noise caused by the ESD or other events may cause an erroneous Start condition on the bus. Then, the master will never generate a Start condition because the hardware assumes the bus is busy. If this occurs, the <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga652a3b9da6db2424fed62c28c6347ef3">Cy_SCB_I2C_MasterGetStatus</a> returns <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> status and the transaction will never finish. The option is to implement a timeout to detect the transfer completion. If the transfer never completes, the SCB needs a reset by calling the <a class="el" href="group__group__scb__i2c__general__functions.html#ga914462cc121171d82335036e65d6ea78">Cy_SCB_I2C_Disable</a> and <a class="el" href="group__group__scb__i2c__general__functions.html#gad14d83faab69d2ac96feede664df3687">Cy_SCB_I2C_Enable</a> functions. The <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#gae25688c0c4f7434a6284c452c9ebd897">Cy_SCB_I2C_MasterAbortRead</a> function will not work, the block must be reset. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae25688c0c4f7434a6284c452c9ebd897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae25688c0c4f7434a6284c452c9ebd897">&#9670;&nbsp;</a></span>Cy_SCB_I2C_MasterAbortRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SCB_I2C_MasterAbortRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function requests master to abort read operation by NAKing the next byte and generating a Stop condition. </p>
<p>The function does not wait until these actions are completed. Therefore the next operation can be initiated only after the <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga412fef33336fb22c95f342ccf2485a0a">CY_SCB_I2C_MASTER_BUSY</a> is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga652a3b9da6db2424fed62c28c6347ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga652a3b9da6db2424fed62c28c6347ef3">&#9670;&nbsp;</a></span>Cy_SCB_I2C_MasterGetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SCB_I2C_MasterGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current I2C master status. </p>
<p>This status is a bit mask and the value returned may have multiple bits set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__scb__i2c__macros__master__status.html">I2C Master Status</a>. Note that not all I2C master statuses are returned by this function. Refer to more details of each status.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Status is cleared by calling <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a> or <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a>. </dd></dl>

</div>
</div>
<a id="gae70af483602c1b26248c5a74a72c74c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae70af483602c1b26248c5a74a72c74c7">&#9670;&nbsp;</a></span>Cy_SCB_I2C_MasterGetTransferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_SCB_I2C_MasterGetTransferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes transferred since the last call of <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga91f7a32d2a20cf3deebe01cef8d9d000">Cy_SCB_I2C_MasterWrite</a> or <a class="el" href="group__group__scb__i2c__master__high__level__functions.html#ga83185adeefa83640ac09852c9d6cf426">Cy_SCB_I2C_MasterRead</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the I2C SCB instance.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> allocated by the user. The structure is used during the I2C operation for internal configuration and data retention. The user must not modify anything in this structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read or written by the master.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This function returns an invalid value if read or write transaction was aborted or any listed event occurs during the transaction: <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga1ce9a39fdccdb63d47aea3cc048ffb90">CY_SCB_I2C_MASTER_ARB_LOST</a>, <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga8eeded717a61477c8f06c59c00ef3f59">CY_SCB_I2C_MASTER_BUS_ERR</a> or <a class="el" href="group__group__scb__i2c__macros__master__status.html#ga39e4ddb9e5a4b11b74f10ea893bf44c2">CY_SCB_I2C_MASTER_ABORT_START</a>.</li>
<li>This number is updated only when the transaction completes, either through an error or successfully. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
