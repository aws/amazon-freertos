<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__common__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a> &raquo; <a class="el" href="group__group__scb__common.html">Common</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4cc4a30079873628f3e57ecff7c20791"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga4cc4a30079873628f3e57ecff7c20791">Cy_SCB_ReadRxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga4cc4a30079873628f3e57ecff7c20791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a data element directly out of the RX FIFO.  <a href="#ga4cc4a30079873628f3e57ecff7c20791">More...</a><br /></td></tr>
<tr class="separator:ga4cc4a30079873628f3e57ecff7c20791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d034531ea5eb2695ed018d6a75da68"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga64d034531ea5eb2695ed018d6a75da68">Cy_SCB_SetRxFifoLevel</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t level)</td></tr>
<tr class="memdesc:ga64d034531ea5eb2695ed018d6a75da68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RX FIFO level.  <a href="#ga64d034531ea5eb2695ed018d6a75da68">More...</a><br /></td></tr>
<tr class="separator:ga64d034531ea5eb2695ed018d6a75da68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609852206a4ebd6e375bfadccc1309d1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga609852206a4ebd6e375bfadccc1309d1">Cy_SCB_GetNumInRxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga609852206a4ebd6e375bfadccc1309d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data elements currently in the RX FIFO.  <a href="#ga609852206a4ebd6e375bfadccc1309d1">More...</a><br /></td></tr>
<tr class="separator:ga609852206a4ebd6e375bfadccc1309d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d298c978eb0efa15c61663c7ff4b31"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga65d298c978eb0efa15c61663c7ff4b31">Cy_SCB_GetRxSrValid</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga65d298c978eb0efa15c61663c7ff4b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the RX FIFO Shift Register valid bit.  <a href="#ga65d298c978eb0efa15c61663c7ff4b31">More...</a><br /></td></tr>
<tr class="separator:ga65d298c978eb0efa15c61663c7ff4b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917e48e9c29d35cde17b8e7bb94ec3fb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga917e48e9c29d35cde17b8e7bb94ec3fb">Cy_SCB_ClearRxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base)</td></tr>
<tr class="memdesc:ga917e48e9c29d35cde17b8e7bb94ec3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the RX FIFO and shifter.  <a href="#ga917e48e9c29d35cde17b8e7bb94ec3fb">More...</a><br /></td></tr>
<tr class="separator:ga917e48e9c29d35cde17b8e7bb94ec3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8c63a539a502984525706e94b9969d3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gab8c63a539a502984525706e94b9969d3">Cy_SCB_WriteTxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t data)</td></tr>
<tr class="memdesc:gab8c63a539a502984525706e94b9969d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data directly into the TX FIFO.  <a href="#gab8c63a539a502984525706e94b9969d3">More...</a><br /></td></tr>
<tr class="separator:gab8c63a539a502984525706e94b9969d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36285e337c94df91a4ebe5b1ee0fd43d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga36285e337c94df91a4ebe5b1ee0fd43d">Cy_SCB_SetTxFifoLevel</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t level)</td></tr>
<tr class="memdesc:ga36285e337c94df91a4ebe5b1ee0fd43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the TX FIFO level.  <a href="#ga36285e337c94df91a4ebe5b1ee0fd43d">More...</a><br /></td></tr>
<tr class="separator:ga36285e337c94df91a4ebe5b1ee0fd43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f43347a32c0c4c27f11a9b3fa448c2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga63f43347a32c0c4c27f11a9b3fa448c2">Cy_SCB_GetNumInTxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga63f43347a32c0c4c27f11a9b3fa448c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data elements currently in the TX FIFO.  <a href="#ga63f43347a32c0c4c27f11a9b3fa448c2">More...</a><br /></td></tr>
<tr class="separator:ga63f43347a32c0c4c27f11a9b3fa448c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29625f5e80763aeb9d8008f58d7ac342"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga29625f5e80763aeb9d8008f58d7ac342">Cy_SCB_GetTxSrValid</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga29625f5e80763aeb9d8008f58d7ac342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the TX FIFO Shift Register valid bit.  <a href="#ga29625f5e80763aeb9d8008f58d7ac342">More...</a><br /></td></tr>
<tr class="separator:ga29625f5e80763aeb9d8008f58d7ac342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00df1df5597c1e370acd9c2e9d82455b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga00df1df5597c1e370acd9c2e9d82455b">Cy_SCB_IsTxComplete</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga00df1df5597c1e370acd9c2e9d82455b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the TX FIFO and Shifter are empty and there is no more data to send.  <a href="#ga00df1df5597c1e370acd9c2e9d82455b">More...</a><br /></td></tr>
<tr class="separator:ga00df1df5597c1e370acd9c2e9d82455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2569d2d15d292c1a36ed2159defb46"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga0c2569d2d15d292c1a36ed2159defb46">Cy_SCB_ClearTxFifo</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base)</td></tr>
<tr class="memdesc:ga0c2569d2d15d292c1a36ed2159defb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the TX FIFO.  <a href="#ga0c2569d2d15d292c1a36ed2159defb46">More...</a><br /></td></tr>
<tr class="separator:ga0c2569d2d15d292c1a36ed2159defb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7a0d6cf0d3912a044535027acdeb64"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gafa7a0d6cf0d3912a044535027acdeb64">Cy_SCB_SetByteMode</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, bool byteMode)</td></tr>
<tr class="memdesc:gafa7a0d6cf0d3912a044535027acdeb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the RX and TX FIFOs are in byte mode.  <a href="#gafa7a0d6cf0d3912a044535027acdeb64">More...</a><br /></td></tr>
<tr class="separator:gafa7a0d6cf0d3912a044535027acdeb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d680995b0ad16dffe53a93c121d9272"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga9d680995b0ad16dffe53a93c121d9272">Cy_SCB_GetInterruptCause</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga9d680995b0ad16dffe53a93c121d9272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask of bits showing the source of the current triggered interrupt.  <a href="#ga9d680995b0ad16dffe53a93c121d9272">More...</a><br /></td></tr>
<tr class="separator:ga9d680995b0ad16dffe53a93c121d9272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d2cbfbc9abd121cb8c416b3e32793bc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga5d2cbfbc9abd121cb8c416b3e32793bc">Cy_SCB_GetRxInterruptStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga5d2cbfbc9abd121cb8c416b3e32793bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RX interrupt request register.  <a href="#ga5d2cbfbc9abd121cb8c416b3e32793bc">More...</a><br /></td></tr>
<tr class="separator:ga5d2cbfbc9abd121cb8c416b3e32793bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88953f39b6d4177b53e1c44239681f83"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga88953f39b6d4177b53e1c44239681f83">Cy_SCB_SetRxInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga88953f39b6d4177b53e1c44239681f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the RX interrupt mask register.  <a href="#ga88953f39b6d4177b53e1c44239681f83">More...</a><br /></td></tr>
<tr class="separator:ga88953f39b6d4177b53e1c44239681f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b947154460358a95f487728956c2c09"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga9b947154460358a95f487728956c2c09">Cy_SCB_GetRxInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga9b947154460358a95f487728956c2c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RX interrupt mask register.  <a href="#ga9b947154460358a95f487728956c2c09">More...</a><br /></td></tr>
<tr class="separator:ga9b947154460358a95f487728956c2c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a18ae8ff92b686e37e8bc4a04fefd53"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga5a18ae8ff92b686e37e8bc4a04fefd53">Cy_SCB_GetRxInterruptStatusMasked</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga5a18ae8ff92b686e37e8bc4a04fefd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RX interrupt masked request register.  <a href="#ga5a18ae8ff92b686e37e8bc4a04fefd53">More...</a><br /></td></tr>
<tr class="separator:ga5a18ae8ff92b686e37e8bc4a04fefd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2b5b3e446dcd75979744c0e646007a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gaee2b5b3e446dcd75979744c0e646007a">Cy_SCB_ClearRxInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gaee2b5b3e446dcd75979744c0e646007a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the RX interrupt sources in the interrupt request register.  <a href="#gaee2b5b3e446dcd75979744c0e646007a">More...</a><br /></td></tr>
<tr class="separator:gaee2b5b3e446dcd75979744c0e646007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160c716b64b2a46bb728a988cc2596c0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga160c716b64b2a46bb728a988cc2596c0">Cy_SCB_SetRxInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga160c716b64b2a46bb728a988cc2596c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RX interrupt sources in the interrupt request register.  <a href="#ga160c716b64b2a46bb728a988cc2596c0">More...</a><br /></td></tr>
<tr class="separator:ga160c716b64b2a46bb728a988cc2596c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c4b4c6ad4a82f81128da1bb7405ff8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gaa2c4b4c6ad4a82f81128da1bb7405ff8">Cy_SCB_GetTxInterruptStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gaa2c4b4c6ad4a82f81128da1bb7405ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the TX interrupt request register.  <a href="#gaa2c4b4c6ad4a82f81128da1bb7405ff8">More...</a><br /></td></tr>
<tr class="separator:gaa2c4b4c6ad4a82f81128da1bb7405ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac262946f7afd9e5c6d0d5d73a63b4a9b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gac262946f7afd9e5c6d0d5d73a63b4a9b">Cy_SCB_SetTxInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gac262946f7afd9e5c6d0d5d73a63b4a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the TX interrupt mask register.  <a href="#gac262946f7afd9e5c6d0d5d73a63b4a9b">More...</a><br /></td></tr>
<tr class="separator:gac262946f7afd9e5c6d0d5d73a63b4a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb3559ffb3a21072ccb44dae1c72af3e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gabb3559ffb3a21072ccb44dae1c72af3e">Cy_SCB_GetTxInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gabb3559ffb3a21072ccb44dae1c72af3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the TX interrupt mask register.  <a href="#gabb3559ffb3a21072ccb44dae1c72af3e">More...</a><br /></td></tr>
<tr class="separator:gabb3559ffb3a21072ccb44dae1c72af3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70aa562e7df60c7d97bb02679aefe39f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga70aa562e7df60c7d97bb02679aefe39f">Cy_SCB_GetTxInterruptStatusMasked</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga70aa562e7df60c7d97bb02679aefe39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the TX interrupt masked request register.  <a href="#ga70aa562e7df60c7d97bb02679aefe39f">More...</a><br /></td></tr>
<tr class="separator:ga70aa562e7df60c7d97bb02679aefe39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7e288f1ce7ccfbac6680b9b357fa11"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga8d7e288f1ce7ccfbac6680b9b357fa11">Cy_SCB_ClearTxInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga8d7e288f1ce7ccfbac6680b9b357fa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the TX interrupt sources in the interrupt request register.  <a href="#ga8d7e288f1ce7ccfbac6680b9b357fa11">More...</a><br /></td></tr>
<tr class="separator:ga8d7e288f1ce7ccfbac6680b9b357fa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ad859c8fc1bbb61829dccee9de7d81"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga92ad859c8fc1bbb61829dccee9de7d81">Cy_SCB_SetTxInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga92ad859c8fc1bbb61829dccee9de7d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets TX interrupt sources in the interrupt request register.  <a href="#ga92ad859c8fc1bbb61829dccee9de7d81">More...</a><br /></td></tr>
<tr class="separator:ga92ad859c8fc1bbb61829dccee9de7d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34602fe769b0f913e8b4166eda530388"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga34602fe769b0f913e8b4166eda530388">Cy_SCB_GetMasterInterruptStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga34602fe769b0f913e8b4166eda530388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the master interrupt request register.  <a href="#ga34602fe769b0f913e8b4166eda530388">More...</a><br /></td></tr>
<tr class="separator:ga34602fe769b0f913e8b4166eda530388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f90d52d67bf39cdf78bc8de61cd9627"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga0f90d52d67bf39cdf78bc8de61cd9627">Cy_SCB_SetMasterInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga0f90d52d67bf39cdf78bc8de61cd9627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the master interrupt mask register.  <a href="#ga0f90d52d67bf39cdf78bc8de61cd9627">More...</a><br /></td></tr>
<tr class="separator:ga0f90d52d67bf39cdf78bc8de61cd9627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8038f3441952c06a5d30adf2252b9d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gafe8038f3441952c06a5d30adf2252b9d">Cy_SCB_GetMasterInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gafe8038f3441952c06a5d30adf2252b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the master interrupt mask register.  <a href="#gafe8038f3441952c06a5d30adf2252b9d">More...</a><br /></td></tr>
<tr class="separator:gafe8038f3441952c06a5d30adf2252b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f822aec978859cfe6764847eebe4abc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga0f822aec978859cfe6764847eebe4abc">Cy_SCB_GetMasterInterruptStatusMasked</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga0f822aec978859cfe6764847eebe4abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the master interrupt masked request register.  <a href="#ga0f822aec978859cfe6764847eebe4abc">More...</a><br /></td></tr>
<tr class="separator:ga0f822aec978859cfe6764847eebe4abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85dd18e458ba388ad4d6ad7e8c55778"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gad85dd18e458ba388ad4d6ad7e8c55778">Cy_SCB_ClearMasterInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gad85dd18e458ba388ad4d6ad7e8c55778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears master interrupt sources in the interrupt request register.  <a href="#gad85dd18e458ba388ad4d6ad7e8c55778">More...</a><br /></td></tr>
<tr class="separator:gad85dd18e458ba388ad4d6ad7e8c55778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a9c7c201923276d8310829fa43baed"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gab1a9c7c201923276d8310829fa43baed">Cy_SCB_SetMasterInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gab1a9c7c201923276d8310829fa43baed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets master interrupt sources in the interrupt request register.  <a href="#gab1a9c7c201923276d8310829fa43baed">More...</a><br /></td></tr>
<tr class="separator:gab1a9c7c201923276d8310829fa43baed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fd9d349b8acb303ff1ef728e29b0e22"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga6fd9d349b8acb303ff1ef728e29b0e22">Cy_SCB_GetSlaveInterruptStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga6fd9d349b8acb303ff1ef728e29b0e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the slave interrupt request register.  <a href="#ga6fd9d349b8acb303ff1ef728e29b0e22">More...</a><br /></td></tr>
<tr class="separator:ga6fd9d349b8acb303ff1ef728e29b0e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba4fe92683be8638a7596c3ab54359b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gaeba4fe92683be8638a7596c3ab54359b">Cy_SCB_SetSlaveInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gaeba4fe92683be8638a7596c3ab54359b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes slave interrupt mask register.  <a href="#gaeba4fe92683be8638a7596c3ab54359b">More...</a><br /></td></tr>
<tr class="separator:gaeba4fe92683be8638a7596c3ab54359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2008a97e40d6a14298bfcf08afac7c24"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga2008a97e40d6a14298bfcf08afac7c24">Cy_SCB_GetSlaveInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga2008a97e40d6a14298bfcf08afac7c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the slave interrupt mask register.  <a href="#ga2008a97e40d6a14298bfcf08afac7c24">More...</a><br /></td></tr>
<tr class="separator:ga2008a97e40d6a14298bfcf08afac7c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2391f2a065128fb7a04aa51fe9d4433"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gad2391f2a065128fb7a04aa51fe9d4433">Cy_SCB_GetSlaveInterruptStatusMasked</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gad2391f2a065128fb7a04aa51fe9d4433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the slave interrupt masked request register.  <a href="#gad2391f2a065128fb7a04aa51fe9d4433">More...</a><br /></td></tr>
<tr class="separator:gad2391f2a065128fb7a04aa51fe9d4433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f62b77479ad1ba27640a98811d465a8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga8f62b77479ad1ba27640a98811d465a8">Cy_SCB_ClearSlaveInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga8f62b77479ad1ba27640a98811d465a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the slave interrupt sources in the interrupt request register.  <a href="#ga8f62b77479ad1ba27640a98811d465a8">More...</a><br /></td></tr>
<tr class="separator:ga8f62b77479ad1ba27640a98811d465a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7e9b47fee87f0364ce35a4f429b4d4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga0f7e9b47fee87f0364ce35a4f429b4d4">Cy_SCB_SetSlaveInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga0f7e9b47fee87f0364ce35a4f429b4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets slave interrupt sources in the interrupt request register.  <a href="#ga0f7e9b47fee87f0364ce35a4f429b4d4">More...</a><br /></td></tr>
<tr class="separator:ga0f7e9b47fee87f0364ce35a4f429b4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaebe015505e14c548255265af4fb77d7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gaaebe015505e14c548255265af4fb77d7">Cy_SCB_GetI2CInterruptStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gaaebe015505e14c548255265af4fb77d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the I2C interrupt request register.  <a href="#gaaebe015505e14c548255265af4fb77d7">More...</a><br /></td></tr>
<tr class="separator:gaaebe015505e14c548255265af4fb77d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213ab7fca61b18cb432e91be97151d42"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga213ab7fca61b18cb432e91be97151d42">Cy_SCB_SetI2CInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga213ab7fca61b18cb432e91be97151d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the I2C interrupt mask register.  <a href="#ga213ab7fca61b18cb432e91be97151d42">More...</a><br /></td></tr>
<tr class="separator:ga213ab7fca61b18cb432e91be97151d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c051a76e2379b38fbb0c466f1f7dbd8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga7c051a76e2379b38fbb0c466f1f7dbd8">Cy_SCB_GetI2CInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga7c051a76e2379b38fbb0c466f1f7dbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the I2C interrupt mask register.  <a href="#ga7c051a76e2379b38fbb0c466f1f7dbd8">More...</a><br /></td></tr>
<tr class="separator:ga7c051a76e2379b38fbb0c466f1f7dbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6156f427bf2976eca07458e1a557a433"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga6156f427bf2976eca07458e1a557a433">Cy_SCB_GetI2CInterruptStatusMasked</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:ga6156f427bf2976eca07458e1a557a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the I2C interrupt masked request register.  <a href="#ga6156f427bf2976eca07458e1a557a433">More...</a><br /></td></tr>
<tr class="separator:ga6156f427bf2976eca07458e1a557a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b1ccc2fcdac4dc12e430bb8865a693"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga89b1ccc2fcdac4dc12e430bb8865a693">Cy_SCB_ClearI2CInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga89b1ccc2fcdac4dc12e430bb8865a693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears I2C interrupt sources in the interrupt request register.  <a href="#ga89b1ccc2fcdac4dc12e430bb8865a693">More...</a><br /></td></tr>
<tr class="separator:ga89b1ccc2fcdac4dc12e430bb8865a693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ed33ba6015b0b4ad116b72a5685a97"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gac9ed33ba6015b0b4ad116b72a5685a97">Cy_SCB_GetSpiInterruptStatus</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gac9ed33ba6015b0b4ad116b72a5685a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SPI interrupt request register.  <a href="#gac9ed33ba6015b0b4ad116b72a5685a97">More...</a><br /></td></tr>
<tr class="separator:gac9ed33ba6015b0b4ad116b72a5685a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b4740908fcc11c882fbcebcbf79158"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gaf3b4740908fcc11c882fbcebcbf79158">Cy_SCB_SetSpiInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:gaf3b4740908fcc11c882fbcebcbf79158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the SPI interrupt mask register.  <a href="#gaf3b4740908fcc11c882fbcebcbf79158">More...</a><br /></td></tr>
<tr class="separator:gaf3b4740908fcc11c882fbcebcbf79158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0ffac666d098ad1eb450defd472ac6f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gad0ffac666d098ad1eb450defd472ac6f">Cy_SCB_GetSpiInterruptMask</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gad0ffac666d098ad1eb450defd472ac6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SPI interrupt mask register.  <a href="#gad0ffac666d098ad1eb450defd472ac6f">More...</a><br /></td></tr>
<tr class="separator:gad0ffac666d098ad1eb450defd472ac6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe022dae40dd39d861033ea44ea3e095"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#gabe022dae40dd39d861033ea44ea3e095">Cy_SCB_GetSpiInterruptStatusMasked</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *base)</td></tr>
<tr class="memdesc:gabe022dae40dd39d861033ea44ea3e095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SPI interrupt masked request register.  <a href="#gabe022dae40dd39d861033ea44ea3e095">More...</a><br /></td></tr>
<tr class="separator:gabe022dae40dd39d861033ea44ea3e095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f78da1f7bdf7b0e6603652c78577073"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__common__functions.html#ga8f78da1f7bdf7b0e6603652c78577073">Cy_SCB_ClearSpiInterrupt</a> (<a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *base, uint32_t interruptMask)</td></tr>
<tr class="memdesc:ga8f78da1f7bdf7b0e6603652c78577073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears SPI interrupt sources in the interrupt request register.  <a href="#ga8f78da1f7bdf7b0e6603652c78577073">More...</a><br /></td></tr>
<tr class="separator:ga8f78da1f7bdf7b0e6603652c78577073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4cc4a30079873628f3e57ecff7c20791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc4a30079873628f3e57ecff7c20791">&#9670;&nbsp;</a></span>Cy_SCB_ReadRxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_ReadRxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a data element directly out of the RX FIFO. </p>
<p>This function does not check whether the RX FIFO has data before reading it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data from RX FIFO. </dd></dl>

</div>
</div>
<a id="ga64d034531ea5eb2695ed018d6a75da68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64d034531ea5eb2695ed018d6a75da68">&#9670;&nbsp;</a></span>Cy_SCB_SetRxFifoLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetRxFifoLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RX FIFO level. </p>
<p>When there are more data elements in the RX FIFO than this level, the RX FIFO level interrupt is triggered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">level</td><td>When there are more data elements in the FIFO than this level, the RX level interrupt is triggered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga609852206a4ebd6e375bfadccc1309d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga609852206a4ebd6e375bfadccc1309d1">&#9670;&nbsp;</a></span>Cy_SCB_GetNumInRxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetNumInRxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data elements currently in the RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number or data elements in RX FIFO. </dd></dl>

</div>
</div>
<a id="ga65d298c978eb0efa15c61663c7ff4b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65d298c978eb0efa15c61663c7ff4b31">&#9670;&nbsp;</a></span>Cy_SCB_GetRxSrValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetRxSrValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the RX FIFO Shift Register valid bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 - RX shift register valid; 0 - RX shift register not valid. </dd></dl>

</div>
</div>
<a id="ga917e48e9c29d35cde17b8e7bb94ec3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga917e48e9c29d35cde17b8e7bb94ec3fb">&#9670;&nbsp;</a></span>Cy_SCB_ClearRxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_ClearRxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the RX FIFO and shifter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there is partial data in the shifter, it is cleared and lost. </dd></dl>

</div>
</div>
<a id="gab8c63a539a502984525706e94b9969d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8c63a539a502984525706e94b9969d3">&#9670;&nbsp;</a></span>Cy_SCB_WriteTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_WriteTxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data directly into the TX FIFO. </p>
<p>This function does not check whether the TX FIFO is not full before writing into it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">data</td><td>Data to write to the TX FIFO. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36285e337c94df91a4ebe5b1ee0fd43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36285e337c94df91a4ebe5b1ee0fd43d">&#9670;&nbsp;</a></span>Cy_SCB_SetTxFifoLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetTxFifoLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the TX FIFO level. </p>
<p>When there are fewer data elements in the TX FIFO than this level, the TX FIFO level interrupt is triggered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">level</td><td>When there are fewer data elements in the FIFO than this level, the TX level interrupt is triggered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63f43347a32c0c4c27f11a9b3fa448c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f43347a32c0c4c27f11a9b3fa448c2">&#9670;&nbsp;</a></span>Cy_SCB_GetNumInTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetNumInTxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data elements currently in the TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number or data elements in the TX FIFO. </dd></dl>

</div>
</div>
<a id="ga29625f5e80763aeb9d8008f58d7ac342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29625f5e80763aeb9d8008f58d7ac342">&#9670;&nbsp;</a></span>Cy_SCB_GetTxSrValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetTxSrValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the TX FIFO Shift Register valid bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 - TX shift register valid; 0 - TX shift register not valid. </dd></dl>

</div>
</div>
<a id="ga00df1df5597c1e370acd9c2e9d82455b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00df1df5597c1e370acd9c2e9d82455b">&#9670;&nbsp;</a></span>Cy_SCB_IsTxComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SCB_IsTxComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the TX FIFO and Shifter are empty and there is no more data to send. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to SPI the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If true, transmission complete. If false, transmission is not complete. </dd></dl>

</div>
</div>
<a id="ga0c2569d2d15d292c1a36ed2159defb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c2569d2d15d292c1a36ed2159defb46">&#9670;&nbsp;</a></span>Cy_SCB_ClearTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_ClearTxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The TX FIFO clear operation also clears the shift register. Thus the shifter could be cleared in the middle of a data element transfer. Thia results in "ones" being sent on the bus for the remainder of the transfer. </dd></dl>

</div>
</div>
<a id="gafa7a0d6cf0d3912a044535027acdeb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa7a0d6cf0d3912a044535027acdeb64">&#9670;&nbsp;</a></span>Cy_SCB_SetByteMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetByteMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>byteMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the RX and TX FIFOs are in byte mode. </p>
<p>The FIFOs are either 16-bit wide or 8-bit wide (byte mode). When the FIFO is in byte mode it is twice as deep. See the device datasheet for FIFO depths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">byteMode</td><td>If true, TX and RX FIFOs are 8-bit wide. If false, the FIFOs are 16-bit wide. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d680995b0ad16dffe53a93c121d9272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d680995b0ad16dffe53a93c121d9272">&#9670;&nbsp;</a></span>Cy_SCB_GetInterruptCause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetInterruptCause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mask of bits showing the source of the current triggered interrupt. </p>
<p>This is useful for modes of operation where an interrupt can be generated by conditions in multiple interrupt source registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mask with the OR of the following conditions that have been triggered. See <a class="el" href="group__group__scb__common__macros__intr__cause.html">SCB Interrupt Causes</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga5d2cbfbc9abd121cb8c416b3e32793bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d2cbfbc9abd121cb8c416b3e32793bc">&#9670;&nbsp;</a></span>Cy_SCB_GetRxInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetRxInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the RX interrupt request register. </p>
<p>This register contains the current status of the RX interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of the RX interrupt sources. Each constant is a bit field value. The value returned may have multiple bits set to indicate the current status. See <a class="el" href="group__group__scb__common__macros__rx__intr.html">RX Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga88953f39b6d4177b53e1c44239681f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88953f39b6d4177b53e1c44239681f83">&#9670;&nbsp;</a></span>Cy_SCB_SetRxInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetRxInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the RX interrupt mask register. </p>
<p>This register configures which bits from the RX interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>Enabled RX interrupt sources. See <a class="el" href="group__group__scb__common__macros__rx__intr.html">RX Interrupt Statuses</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b947154460358a95f487728956c2c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b947154460358a95f487728956c2c09">&#9670;&nbsp;</a></span>Cy_SCB_GetRxInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetRxInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the RX interrupt mask register. </p>
<p>This register specifies which bits from the RX interrupt request register trigger can an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enabled RX interrupt sources. See <a class="el" href="group__group__scb__common__macros__rx__intr.html">RX Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga5a18ae8ff92b686e37e8bc4a04fefd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a18ae8ff92b686e37e8bc4a04fefd53">&#9670;&nbsp;</a></span>Cy_SCB_GetRxInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetRxInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the RX interrupt masked request register. </p>
<p>This register contains a logical AND of corresponding bits from the RX interrupt request and mask registers. This function is intended to be used in the interrupt service routine to identify which of the enabled RX interrupt sources caused the interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of enabled RX interrupt sources. See <a class="el" href="group__group__scb__common__macros__rx__intr.html">RX Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="gaee2b5b3e446dcd75979744c0e646007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee2b5b3e446dcd75979744c0e646007a">&#9670;&nbsp;</a></span>Cy_SCB_ClearRxInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_ClearRxInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the RX interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The RX interrupt sources to be cleared. See <a class="el" href="group__group__scb__common__macros__rx__intr.html">RX Interrupt Statuses</a> for the set of constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>CY_SCB_INTR_RX_FIFO_LEVEL interrupt source is not cleared when the RX FIFO has more entries than the level.</li>
<li>CY_SCB_INTR_RX_NOT_EMPTY interrupt source is not cleared when the RX FIFO is not empty.</li>
<li>CY_SCB_INTR_RX_FULL interrupt source is not cleared when the RX FIFO is full. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga160c716b64b2a46bb728a988cc2596c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga160c716b64b2a46bb728a988cc2596c0">&#9670;&nbsp;</a></span>Cy_SCB_SetRxInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetRxInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RX interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The RX interrupt sources to set in the RX interrupt request register. See <a class="el" href="group__group__scb__common__macros__rx__intr.html">RX Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2c4b4c6ad4a82f81128da1bb7405ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2c4b4c6ad4a82f81128da1bb7405ff8">&#9670;&nbsp;</a></span>Cy_SCB_GetTxInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetTxInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the TX interrupt request register. </p>
<p>This register contains the current status of the TX interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of TX interrupt sources. Each constant is a bit field value. The value returned may have multiple bits set to indicate the current status. See <a class="el" href="group__group__scb__common__macros__tx__intr.html">TX Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="gac262946f7afd9e5c6d0d5d73a63b4a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac262946f7afd9e5c6d0d5d73a63b4a9b">&#9670;&nbsp;</a></span>Cy_SCB_SetTxInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetTxInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the TX interrupt mask register. </p>
<p>This register configures which bits from the TX interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>Enabled TX interrupt sources. See <a class="el" href="group__group__scb__common__macros__tx__intr.html">TX Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb3559ffb3a21072ccb44dae1c72af3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb3559ffb3a21072ccb44dae1c72af3e">&#9670;&nbsp;</a></span>Cy_SCB_GetTxInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetTxInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the TX interrupt mask register. </p>
<p>This register specifies which bits from the TX interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enabled TX interrupt sources. See <a class="el" href="group__group__scb__common__macros__tx__intr.html">TX Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga70aa562e7df60c7d97bb02679aefe39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70aa562e7df60c7d97bb02679aefe39f">&#9670;&nbsp;</a></span>Cy_SCB_GetTxInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetTxInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the TX interrupt masked request register. </p>
<p>This register contains a logical AND of corresponding bits from the TX interrupt request and mask registers. This function is intended to be used in the interrupt service routine to identify which of enabled TX interrupt sources caused the interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of enabled TX interrupt sources. See <a class="el" href="group__group__scb__common__macros__tx__intr.html">TX Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga8d7e288f1ce7ccfbac6680b9b357fa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7e288f1ce7ccfbac6680b9b357fa11">&#9670;&nbsp;</a></span>Cy_SCB_ClearTxInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_ClearTxInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the TX interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The TX interrupt sources to be cleared. See <a class="el" href="group__group__scb__common__macros__tx__intr.html">TX Interrupt Statuses</a> for the set of constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>CY_SCB_INTR_TX_FIFO_LEVEL interrupt source is not cleared when the TX FIFO has fewer entries than the TX level.</li>
<li>CY_SCB_INTR_TX_NOT_FULL interrupt source is not cleared when the TX FIFO has empty entries in the TX FIFO.</li>
<li>CY_SCB_INTR_TX_EMPTY interrupt source is not cleared when the TX FIFO is empty.</li>
<li>CY_SCB_INTR_TX_UNDERFLOW interrupt source is not cleared when the TX FIFO is empty. Put data into the TX FIFO before clearing it. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga92ad859c8fc1bbb61829dccee9de7d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ad859c8fc1bbb61829dccee9de7d81">&#9670;&nbsp;</a></span>Cy_SCB_SetTxInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetTxInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets TX interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The TX interrupt sources to set in the TX interrupt request register. See <a class="el" href="group__group__scb__common__macros__tx__intr.html">TX Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga34602fe769b0f913e8b4166eda530388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34602fe769b0f913e8b4166eda530388">&#9670;&nbsp;</a></span>Cy_SCB_GetMasterInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetMasterInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the master interrupt request register. </p>
<p>This register contains the current status of the master interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of the master interrupt sources. Each constant is a bit field value. The value returned may have multiple bits set to indicate the current status. See <a class="el" href="group__group__scb__common__macros__master__intr.html">Master Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga0f90d52d67bf39cdf78bc8de61cd9627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f90d52d67bf39cdf78bc8de61cd9627">&#9670;&nbsp;</a></span>Cy_SCB_SetMasterInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetMasterInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the master interrupt mask register. </p>
<p>This register specifies which bits from the master interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The master interrupt sources to be enable. See <a class="el" href="group__group__scb__common__macros__master__intr.html">Master Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe8038f3441952c06a5d30adf2252b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe8038f3441952c06a5d30adf2252b9d">&#9670;&nbsp;</a></span>Cy_SCB_GetMasterInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetMasterInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the master interrupt mask register. </p>
<p>This register specifies which bits from the master interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enabled master interrupt sources. See <a class="el" href="group__group__scb__common__macros__master__intr.html">Master Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga0f822aec978859cfe6764847eebe4abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f822aec978859cfe6764847eebe4abc">&#9670;&nbsp;</a></span>Cy_SCB_GetMasterInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetMasterInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the master interrupt masked request register. </p>
<p>This register contains a logical AND of corresponding bits from the master interrupt request and mask registers. This function is intended to be used in the interrupt service routine to identify which of the enabled master interrupt sources caused the interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of enabled master interrupt sources. See <a class="el" href="group__group__scb__common__macros__master__intr.html">Master Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="gad85dd18e458ba388ad4d6ad7e8c55778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad85dd18e458ba388ad4d6ad7e8c55778">&#9670;&nbsp;</a></span>Cy_SCB_ClearMasterInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_ClearMasterInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears master interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The master interrupt sources to be cleared. See <a class="el" href="group__group__scb__common__macros__master__intr.html">Master Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1a9c7c201923276d8310829fa43baed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1a9c7c201923276d8310829fa43baed">&#9670;&nbsp;</a></span>Cy_SCB_SetMasterInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetMasterInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets master interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The master interrupt sources to set in the master interrupt request register. See <a class="el" href="group__group__scb__common__macros__master__intr.html">Master Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6fd9d349b8acb303ff1ef728e29b0e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fd9d349b8acb303ff1ef728e29b0e22">&#9670;&nbsp;</a></span>Cy_SCB_GetSlaveInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetSlaveInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the slave interrupt request register. </p>
<p>This register contains the current status of the slave interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of the slave interrupt sources. Each constant is a bit field value. The value returned may have multiple bits set to indicate the current status. See <a class="el" href="group__group__scb__common__macros__slave__intr.html">Slave Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="gaeba4fe92683be8638a7596c3ab54359b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeba4fe92683be8638a7596c3ab54359b">&#9670;&nbsp;</a></span>Cy_SCB_SetSlaveInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetSlaveInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes slave interrupt mask register. </p>
<p>This register specifies which bits from the slave interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>Enabled slave interrupt sources. See <a class="el" href="group__group__scb__common__macros__slave__intr.html">Slave Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2008a97e40d6a14298bfcf08afac7c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2008a97e40d6a14298bfcf08afac7c24">&#9670;&nbsp;</a></span>Cy_SCB_GetSlaveInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetSlaveInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the slave interrupt mask register. </p>
<p>This register specifies which bits from the slave interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enabled slave interrupt sources. See <a class="el" href="group__group__scb__common__macros__slave__intr.html">Slave Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="gad2391f2a065128fb7a04aa51fe9d4433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2391f2a065128fb7a04aa51fe9d4433">&#9670;&nbsp;</a></span>Cy_SCB_GetSlaveInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetSlaveInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the slave interrupt masked request register. </p>
<p>This register contains a logical AND of corresponding bits from the slave interrupt request and mask registers. This function is intended to be used in the interrupt service routine to identify which of enabled slave interrupt sources caused the interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of enabled slave interrupt sources. See <a class="el" href="group__group__scb__common__macros__slave__intr.html">Slave Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga8f62b77479ad1ba27640a98811d465a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f62b77479ad1ba27640a98811d465a8">&#9670;&nbsp;</a></span>Cy_SCB_ClearSlaveInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_ClearSlaveInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the slave interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>Slave interrupt sources to be cleared. See <a class="el" href="group__group__scb__common__macros__slave__intr.html">Slave Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f7e9b47fee87f0364ce35a4f429b4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7e9b47fee87f0364ce35a4f429b4d4">&#9670;&nbsp;</a></span>Cy_SCB_SetSlaveInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetSlaveInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets slave interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The slave interrupt sources to set in the slave interrupt request register See <a class="el" href="group__group__scb__common__macros__slave__intr.html">Slave Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaebe015505e14c548255265af4fb77d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaebe015505e14c548255265af4fb77d7">&#9670;&nbsp;</a></span>Cy_SCB_GetI2CInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetI2CInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the I2C interrupt request register. </p>
<p>This register contains the current status of the I2C interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of the I2C interrupt sources. Each constant is a bit field value. The value returned may have multiple bits set to indicate the current status. See <a class="el" href="group__group__scb__common__macros__slave__intr.html">Slave Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga213ab7fca61b18cb432e91be97151d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga213ab7fca61b18cb432e91be97151d42">&#9670;&nbsp;</a></span>Cy_SCB_SetI2CInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetI2CInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the I2C interrupt mask register. </p>
<p>This register specifies which bits from the I2C interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>Enabled I2C interrupt sources. See <a class="el" href="group__group__scb__common__macros__i2c__intr.html">I2C Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c051a76e2379b38fbb0c466f1f7dbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c051a76e2379b38fbb0c466f1f7dbd8">&#9670;&nbsp;</a></span>Cy_SCB_GetI2CInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetI2CInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the I2C interrupt mask register. </p>
<p>This register specifies which bits from the I2C interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enabled I2C interrupt sources. See <a class="el" href="group__group__scb__common__macros__i2c__intr.html">I2C Interrupt Statuses</a>. </dd></dl>

</div>
</div>
<a id="ga6156f427bf2976eca07458e1a557a433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6156f427bf2976eca07458e1a557a433">&#9670;&nbsp;</a></span>Cy_SCB_GetI2CInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetI2CInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the I2C interrupt masked request register. </p>
<p>This register contains a logical AND of corresponding bits from I2C interrupt request and mask registers. This function is intended to be used in the interrupt service routine to identify which of enabled I2C interrupt sources caused the interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of enabled I2C interrupt sources. See <a class="el" href="group__group__scb__common__macros__i2c__intr.html">I2C Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga89b1ccc2fcdac4dc12e430bb8865a693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b1ccc2fcdac4dc12e430bb8865a693">&#9670;&nbsp;</a></span>Cy_SCB_ClearI2CInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_ClearI2CInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears I2C interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The I2C interrupt sources to be cleared. See <a class="el" href="group__group__scb__common__macros__i2c__intr.html">I2C Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9ed33ba6015b0b4ad116b72a5685a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9ed33ba6015b0b4ad116b72a5685a97">&#9670;&nbsp;</a></span>Cy_SCB_GetSpiInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetSpiInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the SPI interrupt request register. </p>
<p>This register contains the current status of the SPI interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of SPI interrupt sources. Each constant is a bit field value. The value returned may have multiple bits set to indicate the current status See <a class="el" href="group__group__scb__common__macros___spi_intr_statuses.html">SPI Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="gaf3b4740908fcc11c882fbcebcbf79158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b4740908fcc11c882fbcebcbf79158">&#9670;&nbsp;</a></span>Cy_SCB_SetSpiInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_SetSpiInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the SPI interrupt mask register. </p>
<p>This register specifies which bits from the SPI interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>Enabled SPI interrupt sources. See <a class="el" href="group__group__scb__common__macros___spi_intr_statuses.html">SPI Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0ffac666d098ad1eb450defd472ac6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0ffac666d098ad1eb450defd472ac6f">&#9670;&nbsp;</a></span>Cy_SCB_GetSpiInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetSpiInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the SPI interrupt mask register. </p>
<p>This register specifies which bits from the SPI interrupt request register can trigger an interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enabled SPI interrupt sources. See <a class="el" href="group__group__scb__common__macros___spi_intr_statuses.html">SPI Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="gabe022dae40dd39d861033ea44ea3e095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe022dae40dd39d861033ea44ea3e095">&#9670;&nbsp;</a></span>Cy_SCB_GetSpiInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SCB_GetSpiInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the SPI interrupt masked request register. </p>
<p>This register contains a logical AND of corresponding bits from the SPI interrupt request and mask registers. This function is intended to be used in the interrupt service routine to identify which of enabled SPI interrupt sources caused the interrupt event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of enabled SPI interrupt sources. See <a class="el" href="group__group__scb__common__macros___spi_intr_statuses.html">SPI Interrupt Statuses</a> for the set of constants. </dd></dl>

</div>
</div>
<a id="ga8f78da1f7bdf7b0e6603652c78577073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f78da1f7bdf7b0e6603652c78577073">&#9670;&nbsp;</a></span>Cy_SCB_ClearSpiInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SCB_ClearSpiInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cy_s_c_b___type.html">CySCB_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears SPI interrupt sources in the interrupt request register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the SCB instance.</td></tr>
    <tr><td class="paramname">interruptMask</td><td>The SPI interrupt sources to be cleared. See <a class="el" href="group__group__scb__common__macros___spi_intr_statuses.html">SPI Interrupt Statuses</a> for the set of constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
