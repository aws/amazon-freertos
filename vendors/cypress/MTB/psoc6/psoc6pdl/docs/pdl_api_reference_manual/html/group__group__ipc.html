<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: IPC          (Inter Process Communication)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__ipc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">IPC (Inter Process Communication)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The inter-processor communication (IPC) driver provides a safe and reliable method to transfer data between CPUs. </p>
<p>Hardware locking ensures that only one device can acquire and transfer data at a time so no data is lost or overwritten by asynchronous processes or CPUs.</p>
<p>Include either cy_ipc_pipe.h or cy_ipc_sema.h. Alternatively include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>There are three parts to the API:</p><ul>
<li>Driver-level (DRV) API - used internally by Semaphore and Pipe levels</li>
<li>Pipe-level (PIPE) API - establishes a communication channel between processors</li>
<li>Semaphore-level (SEMA) API - enables users to set and clear flags to synchronize operations.</li>
</ul>
<p>Firmware does not need to use the DRV API. It can implement IPC functionality entirely with the PIPE and SEMA APIs.</p>
<h1><a class="anchor" id="group_ipc_background"></a>
Background</h1>
<p>IPC is implemented in hardware as a collection of individual communication channels, each with a set of 32-bit registers. The IPC design implements a set of interrupts that enable each processor to notify the other that data is available, or has been processed. There is also a locking mechanism that allows only one CPU to gain access at a time.</p>
<p>The Driver-level API manages each channel's registers to implement IPC functionality. For information on the IPC registers, see the IPC chapter of the Technical Reference Manual (TRM).</p>
<p>At the hardware level, communication is a five-step process.</p><ol type="1">
<li>The sending processor acquires a channel</li>
<li>It puts data into the channel</li>
<li>The sender generates a notify event (interrupt)</li>
<li>The receiving processor identifies the sender and retrieves the data</li>
<li>The receiving processor generates a release event (interrupt)</li>
</ol>
<div class="image">
<img src="ipc_driver.png" alt="ipc_driver.png"/>
</div>
<p>These transactions are handled transparently by the DRV-level API. Use the PIPE and SEMA layers of the API to implement communication in your application. The data transferred is limited to a single 32-bit value. As implemented by the PIPE API, that value is a pointer to a data structure of arbitrary size and complexity.</p>
<h1><a class="anchor" id="group_ipc_overview"></a>
Overview</h1>
<p>The Pipe is the key element in the PDL design. A pipe is typically a full-duplex communication channel between CPU cores. A pipe allows a single conduit to transfer messages or data to and from multiple processes or CPUs.</p>
<p>A pipe has two endpoints, one on each core. Each endpoint contains a dedicated IPC channel and an interrupt. IPC channels 0-7(8 for the CYB064XX devices) and IPC interrupts 0-7 are reserved for system use.</p>
<p>The pipe also contains the number of clients it supports, and for each client a callback function. So the pipe can service a number of clients, each with a separate callback function, on either endpoint. The number of clients a pipe supports is the sum of each endpoint's clients.</p>
<p>This design enables any number of processes on the sending core to put arbitrary data into a single pipe. The first element of that data is the client ID of the client that should handle the data.</p>
<p>An interrupt notifies the receiving core that data is available. The receiving core parses the data to identify the client, and then dispatches the event to the appropriate client via the client callback function. An interrupt notifies the sending core that the receiver is finished. In this way a single pipe can manage arbitrary data transfers between cores with data flowing in either direction.</p>
<div class="image">
<img src="ipc_ints.png" alt="ipc_ints.png"/>
</div>
<p>The application can use semaphores to control access to shared resources, as required by the application's logic.</p>
<p>The PDL provides specific files that set up default IPC functionality. They are system_psoc6.h, system_psoc6_cm0plus.c and system_psoc6_cm4.c. You can modify these files based on the requirements of your design. If you use PSoC Creator as a development environment, it will not overwrite your changes when you generate the application or build your code.</p>
<h1><a class="anchor" id="group_ipc_pipe_layer"></a>
PIPE layer</h1>
<p>A pipe is a communication channel between two endpoints. PSoC 6 devices support 16 IPC channels, and 16 IPC interrupts, each numbered 0-15. IPC Channels 0-7 and IPC interrupts 0-7 are reserved for system use. Channels 8-15 and interrupts 8-15 are available for application use.</p>
<p>A full duplex pipe uses two IPC channels, one per endpoint. Each endpoint specifies all the information required to process a message (either sent or received). Each endpoint is configured to use an IPC channel, and an IPC interrupt. Common practice is to use the interrupt with the same number as the IPC channel. However, IPC Interrupts are not directly associated with the IPC channels, so any channel can use any interrupt. Any IPC channel can trigger 0, 1 or all the IPC interrupts at once, depending on the Notify or Release masks used.</p>
<p>It is also possible to set up a one-directional pipe, using a single IPC channel. In this design one processor is always the sender, and the other is always the receiver. However, there are still two endpoints.</p>
<p>A pipe supports an arbitrary number of clients with an array of callback functions, one per client. The client ID is the index number into the array for the client. After a pipe is configured and initialized, the application calls <a class="el" href="group__group__ipc__pipe__functions.html#ga2c998e0f6927eb99ac850daa4a2d5acc" title="This function registers a callback that is called when a message is received on a pipe...">Cy_IPC_Pipe_RegisterCallback()</a> once per client to register each client's callback function. Multiple clients can use the same callback function. The endpoints in a pipe share the callback array.</p>
<p>Use <a class="el" href="group__group__ipc__pipe__functions.html#ga2a3f9b25f2227abe8cf66880c1d5d5a5" title="This function is used to send a message from one endpoint to another. ">Cy_IPC_Pipe_SendMessage()</a> to send data. You specify both the "to" and "from" endpoints, and a callback function to be used when the data transfer is complete. The data is a 32-bit void pointer. The data pointed to is arbitrary, and can be an array, a structure, or a location in memory. The only limitation is that the first element of the data must be a 32-bit unsigned word containing a client ID number. The ID number is the index into the callback array.</p>
<p>When a message is sent, the receiving endpoint's interrupt handler is called. The ISR can perform any task required by the design. However, as part of its function it calls <a class="el" href="group__group__ipc__pipe__functions.html#ga57550447f7bca5f2990868bac69f41dc">Cy_IPC_Pipe_ExecCallback</a>. This function retrieves the client ID from the data and calls the associated callback function. The user-supplied callback function handles the data in whatever way is appropriate based on the application logic.</p>
<p>After the callback function is returned by the receiver, it invokes the release callback function defined by the sender of the message.</p>
<h1><a class="anchor" id="group_ipc_sema_layer"></a>
SEMA Layer</h1>
<p>A semaphore is a flag the application uses to control access to a shared resource. The SEMA-level API uses an IPC channel to implement semaphores. Startup code sets up a default semaphore system. The default system creates an array of 128 semaphores (four 32-bit values). Semaphores 0-15 are reserved for system use. See Configuration Considerations - SEMA.</p>
<p>Functions are available to initialize the semaphore system, to set or clear a semaphore, or to get the semaphore's current status. Application logic uses SEMA functions to relate a particular semaphore to a particular shared resource, and set, clear, or check the flag when accessing the shared resource.</p>
<h1><a class="anchor" id="group_ipc_configuration_cypipe"></a>
Configuration Considerations - CYPIPE</h1>
<p>There are none. The startup files set up the required CYPIPE for system use. Do not modify the CYPIPE. It uses IPC channels 5 and 6 to implement full duplex communication between cores. See System Interrupt (SysInt) for background.</p>
<p>To create your own pipe (<b>USRPIPE</b>) you should edit startup files and take 4 steps:</p><ol type="1">
<li>Define a pipe callbacks processing interrupt handler (similar to <b>Cy_SysIpcPipeIsrCm0</b> or <b>Cy_SysIpcPipeIsrCm4</b>)</li>
<li>Define a callbacks array (similar to <b>systemIpcPipeSysCbArray</b>)</li>
<li>Define your pipe configuration with a <a class="el" href="structcy__stc__ipc__pipe__config__t.html" title="The Pipe channel configuration structure. ">cy_stc_ipc_pipe_config_t</a> type structure (similar to <b>systemIpcPipeConfigCm0</b> and <b>systemIpcPipeConfigCm4</b>)</li>
<li>Call <a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c" title="Initializes the system pipes. ">Cy_IPC_Pipe_Init()</a> from each core to initialize your pipe (similar to call in the <b>SystemInit</b>)</li>
</ol>
<h1><a class="anchor" id="group_ipc_configuration_sema"></a>
Configuration Considerations - SEMA</h1>
<p>Startup code calls <a class="el" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd" title="This function initializes the semaphores subsystem. ">Cy_IPC_Sema_Init()</a> with default values to set up semaphore functionality. By default the semaphore system uses IPC channel 4, and creates 128 semaphores. Do <b>not</b> change the IPC channel. You can change the number of semaphores.</p>
<p>To change the number of semaphores, modify this line of code in system_psoc6.h.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CY_IPC_SEMA_COUNT               (uint32_t)(128u)</span></div></div><!-- fragment --><p>Startup also declares array ipcSemaArray to hold the semaphore flags based on the size defined for this symbol. Use increments of 32. You must have at least 32 semaphores. Semaphores 0-15 are reserved for system use. Your application can use semaphores greater than 15.</p>
<h1><a class="anchor" id="group_ipc_more_information"></a>
More Information</h1>
<p>If the default startup file is not used, or <a class="el" href="group__group__system__config__system__functions.html#ga93f514700ccf00d08dbdcff7f1224eb2" title="Initializes the system: ">SystemInit()</a> is not called in your project, call the following three functions prior to executing any flash or EmEEPROM write or erase operation:</p><ol type="1">
<li><a class="el" href="group__group__ipc__sema__functions.html#ga1cbc3b147c650c8716de10a1ee8423bd" title="This function initializes the semaphores subsystem. ">Cy_IPC_Sema_Init()</a></li>
<li><a class="el" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640" title="This function stores a copy of a pointer to the array of endpoints. ">Cy_IPC_Pipe_Config()</a></li>
<li><a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c" title="Initializes the system pipes. ">Cy_IPC_Pipe_Init()</a></li>
<li><a class="el" href="group__group__flash__functions.html#gaf1b44a029169a1baa08e211bff714a19" title="Initiates all needed prerequisites to support flash erase/write. ">Cy_Flash_Init()</a></li>
</ol>
<p>See the technical reference manual(TRM) for more information on the IPC.</p>
<h1><a class="anchor" id="group_ipc_MISRA"></a>
MISRA-C Compliance</h1>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th style="width: 50%;">Description of Deviation(s)  </th></tr>
<tr>
<td>10.3 </td><td>R </td><td>The value of a complex expression of integer type shall be cast only to a type of the same signedness that is no wider than the underlying type of the expression. </td><td>The cast from integer to enumeration value is used to calculate the interrupt vector source from the integer number of the IPC interrupt structure, so there is no way to avoid this cast.  </td></tr>
<tr>
<td>11.4 </td><td>A </td><td>A cast should not be performed between a pointer to the void to a pointer to the object type. </td><td>The cast from the void to pointer and vice versa is used to transmit data via the <a class="el" href="group__group__ipc.html">IPC (Inter Process Communication)</a> channel by exchanging the pointer. We exchange only one pointer, so there is no way to avoid this cast.  </td></tr>
</table>
<h1><a class="anchor" id="group_ipc_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.40.1 </td><td>Minor documentation updates. </td><td>Documentation enhancement.  </td></tr>
<tr>
<td rowspan="1">1.40 </td><td>Moved cy_semaData structure to the RAM section called ".cy_sharedmem". </td><td>Support Secure Boot devices.  </td></tr>
<tr>
<td rowspan="3">1.30 </td><td>Flattened the organization of the driver source code into the single source directory and the single include directory. </td><td>Driver library directory-structure simplification.  </td></tr>
<tr>
<td>Moved the Cy_IPC_SystemSemaInit(), Cy_IPC_SystemPipeInit() functions implementation from IPC to Startup, removed cy_ipc_config.c and cy_ipc_config.h files. </td><td>Changed IPC driver configuration method from compile time to run time.  </td></tr>
<tr>
<td>Added register access layer. Use register access macros instead of direct register access using dereferenced pointers. </td><td>Makes register access device-independent, so that the PDL does not need to be recompiled for each supported part number.  </td></tr>
<tr>
<td>1.20 </td><td>Added <a class="el" href="group__group__ipc__pipe__functions.html#ga7cff3c4286e6e23519d9925d394ac218">Cy_IPC_Pipe_ExecuteCallback</a> function. Updated documentation about user pipe initialization.  </td><td>Interface improvement, documentation update  </td></tr>
<tr>
<td>1.10.1 </td><td>Updated description of the <a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c">Cy_IPC_Pipe_Init</a>, <a class="el" href="group__group__ipc__pipe__functions.html#gad9865b8577da5a3d580bb6473f9b0912">Cy_IPC_Pipe_EndpointInit</a>, <a class="el" href="group__group__ipc__sema__functions.html#ga455867cd3b817d61d355f0407221a9a9">Cy_IPC_Sema_Set</a> functions. Added / updated code snippets.  </td><td>Documentation update and clarification  </td></tr>
<tr>
<td>1.10 </td><td>Added support for more IPC structures </td><td>New device support  </td></tr>
<tr>
<td>1.0 </td><td>Initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__ipc__drv"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__drv.html">IPC driver layer (IPC_DRV)</a></td></tr>
<tr class="memdesc:group__group__ipc__drv"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions of this layer are used in the higher IPC levels (Semaphores and Pipes). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__ipc__sema"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__sema.html">IPC semaphores layer (IPC_SEMA)</a></td></tr>
<tr class="memdesc:group__group__ipc__sema"><td class="mdescLeft">&#160;</td><td class="mdescRight">The semaphores layer functions made use of a single IPC channel to allow multiple semaphores that can be used by system or user function calls. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__ipc__pipe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe.html">IPC pipes layer (IPC_PIPE)</a></td></tr>
<tr class="memdesc:group__group__ipc__pipe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Pipe functions provide a method to transfer one or more words of data between CPUs or tasks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
