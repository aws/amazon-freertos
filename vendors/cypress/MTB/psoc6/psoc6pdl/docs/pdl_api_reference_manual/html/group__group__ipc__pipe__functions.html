<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__ipc__pipe__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__ipc.html">IPC          (Inter Process Communication)</a> &raquo; <a class="el" href="group__group__ipc__pipe.html">IPC pipes layer (IPC_PIPE)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Functions are used in the driver. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad9865b8577da5a3d580bb6473f9b0912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#gad9865b8577da5a3d580bb6473f9b0912">Cy_IPC_Pipe_EndpointInit</a> (uint32_t epAddr, cy_ipc_pipe_callback_array_ptr_t cbArray, uint32_t cbCnt, uint32_t epConfig, <a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> const *epInterrupt)</td></tr>
<tr class="memdesc:gad9865b8577da5a3d580bb6473f9b0912"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the endpoint of a pipe for the current CPU.  <a href="#gad9865b8577da5a3d580bb6473f9b0912">More...</a><br /></td></tr>
<tr class="separator:gad9865b8577da5a3d580bb6473f9b0912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a3f9b25f2227abe8cf66880c1d5d5a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ipc__pipe__enums.html#ga91750337b3471d3eb01ec316358d0598">cy_en_ipc_pipe_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#ga2a3f9b25f2227abe8cf66880c1d5d5a5">Cy_IPC_Pipe_SendMessage</a> (uint32_t toAddr, uint32_t fromAddr, void *msgPtr, cy_ipc_pipe_relcallback_ptr_t callBackPtr)</td></tr>
<tr class="memdesc:ga2a3f9b25f2227abe8cf66880c1d5d5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send a message from one endpoint to another.  <a href="#ga2a3f9b25f2227abe8cf66880c1d5d5a5">More...</a><br /></td></tr>
<tr class="separator:ga2a3f9b25f2227abe8cf66880c1d5d5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c998e0f6927eb99ac850daa4a2d5acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ipc__pipe__enums.html#ga91750337b3471d3eb01ec316358d0598">cy_en_ipc_pipe_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#ga2c998e0f6927eb99ac850daa4a2d5acc">Cy_IPC_Pipe_RegisterCallback</a> (uint32_t epAddr, cy_ipc_pipe_callback_ptr_t callBackPtr, uint32_t clientId)</td></tr>
<tr class="memdesc:ga2c998e0f6927eb99ac850daa4a2d5acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a callback that is called when a message is received on a pipe.  <a href="#ga2c998e0f6927eb99ac850daa4a2d5acc">More...</a><br /></td></tr>
<tr class="separator:ga2c998e0f6927eb99ac850daa4a2d5acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cff3c4286e6e23519d9925d394ac218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#ga7cff3c4286e6e23519d9925d394ac218">Cy_IPC_Pipe_ExecuteCallback</a> (uint32_t epAddr)</td></tr>
<tr class="memdesc:ga7cff3c4286e6e23519d9925d394ac218"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the ISR for a given pipe endpoint to dispatch the appropriate callback function based on the client ID for that endpoint.  <a href="#ga7cff3c4286e6e23519d9925d394ac218">More...</a><br /></td></tr>
<tr class="separator:ga7cff3c4286e6e23519d9925d394ac218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd8badd20f9ca44b9abc51462f734c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#gadd8badd20f9ca44b9abc51462f734c72">Cy_IPC_Pipe_RegisterCallbackRel</a> (uint32_t epAddr, cy_ipc_pipe_relcallback_ptr_t callBackPtr)</td></tr>
<tr class="memdesc:gadd8badd20f9ca44b9abc51462f734c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a default callback if a release interrupt is generated but the current release callback function is null.  <a href="#gadd8badd20f9ca44b9abc51462f734c72">More...</a><br /></td></tr>
<tr class="separator:gadd8badd20f9ca44b9abc51462f734c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1c8f1e92e74f27856ef2b7ac09c640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640">Cy_IPC_Pipe_Config</a> (<a class="el" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> *theEpArray)</td></tr>
<tr class="memdesc:ga7a1c8f1e92e74f27856ef2b7ac09c640"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stores a copy of a pointer to the array of endpoints.  <a href="#ga7a1c8f1e92e74f27856ef2b7ac09c640">More...</a><br /></td></tr>
<tr class="separator:ga7a1c8f1e92e74f27856ef2b7ac09c640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb7fa479327e6d7c282c262bc1dc6c8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c">Cy_IPC_Pipe_Init</a> (<a class="el" href="structcy__stc__ipc__pipe__config__t.html">cy_stc_ipc_pipe_config_t</a> const *config)</td></tr>
<tr class="memdesc:gafb7fa479327e6d7c282c262bc1dc6c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the system pipes.  <a href="#gafb7fa479327e6d7c282c262bc1dc6c8c">More...</a><br /></td></tr>
<tr class="separator:gafb7fa479327e6d7c282c262bc1dc6c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c9655edfb8596d5d713f8ec54417c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ipc__pipe__enums.html#ga91750337b3471d3eb01ec316358d0598">cy_en_ipc_pipe_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#ga77c9655edfb8596d5d713f8ec54417c2">Cy_IPC_Pipe_EndpointPause</a> (uint32_t epAddr)</td></tr>
<tr class="memdesc:ga77c9655edfb8596d5d713f8ec54417c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the receiver endpoint to paused state.  <a href="#ga77c9655edfb8596d5d713f8ec54417c2">More...</a><br /></td></tr>
<tr class="separator:ga77c9655edfb8596d5d713f8ec54417c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6560e9b7a9a156b79d1380e7003dab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ipc__pipe__enums.html#ga91750337b3471d3eb01ec316358d0598">cy_en_ipc_pipe_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#ga0b6560e9b7a9a156b79d1380e7003dab">Cy_IPC_Pipe_EndpointResume</a> (uint32_t epAddr)</td></tr>
<tr class="memdesc:ga0b6560e9b7a9a156b79d1380e7003dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the receiver endpoint to active state.  <a href="#ga0b6560e9b7a9a156b79d1380e7003dab">More...</a><br /></td></tr>
<tr class="separator:ga0b6560e9b7a9a156b79d1380e7003dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57550447f7bca5f2990868bac69f41dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ipc__pipe__functions.html#ga57550447f7bca5f2990868bac69f41dc">Cy_IPC_Pipe_ExecCallback</a> (<a class="el" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> *endpoint)</td></tr>
<tr class="memdesc:ga57550447f7bca5f2990868bac69f41dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the ISR for a given pipe endpoint to dispatch the appropriate callback function based on the client ID for that endpoint.  <a href="#ga57550447f7bca5f2990868bac69f41dc">More...</a><br /></td></tr>
<tr class="separator:ga57550447f7bca5f2990868bac69f41dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad9865b8577da5a3d580bb6473f9b0912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9865b8577da5a3d580bb6473f9b0912">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_EndpointInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_IPC_Pipe_EndpointInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_ipc_pipe_callback_array_ptr_t&#160;</td>
          <td class="paramname"><em>cbArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cbCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>epConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> const *&#160;</td>
          <td class="paramname"><em>epInterrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the endpoint of a pipe for the current CPU. </p>
<p>The current CPU is the CPU that is executing the code. An endpoint of a pipe is for the IPC channel that receives a message for the current CPU.</p>
<p>After this function is called, the callbackArray needs to be populated with the callback functions for that endpoint using the <a class="el" href="group__group__ipc__pipe__functions.html#ga2c998e0f6927eb99ac850daa4a2d5acc" title="This function registers a callback that is called when a message is received on a pipe...">Cy_IPC_Pipe_RegisterCallback()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>In general case, this function is called within <a class="el" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c">Cy_IPC_Pipe_Init</a>, so user doesn't need to call it anywhere. However, it may be useful in case of some pipe/endpoint customizations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epAddr</td><td>This parameter is the address (or index in the array of endpoint structures) that designates the endpoint you want to initialize.</td></tr>
    <tr><td class="paramname">cbArray</td><td>This is a pointer to the callback function array. Based on the client ID, one of the functions in this array is called to process the message.</td></tr>
    <tr><td class="paramname">cbCnt</td><td>This is the size of the callback array, or the number of defined clients.</td></tr>
    <tr><td class="paramname">epConfig</td><td>This value defines the IPC channel, IPC interrupt number, and the interrupt mask for the entire pipe. The format of the endpoint configuration Bits[31:16] Interrupt Mask Bits[15:8 ] IPC interrupt Bits[ 7:0 ] IPC channel</td></tr>
    <tr><td class="paramname">epInterrupt</td><td>This is a pointer to the endpoint interrupt description structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_CLIENT_CNT   (4UL) </span><span class="comment">/* Number of clients on each endpoint */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">cy_ipc_pipe_callback_ptr_t myIpcPipeCbArray[MY_IPC_PIPE_CLIENT_CNT];</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_CHAN_EP0     (8UL) </span><span class="comment">/* IPC data channel for MYPIPE EP0 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_CHAN_EP1     (9UL) </span><span class="comment">/* IPC data channel for MYPIPE EP1 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_INTR_EP0     (8UL) </span><span class="comment">/* Notifier EP0 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_INTR_EP1     (9UL) </span><span class="comment">/* Notifier EP1 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_INTR_MUX_EP0 (1UL) </span><span class="comment">/* CM0+ NVIC MUX for IPC */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_INTR_MASK    (uint32_t)((1UL &lt;&lt; MY_IPC_PIPE_CHAN_EP0) |\</span></div><div class="line"><span class="preprocessor">                                            (1UL &lt;&lt; MY_IPC_PIPE_CHAN_EP1))</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_EP0_CONFIG   (_VAL2FLD(CY_IPC_PIPE_CFG_IMASK, MY_IPC_PIPE_INTR_MASK) |\</span></div><div class="line"><span class="preprocessor">                                  _VAL2FLD(CY_IPC_PIPE_CFG_INTR,  MY_IPC_PIPE_INTR_EP0) |\</span></div><div class="line"><span class="preprocessor">                                  _VAL2FLD(CY_IPC_PIPE_CFG_CHAN,  MY_IPC_PIPE_CHAN_EP0))</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_EP1_CONFIG   (_VAL2FLD(CY_IPC_PIPE_CFG_IMASK, MY_IPC_PIPE_INTR_MASK) |\</span></div><div class="line"><span class="preprocessor">                                  _VAL2FLD(CY_IPC_PIPE_CFG_INTR,  MY_IPC_PIPE_INTR_EP1) |\</span></div><div class="line"><span class="preprocessor">                                  _VAL2FLD(CY_IPC_PIPE_CFG_CHAN,  MY_IPC_PIPE_CHAN_EP1))</span></div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html">cy_stc_ipc_pipe_ep_config_t</a> myIpcPipeEp0Config =</div><div class="line">{</div><div class="line">    MY_IPC_PIPE_INTR_EP0,        <span class="comment">/* .ipcNotifierNumber       */</span></div><div class="line">    1UL,                         <span class="comment">/* .ipcNotifierPriority     */</span></div><div class="line">    MY_IPC_PIPE_INTR_MUX_EP0,    <span class="comment">/* .ipcNotifierMuxNumber    */</span></div><div class="line">    MY_IPC_PIPE_EP_ADDR_CM0,     <span class="comment">/* .epAddress               */</span></div><div class="line">    MY_IPC_PIPE_EP0_CONFIG       <span class="comment">/* .epConfig                */</span></div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html">cy_stc_ipc_pipe_ep_config_t</a> myIpcPipeEp1Config =</div><div class="line">{</div><div class="line">    MY_IPC_PIPE_INTR_EP1,        <span class="comment">/* .ipcNotifierNumber       */</span></div><div class="line">    1UL,                         <span class="comment">/* .ipcNotifierPriority     */</span></div><div class="line">    0UL,                         <span class="comment">/* .ipcNotifierMuxNumber    */</span></div><div class="line">    MY_IPC_PIPE_EP_ADDR_CM4,     <span class="comment">/* .epAddress               */</span></div><div class="line">    MY_IPC_PIPE_EP1_CONFIG       <span class="comment">/* .epConfig                */</span></div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Scenario: it may be usable in case if user wants to setup theirs own</span></div><div class="line"><span class="comment">     * custom pipe.</span></div><div class="line"><span class="comment">     * Instead, in general cases user can just register custom client IDs</span></div><div class="line"><span class="comment">     * (callbacks) into the System Pipe (CYPIPE) using Cy_IPC_Pipe_RegisterCallback</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html">cy_stc_ipc_pipe_ep_config_t</a> * epReceiverConfig;</div><div class="line">    <a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html">cy_stc_ipc_pipe_ep_config_t</a> * epSenderConfig;</div><div class="line">    <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a>               epIntrConfig;</div><div class="line"></div><div class="line"><span class="preprocessor">    #if (CY_CPU_CORTEX_M0P)</span></div><div class="line">        epReceiverConfig     = &amp;myIpcPipeEp0Config;</div><div class="line">        epSenderConfig       = &amp;myIpcPipeEp1Config;</div><div class="line">        epIntrConfig.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a> = (<a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>)epReceiverConfig-&gt;<a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html#a42676bbce63ebf43f3aa42791473b6e0">ipcNotifierMuxNumber</a>;</div><div class="line">    #<span class="keywordflow">else</span></div><div class="line">        epReceiverConfig     = &amp;myIpcPipeEp1Config;</div><div class="line">        epSenderConfig       = &amp;myIpcPipeEp0Config;</div><div class="line">        epIntrConfig.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a> = (<a class="code" href="group__group__sysint__enums.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>)(cy_device-&gt;cpussIpc0Irq + epReceiverConfig-&gt;<a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html#a85b43b574d346e8711b0737fc317fa44">ipcNotifierNumber</a>);</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div><div class="line">    epIntrConfig.<a class="code" href="structcy__stc__sysint__t.html#a97b1a2acb12257a8b213a5e971ceae3d">intrPriority</a>     = epReceiverConfig-&gt;<a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html#a6c4e6bb126976ea855403085c664c973">ipcNotifierPriority</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the Receiver endpoint */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#gad9865b8577da5a3d580bb6473f9b0912">Cy_IPC_Pipe_EndpointInit</a>(epReceiverConfig-&gt;<a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html#a786ab9fcb46901b27cdb02942546fc2b">epAddress</a>,</div><div class="line">                             myIpcPipeCbArray,</div><div class="line">                             MY_IPC_PIPE_CLIENT_CNT,</div><div class="line">                             epReceiverConfig-&gt;<a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html#ab02225e6a333e91063e0a37a4f93a14c">epConfig</a>,</div><div class="line">                             &amp;epIntrConfig);</div><div class="line"></div><div class="line">    <span class="comment">/* Create the Sender endpoint just for reference */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#gad9865b8577da5a3d580bb6473f9b0912">Cy_IPC_Pipe_EndpointInit</a>(epSenderConfig-&gt;<a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html#a786ab9fcb46901b27cdb02942546fc2b">epAddress</a>, NULL, 0UL, epSenderConfig-&gt;<a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html#ab02225e6a333e91063e0a37a4f93a14c">epConfig</a>, NULL);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2a3f9b25f2227abe8cf66880c1d5d5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a3f9b25f2227abe8cf66880c1d5d5a5">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_SendMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ipc__pipe__enums.html#ga91750337b3471d3eb01ec316358d0598">cy_en_ipc_pipe_status_t</a> Cy_IPC_Pipe_SendMessage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>toAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fromAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_ipc_pipe_relcallback_ptr_t&#160;</td>
          <td class="paramname"><em>callBackPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to send a message from one endpoint to another. </p>
<p>It generates an interrupt on the endpoint that receives the message and a release interrupt to the sender to acknowledge the message has been processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toAddr</td><td>This parameter is the address (or index in the array of endpoint structures) of the endpoint to which you are sending the message.</td></tr>
    <tr><td class="paramname">fromAddr</td><td>This parameter is the address (or index in the array of endpoint structures) of the endpoint from which the message is being sent.</td></tr>
    <tr><td class="paramname">msgPtr</td><td>Pointer to the message structure to be sent.</td></tr>
    <tr><td class="paramname">callBackPtr</td><td>Pointer to the Release callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_IPC_PIPE_SUCCESS: Message was sent to the other end of the pipe CY_IPC_PIPE_ERROR_BAD_HANDLE: The handle provided for the pipe was not valid CY_IPC_PIPE_ERROR_SEND_BUSY: The pipe is already busy sending a message</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> myReleaseCallback(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* The sent data is already processed on the receiver side,</span></div><div class="line"><span class="comment">     * the pipe is ready for next transactions</span></div><div class="line"><span class="comment">     */</span></div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to send a message to the MY_IPC_CLIENT_ID client</span></div><div class="line"><span class="comment">     * on another CPU side with the user code MY_IPC_MSG_USR_CODE</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CLIENT_ID        (4UL) </span><span class="comment">/* Example client ID */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_MSG_USR_CODE     (5UL) </span><span class="comment">/* Example message user code for client #MY_IPC_CLIENT_ID */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">    #define MY_IPC_MSG_SIZE         (7UL) </span><span class="comment">/* Example message size */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    uint32_t myMsg[MY_IPC_MSG_SIZE];      <span class="comment">/* Example message */</span></div><div class="line"></div><div class="line">    myMsg[0] = _VAL2FLD(CY_IPC_PIPE_MSG_CLIENT,  MY_IPC_CLIENT_ID) |</div><div class="line">               _VAL2FLD(CY_IPC_PIPE_MSG_USR,     MY_IPC_MSG_USR_CODE) |</div><div class="line">               _VAL2FLD(CY_IPC_PIPE_MSG_RELEASE, CY_SYS_CYPIPE_INTR_MASK ); <span class="comment">/* Example message header */</span></div><div class="line">    <span class="comment">/* CY_SYS_CYPIPE_INTR_MASK is combined masks of both pipe endpoints</span></div><div class="line"><span class="comment">     * interrupt channels - to notify both sides about an event, as example.</span></div><div class="line"><span class="comment">     * The rest of the message content (as well as message size and user codes</span></div><div class="line"><span class="comment">     * in the first message&#39;s word) can be defined by user without any restrictions.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga2a3f9b25f2227abe8cf66880c1d5d5a5">Cy_IPC_Pipe_SendMessage</a>(CY_IPC_EP_CYPIPE_TO_ADDR, CY_IPC_EP_CYPIPE_FROM_ADDR, (<span class="keywordtype">void</span> *) &amp;myMsg, myReleaseCallback);</div><div class="line">    <span class="comment">/* The myReleaseCallback will be called when addressee has handled the message,</span></div><div class="line"><span class="comment">     * i.e. the correspondent notify callback is returned.</span></div><div class="line"><span class="comment">     */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2c998e0f6927eb99ac850daa4a2d5acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c998e0f6927eb99ac850daa4a2d5acc">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_RegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ipc__pipe__enums.html#ga91750337b3471d3eb01ec316358d0598">cy_en_ipc_pipe_status_t</a> Cy_IPC_Pipe_RegisterCallback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_ipc_pipe_callback_ptr_t&#160;</td>
          <td class="paramname"><em>callBackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clientId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a callback that is called when a message is received on a pipe. </p>
<p>The client_ID is the same as the index of the callback function array. The callback may be a real function pointer or NULL if no callback is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epAddr</td><td>This parameter is the address (or index in the array of endpoint structures) that designates the endpoint to which you want to add callback functions.</td></tr>
    <tr><td class="paramname">callBackPtr</td><td>Pointer to the callback function called when the endpoint has received a message. If this parameters is NULL current callback will be unregistered.</td></tr>
    <tr><td class="paramname">clientId</td><td>The index in the callback array (Client ID) where the function pointer is saved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_IPC_PIPE_SUCCESS: Callback registered successfully CY_IPC_PIPE_ERROR_BAD_CLIENT: Client ID out of range, callback not registered.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#define MY_IPC_MSG_SIZE         (7UL) </span><span class="comment">/* Example message size */</span><span class="preprocessor"></span></div><div class="line">uint32_t myMsg[MY_IPC_MSG_SIZE];      <span class="comment">/* Example message container */</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myAcquireCallback(uint32_t * msgData)</div><div class="line">{</div><div class="line">    uint32_t i;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(i = 0; i &lt; MY_IPC_MSG_SIZE; i++)</div><div class="line">    {</div><div class="line">        myMsg[i] = *((uint32_t*)((uint32_t)msgData + i)); <span class="comment">/* Copying the message content */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* The release callback will be automatically called on the sender side</span></div><div class="line"><span class="comment">     * just after returning from this callback</span></div><div class="line"><span class="comment">     */</span></div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to register an acquire notify event callback */</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_CLIENT_ID        (4UL) </span><span class="comment">/* Example client ID */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__ipc__pipe__enums.html#gga91750337b3471d3eb01ec316358d0598a81f0db1ecbe617526b177482b818d3c2">CY_IPC_PIPE_SUCCESS</a> != <a class="code" href="group__group__ipc__pipe__functions.html#ga2c998e0f6927eb99ac850daa4a2d5acc">Cy_IPC_Pipe_RegisterCallback</a>(CY_IPC_EP_CYPIPE_ADDR, myAcquireCallback, MY_IPC_CLIENT_ID))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle possible errors */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7cff3c4286e6e23519d9925d394ac218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cff3c4286e6e23519d9925d394ac218">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_ExecuteCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_IPC_Pipe_ExecuteCallback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>epAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the ISR for a given pipe endpoint to dispatch the appropriate callback function based on the client ID for that endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epAddr</td><td>This parameter is the address (or index in the array of endpoint structures) that designates the endpoint to process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used instead of obsolete <a class="el" href="group__group__ipc__pipe__functions.html#ga57550447f7bca5f2990868bac69f41dc" title="This function is called by the ISR for a given pipe endpoint to dispatch the appropriate callback fun...">Cy_IPC_Pipe_ExecCallback()</a> function because it will be removed in the next releases.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Number of endpoints of the MyPipe */</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_MAX_ENDPOINTS     (2UL)</span></div><div class="line"><span class="comment">/* Endpoint indexes in the pipe array */</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_EP_ADDR_CM0       (0UL)</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_EP_ADDR_CM4       (1UL)</span></div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> myIpcPipeEpArray[MY_IPC_PIPE_MAX_ENDPOINTS];</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Scenario: the Cy_IPC_Pipe_ExecuteCallback is intended to use in the endpoint</span></div><div class="line"><span class="comment"> * notifier interrupt handler.</span></div><div class="line"><span class="comment"> * It may be usable in case if user wants to setup their own custom pipe.</span></div><div class="line"><span class="comment"> * In general cases user can just register custom client IDs (callbacks)</span></div><div class="line"><span class="comment"> * into the System Pipe (CYPIPE) using \ref Cy_IPC_Pipe_RegisterCallback.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#if (CY_CPU_CORTEX_M0P)</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_PIPE_EP_ADDR       MY_IPC_PIPE_EP_ADDR_CM0</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">    #define MY_IPC_PIPE_EP_ADDR       MY_IPC_PIPE_EP_ADDR_CM4</span></div><div class="line"><span class="preprocessor">#endif  </span><span class="comment">/* (CY_CPU_CORTEX_M0P) */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> My_IPC_PipeIsr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga7cff3c4286e6e23519d9925d394ac218">Cy_IPC_Pipe_ExecuteCallback</a>(MY_IPC_PIPE_EP_ADDR);</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gadd8badd20f9ca44b9abc51462f734c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd8badd20f9ca44b9abc51462f734c72">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_RegisterCallbackRel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_IPC_Pipe_RegisterCallbackRel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_ipc_pipe_relcallback_ptr_t&#160;</td>
          <td class="paramname"><em>callBackPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a default callback if a release interrupt is generated but the current release callback function is null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epAddr</td><td>This parameter is the address (or index in the array of endpoint structures) that designates the endpoint to which you want to add a release callback function.</td></tr>
    <tr><td class="paramname">callBackPtr</td><td>Pointer to the callback executed when the endpoint has received a message. If this parameters is NULL current callback will be unregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> myDefaultReleaseCallback(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* The Cy_IPC_Pipe_SendMessage was called without a pointer to specific callback,</span></div><div class="line"><span class="comment">     * threfore this one is called.</span></div><div class="line"><span class="comment">     * The sent data is already processed on the receiver side,</span></div><div class="line"><span class="comment">     * the pipe is ready for next transactions</span></div><div class="line"><span class="comment">     */</span></div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to register a default release callback */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#gadd8badd20f9ca44b9abc51462f734c72">Cy_IPC_Pipe_RegisterCallbackRel</a>(CY_IPC_EP_CYPIPE_ADDR, &amp;myDefaultReleaseCallback);</div><div class="line"></div><div class="line">    uint32_t myMsg; <span class="comment">/* Some already initialised message */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga2a3f9b25f2227abe8cf66880c1d5d5a5">Cy_IPC_Pipe_SendMessage</a>(CY_IPC_EP_CYPIPE_TO_ADDR, CY_IPC_EP_CYPIPE_FROM_ADDR, (<span class="keywordtype">void</span> *) &amp;myMsg, NULL);</div><div class="line">    <span class="comment">/* Therefore the myDefaultReleaseCallback will be called</span></div><div class="line"><span class="comment">     * when addressee has handled the message,</span></div><div class="line"><span class="comment">     * i.e. the correspondent acquire callback has returned.</span></div><div class="line"><span class="comment">     */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7a1c8f1e92e74f27856ef2b7ac09c640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1c8f1e92e74f27856ef2b7ac09c640">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_Config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_IPC_Pipe_Config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> *&#160;</td>
          <td class="paramname"><em>theEpArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stores a copy of a pointer to the array of endpoints. </p>
<p>All access to endpoints will be via the index of the endpoint in this array.</p>
<dl class="section note"><dt>Note</dt><dd>In general case, this function is called in the default startup code, so user doesn't need to call it anywhere. However, it may be useful in case of some pipe customizations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theEpArray</td><td>This is the pointer to an array of endpoint structures that the designer created and will be used to reference all endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Number of endpoints of the MyPipe */</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_MAX_ENDPOINTS     (2UL)</span></div><div class="line"><span class="comment">/* Endpoint indexes in the pipe array */</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_EP_ADDR_CM0       (0UL)</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_EP_ADDR_CM4       (1UL)</span></div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> myIpcPipeEpArray[MY_IPC_PIPE_MAX_ENDPOINTS];</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Scenario: there is a need to register the endpoint array prior to</span></div><div class="line"><span class="comment">     * pipe/endpoints initializing.</span></div><div class="line"><span class="comment">     * It may be usable in case if user wants to setup theirs own custom pipe.</span></div><div class="line"><span class="comment">     * Instead, in general cases user can just register custom client IDs</span></div><div class="line"><span class="comment">     * (callbacks) into the System Pipe (CYPIPE) using Cy_IPC_Pipe_RegisterCallback</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga7a1c8f1e92e74f27856ef2b7ac09c640">Cy_IPC_Pipe_Config</a>(myIpcPipeEpArray);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gafb7fa479327e6d7c282c262bc1dc6c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb7fa479327e6d7c282c262bc1dc6c8c">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_IPC_Pipe_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__ipc__pipe__config__t.html">cy_stc_ipc_pipe_config_t</a> const *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the system pipes. </p>
<p>The system pipes are used by BLE. </p><dl class="section note"><dt>Note</dt><dd>The function should be called on all CPUs.</dd>
<dd>
In general case, this function is called in the default startup code, so user doesn't need to call it anywhere. However, it may be useful in case of some pipe customizations.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>This is the pointer to the pipe configuration structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_CLIENT_CNT   (4UL) </span><span class="comment">/* Number of clients on each endpoint */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">cy_ipc_pipe_callback_ptr_t myIpcPipeCbArray[MY_IPC_PIPE_CLIENT_CNT];</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_CHAN_EP0     (8UL) </span><span class="comment">/* IPC data channel for MYPIPE EP0 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_CHAN_EP1     (9UL) </span><span class="comment">/* IPC data channel for MYPIPE EP1 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_INTR_EP0     (8UL) </span><span class="comment">/* Notifier EP0 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_INTR_EP1     (9UL) </span><span class="comment">/* Notifier EP1 */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_INTR_MUX_EP0 (1UL) </span><span class="comment">/* CM0+ NVIC MUX for IPC */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_INTR_MASK    (uint32_t)((1UL &lt;&lt; MY_IPC_PIPE_CHAN_EP0) |\</span></div><div class="line"><span class="preprocessor">                                            (1UL &lt;&lt; MY_IPC_PIPE_CHAN_EP1))</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_EP0_CONFIG   (_VAL2FLD(CY_IPC_PIPE_CFG_IMASK, MY_IPC_PIPE_INTR_MASK) |\</span></div><div class="line"><span class="preprocessor">                                  _VAL2FLD(CY_IPC_PIPE_CFG_INTR,  MY_IPC_PIPE_INTR_EP0) |\</span></div><div class="line"><span class="preprocessor">                                  _VAL2FLD(CY_IPC_PIPE_CFG_CHAN,  MY_IPC_PIPE_CHAN_EP0))</span></div><div class="line"><span class="preprocessor">#define MY_IPC_PIPE_EP1_CONFIG   (_VAL2FLD(CY_IPC_PIPE_CFG_IMASK, MY_IPC_PIPE_INTR_MASK) |\</span></div><div class="line"><span class="preprocessor">                                  _VAL2FLD(CY_IPC_PIPE_CFG_INTR,  MY_IPC_PIPE_INTR_EP1) |\</span></div><div class="line"><span class="preprocessor">                                  _VAL2FLD(CY_IPC_PIPE_CFG_CHAN,  MY_IPC_PIPE_CHAN_EP1))</span></div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html">cy_stc_ipc_pipe_ep_config_t</a> myIpcPipeEp0Config =</div><div class="line">{</div><div class="line">    MY_IPC_PIPE_INTR_EP0,        <span class="comment">/* .ipcNotifierNumber       */</span></div><div class="line">    1UL,                         <span class="comment">/* .ipcNotifierPriority     */</span></div><div class="line">    MY_IPC_PIPE_INTR_MUX_EP0,    <span class="comment">/* .ipcNotifierMuxNumber    */</span></div><div class="line">    MY_IPC_PIPE_EP_ADDR_CM0,     <span class="comment">/* .epAddress               */</span></div><div class="line">    MY_IPC_PIPE_EP0_CONFIG       <span class="comment">/* .epConfig                */</span></div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__ipc__pipe__ep__config__t.html">cy_stc_ipc_pipe_ep_config_t</a> myIpcPipeEp1Config =</div><div class="line">{</div><div class="line">    MY_IPC_PIPE_INTR_EP1,        <span class="comment">/* .ipcNotifierNumber       */</span></div><div class="line">    1UL,                         <span class="comment">/* .ipcNotifierPriority     */</span></div><div class="line">    0UL,                         <span class="comment">/* .ipcNotifierMuxNumber    */</span></div><div class="line">    MY_IPC_PIPE_EP_ADDR_CM4,     <span class="comment">/* .epAddress               */</span></div><div class="line">    MY_IPC_PIPE_EP1_CONFIG       <span class="comment">/* .epConfig                */</span></div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Scenario: it may be usable in case if user wants to setup theirs own</span></div><div class="line"><span class="comment">     * custom pipe.</span></div><div class="line"><span class="comment">     * Instead, in general cases user can just register custom client IDs</span></div><div class="line"><span class="comment">     * (callbacks) into the System Pipe (CYPIPE) using Cy_IPC_Pipe_RegisterCallback</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="structcy__stc__ipc__pipe__config__t.html">cy_stc_ipc_pipe_config_t</a> myIpcPipeConfig =</div><div class="line">    {</div><div class="line">        myIpcPipeEp0Config,         <span class="comment">/* CM0+ endpoint configuration structure */</span></div><div class="line">        myIpcPipeEp1Config,         <span class="comment">/* CM4  endpoint configuration structure */</span></div><div class="line">        MY_IPC_PIPE_CLIENT_CNT,     <span class="comment">/* .endpointClientsCount    */</span></div><div class="line">        myIpcPipeCbArray,           <span class="comment">/* .endpointsCallbacksArray */</span></div><div class="line">        &amp;My_IPC_PipeIsr             <span class="comment">/* .userPipeIsrHandler      */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#gafb7fa479327e6d7c282c262bc1dc6c8c">Cy_IPC_Pipe_Init</a>(&amp;myIpcPipeConfig);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga77c9655edfb8596d5d713f8ec54417c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c9655edfb8596d5d713f8ec54417c2">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_EndpointPause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ipc__pipe__enums.html#ga91750337b3471d3eb01ec316358d0598">cy_en_ipc_pipe_status_t</a> Cy_IPC_Pipe_EndpointPause </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>epAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the receiver endpoint to paused state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epAddr</td><td>This parameter is the address (or index in the array of endpoint structures) that designates the endpoint to pause.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_IPC_PIPE_SUCCESS: Callback registered successfully</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: the CPU needs to perform some critical operation</span></div><div class="line"><span class="comment">     * that cannot be disturbed. So there is a need to put the endpoint into</span></div><div class="line"><span class="comment">     * paused state while the operation is being performed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga77c9655edfb8596d5d713f8ec54417c2">Cy_IPC_Pipe_EndpointPause</a>(CY_IPC_EP_CYPIPE_ADDR);</div><div class="line"></div><div class="line">    <span class="comment">/* Perform the critical operation */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Resume endpoint, return to normal pipe operation */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga0b6560e9b7a9a156b79d1380e7003dab">Cy_IPC_Pipe_EndpointResume</a>(CY_IPC_EP_CYPIPE_ADDR);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga0b6560e9b7a9a156b79d1380e7003dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6560e9b7a9a156b79d1380e7003dab">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_EndpointResume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ipc__pipe__enums.html#ga91750337b3471d3eb01ec316358d0598">cy_en_ipc_pipe_status_t</a> Cy_IPC_Pipe_EndpointResume </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>epAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the receiver endpoint to active state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epAddr</td><td>This parameter is the address (or index in the array of endpoint structures) that designates the endpoint to resume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_IPC_PIPE_SUCCESS: Callback registered successfully</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: the CPU needs to perform some critical operation</span></div><div class="line"><span class="comment">     * that cannot be disturbed. So there is a need to put the endpoint into</span></div><div class="line"><span class="comment">     * paused state while the operation is being performed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga77c9655edfb8596d5d713f8ec54417c2">Cy_IPC_Pipe_EndpointPause</a>(CY_IPC_EP_CYPIPE_ADDR);</div><div class="line"></div><div class="line">    <span class="comment">/* Perform the critical operation */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Resume endpoint, return to normal pipe operation */</span></div><div class="line">    <a class="code" href="group__group__ipc__pipe__functions.html#ga0b6560e9b7a9a156b79d1380e7003dab">Cy_IPC_Pipe_EndpointResume</a>(CY_IPC_EP_CYPIPE_ADDR);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga57550447f7bca5f2990868bac69f41dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57550447f7bca5f2990868bac69f41dc">&#9670;&nbsp;</a></span>Cy_IPC_Pipe_ExecCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_IPC_Pipe_ExecCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__ipc__pipe__ep__t.html">cy_stc_ipc_pipe_ep_t</a> *&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the ISR for a given pipe endpoint to dispatch the appropriate callback function based on the client ID for that endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Pointer to endpoint structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is obsolete and will be removed in the next releases. Please use <a class="el" href="group__group__ipc__pipe__functions.html#ga7cff3c4286e6e23519d9925d394ac218" title="This function is called by the ISR for a given pipe endpoint to dispatch the appropriate callback fun...">Cy_IPC_Pipe_ExecuteCallback()</a> instead. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
