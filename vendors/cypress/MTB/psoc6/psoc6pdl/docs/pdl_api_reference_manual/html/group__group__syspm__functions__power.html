<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Power Modes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__syspm__functions__power.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Power Modes<div class="ingroups"><a class="el" href="group__group__syspm.html">SysPm        (System Power Management)</a> &raquo; <a class="el" href="group__group__syspm__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab09936e85606de476a0c379f9548603f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#gab09936e85606de476a0c379f9548603f">Cy_SysPm_CpuEnterSleep</a> (<a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a> waitFor)</td></tr>
<tr class="memdesc:gab09936e85606de476a0c379f9548603f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets executing CPU to Sleep mode.  <a href="#gab09936e85606de476a0c379f9548603f">More...</a><br /></td></tr>
<tr class="separator:gab09936e85606de476a0c379f9548603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5150c28fe4d2626720c1fbf74b3111ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca">Cy_SysPm_CpuEnterDeepSleep</a> (<a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a> waitFor)</td></tr>
<tr class="memdesc:ga5150c28fe4d2626720c1fbf74b3111ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets executing CPU to the Deep Sleep mode.  <a href="#ga5150c28fe4d2626720c1fbf74b3111ca">More...</a><br /></td></tr>
<tr class="separator:ga5150c28fe4d2626720c1fbf74b3111ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72531fcca015df727a163b510639a334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga72531fcca015df727a163b510639a334">Cy_SysPm_SystemEnterLp</a> (void)</td></tr>
<tr class="memdesc:ga72531fcca015df727a163b510639a334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device into system Low Power mode.  <a href="#ga72531fcca015df727a163b510639a334">More...</a><br /></td></tr>
<tr class="separator:ga72531fcca015df727a163b510639a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7c8f1ab6d555530a68978269198836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#gaca7c8f1ab6d555530a68978269198836">Cy_SysPm_SystemEnterUlp</a> (void)</td></tr>
<tr class="memdesc:gaca7c8f1ab6d555530a68978269198836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets device into system Ultra Low Power mode.  <a href="#gaca7c8f1ab6d555530a68978269198836">More...</a><br /></td></tr>
<tr class="separator:gaca7c8f1ab6d555530a68978269198836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae97647a28c370674ba57d451d21d1c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#gae97647a28c370674ba57d451d21d1c51">Cy_SysPm_SystemEnterHibernate</a> (void)</td></tr>
<tr class="memdesc:gae97647a28c370674ba57d451d21d1c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the device into system Hibernate mode.  <a href="#gae97647a28c370674ba57d451d21d1c51">More...</a><br /></td></tr>
<tr class="separator:gae97647a28c370674ba57d451d21d1c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2540970e6c27efa25752efc43da0d622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga2540970e6c27efa25752efc43da0d622">Cy_SysPm_SetHibernateWakeupSource</a> (uint32_t wakeupSource)</td></tr>
<tr class="memdesc:ga2540970e6c27efa25752efc43da0d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures sources to wake up the device from the system Hibernate power mode.  <a href="#ga2540970e6c27efa25752efc43da0d622">More...</a><br /></td></tr>
<tr class="separator:ga2540970e6c27efa25752efc43da0d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb3a837b9c441f4806c7550e6a0b026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga5cb3a837b9c441f4806c7550e6a0b026">Cy_SysPm_ClearHibernateWakeupSource</a> (uint32_t wakeupSource)</td></tr>
<tr class="memdesc:ga5cb3a837b9c441f4806c7550e6a0b026"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables a wakeup source that was previously configured to wake up the device from the system Hibernate mode.  <a href="#ga5cb3a837b9c441f4806c7550e6a0b026">More...</a><br /></td></tr>
<tr class="separator:ga5cb3a837b9c441f4806c7550e6a0b026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bde7056544d0ada3da80a0f58fefab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga3bde7056544d0ada3da80a0f58fefab9">Cy_SysPm_SystemSetMinRegulatorCurrent</a> (void)</td></tr>
<tr class="memdesc:ga3bde7056544d0ada3da80a0f58fefab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the system into minimum core regulator current mode.  <a href="#ga3bde7056544d0ada3da80a0f58fefab9">More...</a><br /></td></tr>
<tr class="separator:ga3bde7056544d0ada3da80a0f58fefab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54112d6ea4d40ad241923ee7068f5363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga54112d6ea4d40ad241923ee7068f5363">Cy_SysPm_SystemSetNormalRegulatorCurrent</a> (void)</td></tr>
<tr class="memdesc:ga54112d6ea4d40ad241923ee7068f5363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the system to normal regulator current mode.  <a href="#ga54112d6ea4d40ad241923ee7068f5363">More...</a><br /></td></tr>
<tr class="separator:ga54112d6ea4d40ad241923ee7068f5363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5d2956621c6ba87c0d968ed497b970"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#gadf5d2956621c6ba87c0d968ed497b970">Cy_SysPm_SystemIsMinRegulatorCurrentSet</a> (void)</td></tr>
<tr class="memdesc:gadf5d2956621c6ba87c0d968ed497b970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the system regulator is set to minimal current mode.  <a href="#gadf5d2956621c6ba87c0d968ed497b970">More...</a><br /></td></tr>
<tr class="separator:gadf5d2956621c6ba87c0d968ed497b970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c50f7236c3a6a7b75a7d915f8ebb089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga7c50f7236c3a6a7b75a7d915f8ebb089">Cy_SysPm_CpuSleepOnExit</a> (bool enable)</td></tr>
<tr class="memdesc:ga7c50f7236c3a6a7b75a7d915f8ebb089"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the sleep-on-exit feature of the CPU.  <a href="#ga7c50f7236c3a6a7b75a7d915f8ebb089">More...</a><br /></td></tr>
<tr class="separator:ga7c50f7236c3a6a7b75a7d915f8ebb089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177941ebfd3c4e3f6e391d303c407534"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__syspm__functions__power.html#ga177941ebfd3c4e3f6e391d303c407534">Cy_SysPm_CpuSendWakeupEvent</a> (void)</td></tr>
<tr class="memdesc:ga177941ebfd3c4e3f6e391d303c407534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the SEV (Send Event) ARM instruction to the system.  <a href="#ga177941ebfd3c4e3f6e391d303c407534">More...</a><br /></td></tr>
<tr class="separator:ga177941ebfd3c4e3f6e391d303c407534"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab09936e85606de476a0c379f9548603f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab09936e85606de476a0c379f9548603f">&#9670;&nbsp;</a></span>Cy_SysPm_CpuEnterSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_CpuEnterSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a>&#160;</td>
          <td class="paramname"><em>waitFor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets executing CPU to Sleep mode. </p>
<p>Puts the CPU executing this function into CPU Sleep power mode. If callback functions were registered they are also executed.</p>
<p>For more detail about switching into CPU Sleep power mode and debug, refer to the device technical reference manual (TRM).</p>
<p>If at least one callback function with the CY_SYSPM_SLEEP type was registered, the following algorithm is executed: Prior to entering CPU Sleep mode, all callback functions of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter are called. This allows the driver to signal whether it is ready to enter the low power mode. If any of the callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter returns CY_SYSPM_FAIL, the remaining callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter are skipped. After the first CY_SYSPM_FAIL, all the CY_SYSPM_SLEEP callbacks that were previously executed before getting the CY_SYSPM_CHECK_FAIL are executed with the CY_SYSPM_CHECK_FAIL parameter. The CPU Sleep mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#gab09936e85606de476a0c379f9548603f" title="Sets executing CPU to Sleep mode. ">Cy_SysPm_CpuEnterSleep()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all of the callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_READY parameter return CY_SYSPM_SUCCESS, then all callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_CHECK_FAIL parameters calls are skipped. All callbacks of the CY_SYSPM_SLEEP type and then CY_SYSPM_BEFORE_TRANSITION parameter calls are executed, allowing the peripherals to prepare for CPU Sleep. The CPU then enters Sleep mode. This is a CPU-centric power mode. This means that the CPU has entered Sleep mode and its main clock is removed. Any enabled interrupt can cause a CPU wakeup from Sleep mode.</p>
<p>For multi-core devices, CPU wakeup can also be performed using the Send Event (SEV) assembly instruction executed from the other active CPU. Such wakeup is expected only if the CPU Sleep power mode is done with WFE assembly instruction.</p>
<p>After a wakeup from CPU Sleep, all of the registered callbacks of the CY_SYSPM_SLEEP type and with the CY_SYSPM_AFTER_TRANSITION parameter are executed to return the peripherals to CPU active operation. The <a class="el" href="group__group__syspm__functions__power.html#gab09936e85606de476a0c379f9548603f" title="Sets executing CPU to Sleep mode. ">Cy_SysPm_CpuEnterSleep()</a> function returns CY_SYSPM_SUCCESS. No callbacks of the CY_SYSPM_SLEEP type with the CY_SYSPM_BEFORE_TRANSITION parameter or callbacks of the CY_SYSPM_SLEEP type and CY_SYSPM_AFTER_TRANSITION parameter callbacks are executed if CPU Sleep mode is not entered.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returns CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL. The callback generating CY_SYSPM_FAIL is expected to not make any changes that require being undone.</dd></dl>
<p>To support control of callback execution order th following method is implemented. Callback function with the CY_SYSPM_CHECK_READY and CY_SYSPM_BEFORE_TRANSITION parameter are executed in the same order they are registered. Callback function with the CY_SYSPM_CHECK_FAIL and CY_SYSPM_AFTER_TRANSITION parameter are executed in the reverse order they are registered.</p>
<p>The return value from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<p><a class="el" href="group__group__syspm__data__enumerates.html#gae06cd8869fe61d709ad6145ca9f3cd63">cy_en_syspm_callback_mode_t</a>, except the CY_SYSPM_CHECK_READY, are ignored</p>
<dl class="section note"><dt>Note</dt><dd>The Arm BSD assembly instruction is not required in this function because the function implementation ensures the SLEEPDEEP bit of SCS register is settled prior executing WFI/WFE instruction.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitFor</td><td>Selects wait for action. See <a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Entered status, see <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>.</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>For CY8C6xx6, CY8C6xx7 devices this function clears the Event Register of the CM4 CPU after wakeup from WFE.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to put the CPU into Sleep mode */</span></div><div class="line">    <span class="comment">/* Prepare the system for CPU Sleep power mode here */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#gab09936e85606de476a0c379f9548603f">Cy_SysPm_CpuEnterSleep</a>(<a class="code" href="group__group__syspm__data__enumerates.html#ggaae6a9f528630a2d69bb70b3bced1f0acadf47e50b6700c08b6f9e7e70bb525541">CY_SYSPM_WAIT_FOR_INTERRUPT</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* The CPU Sleep mode was not entered because a registered </span></div><div class="line"><span class="comment">        *  Sleep &quot;check ready&quot; callback returned a &quot;not success&quot; status</span></div><div class="line"><span class="comment">        */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* If the program has reached here, the CPU has just woken up</span></div><div class="line"><span class="comment">         * from the CPU Sleep mode</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga5150c28fe4d2626720c1fbf74b3111ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5150c28fe4d2626720c1fbf74b3111ca">&#9670;&nbsp;</a></span>Cy_SysPm_CpuEnterDeepSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_CpuEnterDeepSleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a>&#160;</td>
          <td class="paramname"><em>waitFor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets executing CPU to the Deep Sleep mode. </p>
<p>Puts the CPU executing the function into CPU Deep Sleep. For a single CPU devices the device will immediately transition to system Deep Sleep. For a dual CPU devices the device will transition to system Deep Sleep only after both CPUs are in CPU Deep Sleep power mode.</p>
<p>Prior to entering the CPU Deep Sleep mode, all callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_READY parameter registered callbacks are called, allowing the driver to signal whether it is ready to enter the power mode. If any CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_READY parameter call returns CY_SYSPM_FAIL, the remaining callback CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_READY parameter are skipped. After the first CY_SYSPM_FAIL, all the CY_SYSPM_DEEPSLEEP callbacks that were previously executed before getting the CY_SYSPM_CHECK_FAIL are executed with the CY_SYSPM_CHECK_FAIL parameter. The CPU Deep Sleep mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca" title="Sets executing CPU to the Deep Sleep mode. ">Cy_SysPm_CpuEnterDeepSleep()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_READY parameter return CY_SYSPM_SUCCESS, then all callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_CHECK_FAIL parameter calls are skipped. All callbacks of the CY_SYSPM_DEEPSLEEP type with the CY_SYSPM_BEFORE_TRANSITION parameter calls are then executed, allowing the peripherals to prepare for CPU Deep Sleep. The Deep Sleep mode is then entered. Any enabled interrupt can cause a wakeup from the Deep Sleep mode.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returns CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL. The callback generating CY_SYSPM_FAIL is expected to not make any changes that require being undone.</dd></dl>
<p>For multi-CPU devices (except CY8C6xx6 and CY8C6xx7) there is a possible situation when a syscall operation (for example during flash read or write) is executing. If the CM0+ CPU tries to enter Deep Sleep, it will fail. All the CY_SYSPM_DEEPSLEEP callbacks that were previously executed, are executed with the CY_SYSPM_CHECK_FAIL parameter. Deep Sleep mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca" title="Sets executing CPU to the Deep Sleep mode. ">Cy_SysPm_CpuEnterDeepSleep()</a> function returns CY_SYSPM_SYSCALL_PENDING.</p>
<p>The return value from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<p>If the firmware attempts to enter this mode before the system is ready (that is, when PWR_CONTROL.LPM_READY = 0), then the CPU(s) will go into the CPU Sleep mode instead and automatically enter system Deep Sleep mode when the system is ready. On dual CPU devices, if one CPU enters CPU Deep Sleep and the other CPU remains active or is in CPU Sleep the first CPU will remain in CPU Deep Sleep. A CPU Deep Sleep is functionally identical to CPU Sleep.</p>
<p>The device enters system Deep Sleep mode when all the CPU(s) are in CPU Deep Sleep, there are no busy peripherals, the debugger is not active, and the Deep Sleep power and reference are ready (PWR_CONTROL.LPM_READY=1).</p>
<p>The peripherals that do not need a clock or that receive a clock from their external interface (e.g. I2C/SPI) may continue operating in system Deep Sleep. All circuits using current from Vccdpslp supply are limited by its maximum current specification of the Deep Sleep regulator.</p>
<p>Wakeup occurs when an interrupt asserts from a Deep Sleep active peripheral. For more detail, see the corresponding peripheral's datasheet.</p>
<p>For multi-core devices, CPU wakeup can also be performed using the Send Event (SEV) assembly instruction executed from the other active CPU. Such wakeup is expected only if the CPU Sleep power mode is done with WFE assembly instruction.</p>
<dl class="section note"><dt>Note</dt><dd>For multi-CPU devices, the second CPU, if it did not participate in system wakeup, remains in CPU Deep Sleep mode. Any Deep Sleep capable interrupt routed to this CPU can also wake it.</dd></dl>
<p>For more detail about switching into the system Deep Sleep power mode and debug, refer to the device TRM.</p>
<p>A normal wakeup from the Deep Sleep power mode returns to either ULP or LP mode, depending on the previous state and programmed behavior for the particular wakeup interrupt. As soon as the system resumes LP or ULP mode the CPU(s) return to CPU Active or CPU Deep Sleep mode, depending on their configured wakeup settings.</p>
<p>After wakeup from CPU Deep Sleep, all of the registered callbacks with CY_SYSPM_DEEPSLEEP type with CY_SYSPM_AFTER_TRANSITION are executed to return peripherals to active operation. The <a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca" title="Sets executing CPU to the Deep Sleep mode. ">Cy_SysPm_CpuEnterDeepSleep()</a> function returns CY_SYSPM_SUCCESS. No callbacks are executed with CY_SYSPM_DEEPSLEEP type with CY_SYSPM_BEFORE_TRANSITION or CY_SYSPM_AFTER_TRANSITION parameter, if Deep Sleep mode was not entered.</p>
<p>To support control of callback execution order th following method is implemented. Callback function with the CY_SYSPM_CHECK_READY and CY_SYSPM_BEFORE_TRANSITION parameter are executed in the same order they are registered. Callback function with the CY_SYSPM_CHECK_FAIL and CY_SYSPM_AFTER_TRANSITION parameter are executed in the reverse order they are registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitFor</td><td>Selects wait for action. See <a class="el" href="group__group__syspm__data__enumerates.html#gaae6a9f528630a2d69bb70b3bced1f0ac">cy_en_syspm_waitfor_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Side Effects</dt><dd>For CY8C6xx6, CY8C6xx7 devices this function clears the Event Register of the CM4 CPU after wakeup from WFE.</dd></dl>
<dl class="section user"><dt>Side Effects</dt><dd>This function changes the slow and fast clock dividers right before entering into system Deep Sleep and restores these dividers after wakeup.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Entered status, see <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>. For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The FLL/PLL are not restored right before the CPU(s) start executing the instructions after system Deep Sleep. This can affect the peripheral that is driven by PLL/FLL. Ensure that the PLL/FLL are properly restored (locked) after wakeup from System Deep Sleep. Refer to the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver documentation for information about how to read the PLL/FLL lock statuses.</dd>
<dd>
The Arm BSD assembly instruction is not required in this function because the function implementation ensures the SLEEPDEEP bit of SCS register is settled prior executing the WFI/WFE instruction.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to put the CPU into Deep Sleep mode */</span></div><div class="line">    <span class="comment">/* Prepare the system for Deep Sleep power mode here */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca">Cy_SysPm_CpuEnterDeepSleep</a>(<a class="code" href="group__group__syspm__data__enumerates.html#ggaae6a9f528630a2d69bb70b3bced1f0acadf47e50b6700c08b6f9e7e70bb525541">CY_SYSPM_WAIT_FOR_INTERRUPT</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* CPU did not enter Deep Sleep mode because a registered </span></div><div class="line"><span class="comment">        *  CPU Deep Sleep &quot;check ready&quot; callback returned a &quot;not success&quot; status</span></div><div class="line"><span class="comment">        */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* If the program has reached here, the core is just woken up</span></div><div class="line"><span class="comment">         * from the CPU Deep Sleep mode</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga72531fcca015df727a163b510639a334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72531fcca015df727a163b510639a334">&#9670;&nbsp;</a></span>Cy_SysPm_SystemEnterLp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_SystemEnterLp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device into system Low Power mode. </p>
<p>Returns the system to the default LP mode by raising the core voltage. In the LP mode, the clock frequencies can be increased to t he LP mode limitations. Refer to the device datasheet for frequency limitations in the LP mode. Approximate LP limit values - <a class="el" href="group__group__syspm.html#group_syspm_lp_limitations">LP Limitations</a>.</p>
<p>Prior to entering the system LP mode, all the registered CY_SYSPM_LP callbacks with CY_SYSPM_CHECK_READY parameter are called. This allows the driver to signal that it is not ready to enter the system LP mode. If any CY_SYSPM_LP callbacks with the CY_SYSPM_CHECK_READY parameter call return CY_SYSPM_FAIL, the remaining CY_SYSPM_LP callbacks with the CY_SYSPM_CHECK_READY parameter calls are skipped.</p>
<p>After a CY_SYSPM_FAIL, all of the CY_SYSPM_LP callbacks with CY_SYSPM_CHECK_FAIL parameter are executed that correspond to the CY_SYSPM_LP callbacks with CY_SYSPM_CHECK_READY parameter that occurred up to the point of failure. System LP mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#ga72531fcca015df727a163b510639a334" title="Sets device into system Low Power mode. ">Cy_SysPm_SystemEnterLp()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all CY_SYSPM_LP callbacks with the CY_SYSPM_CHECK_READY parameter return CY_SYSPM_SUCCESS, then all CY_SYSPM_LP callbacks with CY_SYSPM_CHECK_FAIL are skipped and all CY_SYSPM_LP callbacks with the CY_SYSPM_BEFORE_TRANSITION parameter are executed. This allows the peripherals to prepare for LP mode. The system LP mode is then entered.</p>
<p>After entering the system LP mode, all of the registered CY_SYSPM_LP callbacks with the CY_SYSPM_AFTER_TRANSITION parameter are executed to complete preparing the peripherals for low power operation. The <a class="el" href="group__group__syspm__functions__power.html#ga72531fcca015df727a163b510639a334" title="Sets device into system Low Power mode. ">Cy_SysPm_SystemEnterLp()</a> function returns CY_SYSPM_SUCCESS. No CY_SYSPM_LP callbacks with the CY_SYSPM_BEFORE_TRANSITION or CY_SYSPM_AFTER_TRANSITION parameter are executed if the system LP mode is not entered.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returns CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL. The callback generating CY_SYSPM_FAIL is expected to not make any changes that require being undone.</dd></dl>
<p>The return value from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<p>To support control of callback execution order th following method is implemented. Callback function with the CY_SYSPM_CHECK_READY and CY_SYSPM_BEFORE_TRANSITION parameter are executed in the same order they are registered. Callback function with the CY_SYSPM_CHECK_FAIL and CY_SYSPM_AFTER_TRANSITION parameter are executed in the reverse order they are registered.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CY_SYSPM_SUCCESS - Entered the system LP mode or the device is already in LP mode.</li>
<li>CY_SYSPM_INVALID_STATE - The system LP mode was not set. The system LP mode was not set because the protection context value is higher than zero (PC &gt; 0) or the device revision does not support modifying registers (to enter LP mode) via syscall.</li>
<li>CY_SYSPM_CANCELED - Operation was canceled. Call the function again until the function returns CY_SYSPM_SUCCESS.</li>
<li>CY_SYSPM_FAIL - The system LP mode is not entered. For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to put the device to the system LP mode */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#ga72531fcca015df727a163b510639a334">Cy_SysPm_SystemEnterLp</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* System did not enter LP mode because a registered </span></div><div class="line"><span class="comment">        *  LP mode &quot;check ready&quot; callback returned a &quot;not success&quot; status </span></div><div class="line"><span class="comment">        */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Reconfigure/switch on the peripherals </span></div><div class="line"><span class="comment">    * with relaxed power consumption restrictions</span></div><div class="line"><span class="comment">    */</span></div><div class="line">     </div><div class="line">    <span class="comment">/* Call Cy_SysLib_SetWaitStates(true, clkMHz);</span></div><div class="line"><span class="comment">    * where clkMHz is the current CPU frequency in MHz</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaca7c8f1ab6d555530a68978269198836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca7c8f1ab6d555530a68978269198836">&#9670;&nbsp;</a></span>Cy_SysPm_SystemEnterUlp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_SystemEnterUlp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets device into system Ultra Low Power mode. </p>
<p>System ULP mode is similar to system LP mode. The difference is that the system is put under <a class="el" href="group__group__syspm.html#group_syspm_ulp_limitations">ULP Limitations</a>.</p>
<p>Before entering system ULP mode, the user must configure the system so the maximum clock frequencies are less than the ULP mode specifications presented in the device datasheet. Refer to the device datasheet for the maximum clock limitations in the ULP mode with reduced core supply regulator voltages.</p>
<p>Prior to entering system ULP mode, all the registered CY_SYSPM_ULP callbacks with CY_SYSPM_CHECK_READY parameter are called. This allows the driver to signal if it is not ready to enter system ULP mode. If any CY_SYSPM_ULP callback with the CY_SYSPM_CHECK_READY parameter call returns CY_SYSPM_FAIL, the remaining CY_SYSPM_ULP callbacks with the CY_SYSPM_CHECK_READY parameter are skipped.</p>
<p>After a CY_SYSPM_FAIL, all of the CY_SYSPM_ULP callbacks with the CY_SYSPM_CHECK_FAIL parameter are executed that correspond to the CY_SYSPM_ULP callback with CY_SYSPM_CHECK_READY parameter that occurred up to the point of failure. System ULP mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#gaca7c8f1ab6d555530a68978269198836" title="Sets device into system Ultra Low Power mode. ">Cy_SysPm_SystemEnterUlp()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all CY_SYSPM_ULP callbacks with the CY_SYSPM_CHECK_READY parameter return CY_SYSPM_SUCCESS, then all CY_SYSPM_ULP callbacks with CY_SYSPM_CHECK_FAIL calls are skipped and all CY_SYSPM_ULP callbacks with the CY_SYSPM_BEFORE_TRANSITION parameter are executed. This allows preparation for ULP. The system ULP mode is then entered.</p>
<p>After entering system ULP, all of the registered CY_SYSPM_ULP callbacks with the CY_SYSPM_AFTER_TRANSITION parameter are executed to complete preparing the peripherals for ULP operation. The <a class="el" href="group__group__syspm__functions__power.html#gaca7c8f1ab6d555530a68978269198836" title="Sets device into system Ultra Low Power mode. ">Cy_SysPm_SystemEnterUlp()</a> function returns CY_SYSPM_SUCCESS. No CY_SYSPM_ULP callbacks with the CY_SYSPM_BEFORE_TRANSITION or CY_SYSPM_AFTER_TRANSITION parameter are executed, if ULP mode is not entered.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returns CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL. The callback generating CY_SYSPM_FAIL is expected to not make any changes that require being undone.</dd></dl>
<p>The return value from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<p>To support control of callback execution order th following method is implemented. Callback function with the CY_SYSPM_CHECK_READY and CY_SYSPM_BEFORE_TRANSITION parameter are executed in the same order they are registered. Callback function with the CY_SYSPM_CHECK_FAIL and CY_SYSPM_AFTER_TRANSITION parameter are executed in the reverse order they are registered.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CY_SYSPM_SUCCESS - Entered the system ULP mode or the device is already in ULP mode.</li>
<li>CY_SYSPM_INVALID_STATE - System ULP mode was not set. The ULP mode was not set because the protection context value is higher than zero (PC &gt; 0) or the device revision does not support modifying registers (to enter system ULP mode) via syscall.</li>
<li>CY_SYSPM_CANCELED - Operation was canceled. Call the function again until the function returns CY_SYSPM_SUCCESS.</li>
<li>CY_SYSPM_FAIL - The system ULP mode is not entered. For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to put the device into the ULP mode */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Prepare the device for system ULP entering - reconfigure/switch off </span></div><div class="line"><span class="comment">    *  some used peripherals to match the current consumption and operating </span></div><div class="line"><span class="comment">    *  frequency restrictions of ULP mode.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">     </div><div class="line">    <span class="comment">/* Call Cy_SysLib_SetWaitStates(true, clkMHz);</span></div><div class="line"><span class="comment">    *  where clkMHz is the CPU frequency in MHz</span></div><div class="line"><span class="comment">    */</span></div><div class="line">     </div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#gaca7c8f1ab6d555530a68978269198836">Cy_SysPm_SystemEnterUlp</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* System did not enter ULP mode because a registered </span></div><div class="line"><span class="comment">        *  ULP &quot;check ready&quot; callback returned a &quot;not success&quot; status</span></div><div class="line"><span class="comment">        */</span></div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">/* Device is in system ULP mode */</span></div><div class="line">    </div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gae97647a28c370674ba57d451d21d1c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae97647a28c370674ba57d451d21d1c51">&#9670;&nbsp;</a></span>Cy_SysPm_SystemEnterHibernate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_SystemEnterHibernate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the device into system Hibernate mode. </p>
<p>Puts the device into the system Hibernate power mode. Prior to entering Hibernate mode, all callbacks of the CY_SYSPM_HIBERNATE type are executed.</p>
<p>First, callbacks of the CY_SYSPM_HIBERNATE type are called with the CY_SYSPM_CHECK_READY parameter. This allows the callback to signal that the driver is not ready to enter the system Hibernate power mode. If any of the callback return CY_SYSPM_FAIL, the remaining CY_SYSPM_HIBERNATE callbacks are skipped. In this case, all of the callbacks that have already been called are called again with the CY_SYSPM_CHECK_FAIL parameter. System Hibernate mode is not entered and the <a class="el" href="group__group__syspm__functions__power.html#gae97647a28c370674ba57d451d21d1c51" title="Sets the device into system Hibernate mode. ">Cy_SysPm_SystemEnterHibernate()</a> function returns CY_SYSPM_FAIL.</p>
<p>If all CY_SYSPM_HIBERNATE callbacks with the CY_SYSPM_CHECK_READY parameter return CY_SYSPM_SUCCESS, then all CY_SYSPM_HIBERNATE callbacks with CY_SYSPM_CHECK_FAIL calls are skipped and all CY_SYSPM_HIBERNATE callbacks with CY_SYSPM_BEFORE_TRANSITION parameter are executed allowing the peripherals to prepare for system Hibernate.</p>
<p>The I/O output state is automatically frozen by hardware system and Hibernate mode is then entered. In Hibernate mode, all internal supplies are off and no internal state is retained. The only exception is resources powered by the Vbackup domain continue to operate, if enabled. For multi-CPU devices, there is no handshake with the CPUs and the chip will enter Hibernate power mode immediately.</p>
<dl class="section note"><dt>Note</dt><dd>The last callback that returns CY_SYSPM_FAIL is not executed with the CY_SYSPM_CHECK_FAIL parameter because of the FAIL. The callback generating CY_SYSPM_FAIL is expected to not make any changes that require being undone.</dd></dl>
<p>The return value from executed callback functions with the CY_SYSPM_CHECK_FAIL, CY_SYSPM_BEFORE_TRANSITION, and CY_SYSPM_AFTER_TRANSITION modes are ignored.</p>
<p>Wakeup from system Hibernate is triggered by toggling the wakeup pin(s), WDT match, or back-up domain RTC alarm expiration, depending on how the they are configured. A wakeup causes a normal boot procedure. To configure the wakeup pin(s), a digital input pin must be configured, and resistively pulled up or down to the inverse state of the wakeup polarity. To distinguish a Hibernate mode from a general reset wakeup event, the <a class="el" href="group__group__syslib__functions.html#gac8aa61d2f8052886c676f4f592d1693d" title="The function returns the cause for the latest reset(s) that occurred in the system. ">Cy_SysLib_GetResetReason()</a> function can be used. The wakeup pin and low-power comparators are active-low by default. The wakeup pin or the LPComparators polarity can be changed with the <a class="el" href="group__group__syspm__functions__power.html#ga2540970e6c27efa25752efc43da0d622">Cy_SysPm_SetHibernateWakeupSource()</a> function. This function call will not return if system Hibernate mode is entered. The CY_SYSPM_HIBERNATE callbacks with the CY_SYSPM_AFTER_TRANSITION parameter are never executed.</p>
<p>This function freezes the I/O pins implicitly. Entering system Hibernate mode before freezing the I/O pins is not possible. The I/O pins remain frozen after waking from Hibernate mode until the firmware unfreezes them with a <a class="el" href="group__group__syspm__functions__iofreeze.html#ga5df20917d995755606672fac961e8e9b">Cy_SysPm_IoUnfreeze()</a> function call.</p>
<p>Boot firmware should reconfigure the I/O pins as required by the application prior unfreezing them.</p>
<p>To support control of callback execution order th following method is implemented. Callback function with the CY_SYSPM_CHECK_READY and CY_SYSPM_BEFORE_TRANSITION parameter are executed in the same order they are registered. Callback function with the CY_SYSPM_CHECK_FAIL and CY_SYSPM_AFTER_TRANSITION parameter are executed in the reverse order they are registered.</p>
<dl class="section return"><dt>Returns</dt><dd>Entered status, see <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>. For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to put the device into the system Hibernate mode */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Prepare the device for system Hibernate mode here */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> != <a class="code" href="group__group__syspm__functions__power.html#gae97647a28c370674ba57d451d21d1c51">Cy_SysPm_SystemEnterHibernate</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* System did not enter Hibernate mode because a registered </span></div><div class="line"><span class="comment">        *  Hibernate &quot;check ready&quot; callback returned a &quot;not success&quot; status</span></div><div class="line"><span class="comment">        */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* You will never get CY_SYSPM_SUCCESS here because in case of successfully</span></div><div class="line"><span class="comment">     * entering system hibernate mode because a wakeup from system Hibernate </span></div><div class="line"><span class="comment">     * goes through the system reset.</span></div><div class="line"><span class="comment">     */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga2540970e6c27efa25752efc43da0d622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2540970e6c27efa25752efc43da0d622">&#9670;&nbsp;</a></span>Cy_SysPm_SetHibernateWakeupSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysPm_SetHibernateWakeupSource </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeupSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures sources to wake up the device from the system Hibernate power mode. </p>
<p>Sources can be wakeup pins, LPComparators, Watchdog (WDT) interrupt, or a Real-Time clock (RTC) alarm (interrupt). Wakeup from system Hibernate always results in a device reset and normal boot process.</p>
<p>Wakeup pins:</p>
<p>A wakeup is supported by up to two pins with programmable polarity. These pins are typically connected to the GPIO pins or on-chip peripherals under some conditions. See device datasheet for specific pin connections. Setting the wakeup pin to this level will cause a wakeup from system Hibernate mode. The wakeup pins are active-low by default.</p>
<p>LPComparators:</p>
<p>A wakeup is supported by up to two LPComps with programmable polarity. Setting the LPComp to this level will cause a wakeup from system Hibernate mode. The wakeup LPComps are active-low by default.</p>
<dl class="section note"><dt>Note</dt><dd>The low-power comparators should be configured and enabled before switching to system Hibernate mode. Refer to the LPComp driver description for more detail.</dd></dl>
<p>Watchdog Timer:</p>
<dl class="section note"><dt>Note</dt><dd>The WDT should be configured and enabled before entering to system Hibernate mode.</dd></dl>
<p>A wakeup is performed by a WDT interrupt.</p>
<p>Real-time Clock:</p>
<p>A wakeup is performed by the RTC alarm. Refer to the Real-Time Clock (RTC) driver description for more detail.</p>
<p>For information about wakeup sources and their assignment in specific devices, refer to the appropriate device TRM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeupSource</td><td>The source to be configured as a wakeup source from the system Hibernate power mode, see <a class="el" href="group__group__syspm__data__enumerates.html#ga369b76c2e602edf09ede9f8f804e066e">cy_en_syspm_hibernate_wakeup_source_t</a>. The input parameter values can be ORed. For example, if you want to enable LPComp0 (active high) and WDT, call this function: Cy_SysPm_SetHibernateWakeupSource(CY_SYSPM_HIBERNATE_LPCOMP0_HIGH | CY_SYSPM_HIBERNATE_WDT).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function with different polarity levels for the same wakeup source. For example, do not call a function like this: Cy_SysPm_SetHibernateWakeupSource(CY_SYSPM_HIBERNATE_LPCOMP0_LOW, CY_SYSPM_HIBERNATE_LPCOMP0_HIGH);</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to configure all desired system Hibernate wake up sources */</span></div><div class="line">    <a class="code" href="group__group__syspm__functions__power.html#ga2540970e6c27efa25752efc43da0d622">Cy_SysPm_SetHibernateWakeupSource</a>(<a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066ea21ccdb0596ce5097ca95c700e46e24cf">CY_SYSPM_HIBERNATE_LPCOMP0_LOW</a> | <a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066eaf1aa6dc689e0656b696f0b81f7e323c7">CY_SYSPM_HIBERNATE_RTC_ALARM</a> | <a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066eacb2a6e7c498e704f86f2315833feddcf">CY_SYSPM_HIBERNATE_PIN1_HIGH</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Scenario: the LPComp0 wake up polarity was Low and there is a need to set it to High */</span></div><div class="line">    <a class="code" href="group__group__syspm__functions__power.html#ga2540970e6c27efa25752efc43da0d622">Cy_SysPm_SetHibernateWakeupSource</a>(<a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066ea5dbe774244382f2a853050d758a58219">CY_SYSPM_HIBERNATE_LPCOMP0_HIGH</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga5cb3a837b9c441f4806c7550e6a0b026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb3a837b9c441f4806c7550e6a0b026">&#9670;&nbsp;</a></span>Cy_SysPm_ClearHibernateWakeupSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysPm_ClearHibernateWakeupSource </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeupSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables a wakeup source that was previously configured to wake up the device from the system Hibernate mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeupSource</td><td>For the source to be disabled, see <a class="el" href="group__group__syspm__data__enumerates.html#ga369b76c2e602edf09ede9f8f804e066e">cy_en_syspm_hibernate_wakeup_source_t</a>. The input parameters values can be ORed. For example, if you want to disable LPComp0 (active high) and WDT call this function: Cy_SysPm_ClearHibernateWakeupSource(CY_SYSPM_HIBERNATE_LPCOMP0_HIGH | CY_SYSPM_HIBERNATE_WDT).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to disable the LPComp0 wake up source */</span></div><div class="line">    <a class="code" href="group__group__syspm__functions__power.html#ga5cb3a837b9c441f4806c7550e6a0b026">Cy_SysPm_ClearHibernateWakeupSource</a>(<a class="code" href="group__group__syspm__data__enumerates.html#gga369b76c2e602edf09ede9f8f804e066ea5dbe774244382f2a853050d758a58219">CY_SYSPM_HIBERNATE_LPCOMP0_HIGH</a>);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga3bde7056544d0ada3da80a0f58fefab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bde7056544d0ada3da80a0f58fefab9">&#9670;&nbsp;</a></span>Cy_SysPm_SystemSetMinRegulatorCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_SystemSetMinRegulatorCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the system into minimum core regulator current mode. </p>
<p>This mode limits maximum current available for the system core logic.</p>
<p>Minimum regulator current mode modifies operation of the system in LP or ULP modes to further reduce current consumption. If the system current is below datasheet current limits for the active core voltage regulator (LDO or Buck), this mode may be entered. The user is responsible for ensuring the regulator current limit is met in their application.</p>
<p>When in minimum regulator current mode, the following system resources are also set to their LP mode:</p><ul>
<li>Linear regulator (If LDO is active regulator)</li>
<li>POR/BOD circuit</li>
<li>Bandgap reference circuit</li>
<li>Reference buffer circuit</li>
<li>Current reference circuit</li>
</ul>
<p>The LDO and Buck current limits must be met prior to entering this mode. If these are not met, the device may brown out, resulting in an exception or reset. These changes also reduce power supply rejection of the affected system resources, which can result in increased noise or response time. These effects must be evaluated in each application.</p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a>.<ul>
<li>CY_SYSPM_SUCCESS - Minimum regulator current mode was set</li>
<li>CY_SYSPM_CANCELED - The power circuits were not ready to enter into minimum current mode. You should call the function again. For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</li>
</ul>
</dd></dl>
<p>Refer to device datasheet for maximum current value in regulator minimum current mode.</p>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    </div><div class="line">    <span class="comment">/* Scenario: There is a need to limit device current consumption. This can </span></div><div class="line"><span class="comment">    *  be done by setting the regulator minimum current mode</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Before setting the regulator minimum current mode ensure that device </span></div><div class="line"><span class="comment">    *  current consumption is less than the regulator maximum value. If not BOD </span></div><div class="line"><span class="comment">    *  can occur. Refer to device datasheet for the maximum current value of </span></div><div class="line"><span class="comment">    *  regulator minimum current mode</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Check regulator current mode */</span></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="group__group__syspm__functions__power.html#gadf5d2956621c6ba87c0d968ed497b970">Cy_SysPm_SystemIsMinRegulatorCurrentSet</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set regulator minimum current mode */</span></div><div class="line">        <a class="code" href="group__group__syspm__functions__power.html#ga3bde7056544d0ada3da80a0f58fefab9">Cy_SysPm_SystemSetMinRegulatorCurrent</a>();</div><div class="line">    }</div><div class="line">    </div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga54112d6ea4d40ad241923ee7068f5363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54112d6ea4d40ad241923ee7068f5363">&#9670;&nbsp;</a></span>Cy_SysPm_SystemSetNormalRegulatorCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__syspm__data__enumerates.html#ga601b1cb722cb091133caf33d8ab235ca">cy_en_syspm_status_t</a> Cy_SysPm_SystemSetNormalRegulatorCurrent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the system to normal regulator current mode. </p>
<p>Normal regulator current mode modifies operation of the system in LP or ULP modes to provide maximum core current consumption. If the LDO core regulator is in use, the normal mode output current limits may be used. If the buck regulator is in use, its reduced current output limits still apply.</p>
<p>When in normal regulator current mode, the following system resources are set to their normal mode:</p><ul>
<li>Linear regulator (If LDO is active regulator)</li>
<li>POR/BOD circuit</li>
<li>Bandgap reference circuit</li>
<li>Reference buffer circuit</li>
<li>Current reference circuit</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>CY_SYSPM_SUCCESS - Normal regulator current mode was set</li>
<li>CY_SYSPM_TIMEOUT - The timeout occurred because device was not ready to enter into the normal regulator current mode For the PSoC 64 devices there are possible situations when function returns the PRA error status code. This is because for PSoC 64 devices the function uses the PRA driver to change the protected registers. Refer to <a class="el" href="group__group__pra__enums.html#ga60be13e12e82986f8c0d6c6a6d4f12c5">cy_en_pra_status_t</a> for more details.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    </div><div class="line">    <span class="comment">/* Scenario: There is a need to increase available core regulator current </span></div><div class="line"><span class="comment">    *  by setting the to regulator normal current mode</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Check regulator current mode */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__syspm__functions__power.html#gadf5d2956621c6ba87c0d968ed497b970">Cy_SysPm_SystemIsMinRegulatorCurrentSet</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set regulator to normal current mode */</span></div><div class="line">        <a class="code" href="group__group__syspm__functions__power.html#ga54112d6ea4d40ad241923ee7068f5363">Cy_SysPm_SystemSetNormalRegulatorCurrent</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Once the regulator is set to normal current mode, current consumption </span></div><div class="line"><span class="comment">    *  can be increased to maximum specification</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    </div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gadf5d2956621c6ba87c0d968ed497b970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf5d2956621c6ba87c0d968ed497b970">&#9670;&nbsp;</a></span>Cy_SysPm_SystemIsMinRegulatorCurrentSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_SysPm_SystemIsMinRegulatorCurrentSet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the system regulator is set to minimal current mode. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True - system is in regulator minimum current mode.</li>
<li>False - system is in normal regulator current mode.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    </div><div class="line">    <span class="comment">/* Scenario: There is a need to increase available core regulator current </span></div><div class="line"><span class="comment">    *  by setting the to regulator normal current mode</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Check regulator current mode */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__syspm__functions__power.html#gadf5d2956621c6ba87c0d968ed497b970">Cy_SysPm_SystemIsMinRegulatorCurrentSet</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set regulator to normal current mode */</span></div><div class="line">        <a class="code" href="group__group__syspm__functions__power.html#ga54112d6ea4d40ad241923ee7068f5363">Cy_SysPm_SystemSetNormalRegulatorCurrent</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Once the regulator is set to normal current mode, current consumption </span></div><div class="line"><span class="comment">    *  can be increased to maximum specification</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    </div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7c50f7236c3a6a7b75a7d915f8ebb089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c50f7236c3a6a7b75a7d915f8ebb089">&#9670;&nbsp;</a></span>Cy_SysPm_CpuSleepOnExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_SysPm_CpuSleepOnExit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the sleep-on-exit feature of the CPU. </p>
<p>This API sets the SLEEPONEXIT bit of the SCR register.</p>
<p>When the sleep-on-exit feature is enabled (the SLEEPONEXIT bit is set), the CPU wakes up to service the interrupt and then immediately goes back to sleep. Because of this, the unstacking process is not carried out, so this feature is useful for interrupt driven application and helps to reduce unnecessary stack push and pop operations. The CPU does not go to sleep if the interrupt handler returns to another interrupt handler (nested interrupt). You can use this feature in applications that require the CPU to only run when an interrupt occurs.</p>
<p>When the sleep-on-exit feature is disabled (the SLEEPONEXIT bit is cleared), the CPU returns back to the main thread after servicing the interrupt without going back to sleep.</p>
<p>Refer to the Arm documentation about the sleep-on-exit feature and SLEEPONEXIT in the SCR register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><ul>
<li>True if enable sleep-on-exit feature.</li>
<li>False if disable sleep-on-exit feature.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to enable sleep-on-exit feature */</span></div><div class="line">    <a class="code" href="group__group__syspm__functions__power.html#ga7c50f7236c3a6a7b75a7d915f8ebb089">Cy_SysPm_CpuSleepOnExit</a>(<span class="keyword">true</span>);</div><div class="line">    </div><div class="line">    <span class="comment">/* Prepare the device for CPU Sleep */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__syspm__data__enumerates.html#gga601b1cb722cb091133caf33d8ab235caaf00d22f1ee891a8a56f8bbf58132e775">CY_SYSPM_SUCCESS</a> == <a class="code" href="group__group__syspm__functions__power.html#gab09936e85606de476a0c379f9548603f">Cy_SysPm_CpuEnterSleep</a>(<a class="code" href="group__group__syspm__data__enumerates.html#ggaae6a9f528630a2d69bb70b3bced1f0acadf47e50b6700c08b6f9e7e70bb525541">CY_SYSPM_WAIT_FOR_INTERRUPT</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Now the CPU is in Sleep. </span></div><div class="line"><span class="comment">        *  The CPU wakes up to service the interrupt and then immediately goes </span></div><div class="line"><span class="comment">        *  back to CPU Sleep. </span></div><div class="line"><span class="comment">        */</span> </div><div class="line">    }</div><div class="line">        </div><div class="line">    <span class="comment">/* Scenario: There is a need to disable sleep-on-exit after it was enabled</span></div><div class="line"><span class="comment">    *  Call Cy_SysPm_CpuSleepOnExit(false) in the interrupt handler </span></div><div class="line"><span class="comment">    */</span></div><div class="line">        </div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga177941ebfd3c4e3f6e391d303c407534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga177941ebfd3c4e3f6e391d303c407534">&#9670;&nbsp;</a></span>Cy_SysPm_CpuSendWakeupEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SysPm_CpuSendWakeupEvent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the SEV (Send Event) ARM instruction to the system. </p>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    </div><div class="line">    <span class="comment">/* Scenario: There is a need wakeup the CM4 CPU in the system using the </span></div><div class="line"><span class="comment">    *  CM0+ CPU without using interrupts if the CM4 CPU is in CPU Sleep mode.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Check the CM4 CPU status */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__syspm__functions__power__status.html#gacd7b6466440678ce4ea36dbba53eaa3e">Cy_SysPm_Cm4IsSleep</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wake up the CM4 CPU */</span></div><div class="line">        <a class="code" href="group__group__syspm__functions__power.html#ga177941ebfd3c4e3f6e391d303c407534">Cy_SysPm_CpuSendWakeupEvent</a>();</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
