<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: EZI2C (SCB)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__ezi2c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">EZI2C (SCB)<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Driver API for EZI2C Slave Peripheral. </p>
<p>The functions and other declarations used in this part of the driver are in cy_scb_ezi2c.h. You can also include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>I2C - The Inter-Integrated Circuit (I2C) bus is an industry-standard.</p>
<p>The EZI2C slave peripheral driver provides an API to implement the I2C slave device based on the SCB hardware block. This slave device emulates a common I2C EEPROM interface that acts like dual-port memory between the external master and your code. I2C devices based on the SCB hardware are compatible with the I2C Standard mode, Fast mode, and Fast mode Plus specifications, as defined in the I2C bus specification.</p>
<p>Features:</p><ul>
<li>An industry-standard I2C bus interface</li>
<li>Supports standard data rates of 100/400/1000 kbps</li>
<li>Emulates a common I2C EEPROM Interface</li>
<li>Acts like dual-port memory between the external master and your code</li>
<li>Supports Hardware Address Match</li>
<li>Supports two hardware addresses with separate buffers</li>
<li>Supports Wake from Deep Sleep on address match</li>
<li>Simple to set up and use; does not require calling EZI2C API at run time.</li>
</ul>
<h1><a class="anchor" id="group_scb_ezi2c_configuration"></a>
Configuration Considerations</h1>
<p>The EZI2C slave driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_config">Configure EZI2C slave</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_data_rate">Configure Data Rate</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_enable">Enable EZI2C slave</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>EZI2C slave driver is built on top of the SCB hardware block. The SCB3 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_ezi2c_config"></a>
Configure EZI2C slave</h2>
<p>To set up the EZI2C slave driver, provide the configuration parameters in the <a class="el" href="structcy__stc__scb__ezi2c__config__t.html">cy_stc_scb_ezi2c_config_t</a> structure. The primary slave address slaveAddress1 must be provided. The other parameters are optional for operation. To initialize the driver, call <a class="el" href="group__group__scb__ezi2c__general__functions.html#gaafe61aa4c2931975a8698afa46717b97">Cy_SCB_EZI2C_Init</a> function providing a pointer to the populated <a class="el" href="structcy__stc__scb__ezi2c__config__t.html">cy_stc_scb_ezi2c_config_t</a> structure and the allocated <a class="el" href="structcy__stc__scb__ezi2c__context__t.html">cy_stc_scb_ezi2c_context_t</a> structure.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate context for EZI2C operation */</span></div><div class="line"><a class="code" href="structcy__stc__scb__ezi2c__context__t.html">cy_stc_scb_ezi2c_context_t</a> ezI2cContext;</div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__scb__ezi2c__config__t.html">cy_stc_scb_ezi2c_config_t</a> ezI2cConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__scb__ezi2c__config__t.html#aa3405d940eb60a40f7de1580eb391c71">numberOfAddresses</a> = <a class="code" href="group__group__scb__ezi2c__enums.html#gga5e20e1c00a75b3467305aa839271697aa88d5060e586a93a7e1c77885dee8c5cf">CY_SCB_EZI2C_ONE_ADDRESS</a>,</div><div class="line">    .slaveAddress1     = 0x08U,</div><div class="line">    .slaveAddress2     = 0x00U,</div><div class="line">    .subAddressSize    = <a class="code" href="group__group__scb__ezi2c__enums.html#gga2a4845448404203987f881e2e907feffa313bce9b46a4ce11f0d2891842e98ee6">CY_SCB_EZI2C_SUB_ADDR8_BITS</a>,</div><div class="line">    .enableWakeFromSleep = <span class="keyword">false</span>,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Configure EZI2C slave */</span></div><div class="line">(void) <a class="code" href="group__group__scb__ezi2c__general__functions.html#gaafe61aa4c2931975a8698afa46717b97">Cy_SCB_EZI2C_Init</a>(SCB3, &amp;ezI2cConfig, &amp;ezI2cContext);</div></div><!-- fragment --><p> Set up the EZI2C slave buffer before enabling its operation by using <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga37de7020a41bff6ee0ad54af0a8be36e">Cy_SCB_EZI2C_SetBuffer1</a> for the primary slave address and <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga2435d7a2b8e0d069e6ae1f2686e64be8">Cy_SCB_EZI2C_SetBuffer2</a> for the secondary (if the secondary is enabled).</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate buffer for EZI2C operation */</span></div><div class="line"><span class="preprocessor">#define BUFFER_SIZE (128UL)</span></div><div class="line">uint8_t bufferAddr1[BUFFER_SIZE];</div><div class="line"></div><div class="line"><span class="comment">/* Configure buffer for communication with master */</span></div><div class="line"><a class="code" href="group__group__scb__ezi2c__slave__functions.html#ga37de7020a41bff6ee0ad54af0a8be36e">Cy_SCB_EZI2C_SetBuffer1</a>(SCB3, bufferAddr1, BUFFER_SIZE, BUFFER_SIZE, &amp;ezI2cContext);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_pins"></a>
Assign and Configure Pins</h2>
<p>Only dedicated SCB pins can be used for I2C operation. The HSIOM register must be configured to connect dedicated SCB I2C pins to the SCB block. Also the I2C pins must be configured in Open-Drain, Drives Low mode (this pin configuration implies usage of external pull-up resistors):</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign pins for EZI2C on SCB3: P6[0] and P6[1] */</span></div><div class="line"><span class="preprocessor">#define EZI2C_PORT      (P6_0_PORT)</span></div><div class="line"><span class="preprocessor">#define EZI2C_SCL_NUM   (P6_0_NUM)</span></div><div class="line"><span class="preprocessor">#define EZI2C_SDA_NUM   (P6_1_NUM)</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect SCB3 I2C function to pins */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(EZI2C_PORT, EZI2C_SCL_NUM, P6_0_SCB3_I2C_SCL);</div><div class="line"><a class="code" href="group__group__gpio__functions__init.html#ga83a06264feed0e1042671a74339ea155">Cy_GPIO_SetHSIOM</a>(EZI2C_PORT, EZI2C_SDA_NUM, P6_1_SCB3_I2C_SDA);</div><div class="line"></div><div class="line"><span class="comment">/* Configure pins for I2C operation */</span></div><div class="line"><a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(EZI2C_PORT, EZI2C_SCL_NUM, <a class="code" href="group__group__gpio__drive_modes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div><div class="line"><a class="code" href="group__group__gpio__functions__gpio.html#ga97e64dc8c45e7cd73e3012100d03b1fd">Cy_GPIO_SetDrivemode</a>(EZI2C_PORT, EZI2C_SDA_NUM, <a class="code" href="group__group__gpio__drive_modes.html#ga4c713a8cb3c1e444153829c5ea94b34f">CY_GPIO_DM_OD_DRIVESLOW</a>);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The alternative pins configuration is Resistive Pull-ups which implies usage internal pull-up resistors. This configuration is not recommended because resistor value is fixed and cannot be used for all supported data rates. Refer to device datasheet parameter RPULLUP for resistor value specifications.</dd></dl>
<h2><a class="anchor" id="group_scb_ezi2c_clock"></a>
Assign Clock Divider</h2>
<p>A clock source must be connected to the SCB block to oversample input and output signals, in this document this clock will be referred as clk_scb. You must use one of the 8-bit or 16-bit dividers. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign divider type and number for EZI2C */</span></div><div class="line"><span class="preprocessor">#define EZI2C_CLK_DIV_TYPE  (CY_SYSCLK_DIV_8_BIT)</span></div><div class="line"><span class="preprocessor">#define EZI2C_CLK_DIV_NUM   (0UL)</span></div><div class="line"></div><div class="line"><span class="comment">/* Connect assigned divider to be a clock source for EZI2C */</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gacb66324e3191006f6d1cee8b29238fb2">Cy_SysClk_PeriphAssignDivider</a>(PCLK_SCB3_CLOCK, EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUM);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_data_rate"></a>
Configure Data Rate</h2>
<p>To get EZI2C slave to operate at the desired data rate, the clk_scb must be fast enough to provide sufficient oversampling. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<p><b>Refer to the technical reference manual (TRM) section I2C sub-section Oversampling and Bit Rate to get information about how to configure the I2C to run at the desired data rate</b>.</p>
<div class="fragment"><div class="line"><span class="comment">/* EZI2C slave desired data rate is 400 kbps.</span></div><div class="line"><span class="comment">* To support this data rate the clk_scb frequency must be in range 7.82 â€“ 15.38 MHz.</span></div><div class="line"><span class="comment">* Find clk_scb valid ranges in TRM section I2C sub-section Oversampling and Bit Rate.</span></div><div class="line"><span class="comment">* For clk_peri = 50 MHz, select divider value 4 and get clk_scb = (50 MHz / 4) = 12.5 MHz.</span></div><div class="line"><span class="comment">* This clock frequency meets requirements above.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gac67931844e6ec06b5ff88f4f3119e127">Cy_SysClk_PeriphSetDivider</a>   (EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUM, 3u);</div><div class="line"><a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga8c626f11b583d8296516bbcf4a22f98e">Cy_SysClk_PeriphEnableDivider</a>(EZI2C_CLK_DIV_TYPE, EZI2C_CLK_DIV_NUM);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_intr"></a>
Configure Interrupt</h2>
<p>The interrupt is mandatory for the EZI2C slave operation. The <a class="el" href="group__group__scb__ezi2c__slave__functions.html#ga5e811e428ecb264dddb284066d6ff956">Cy_SCB_EZI2C_Interrupt</a> function must be called in the interrupt handler for the selected SCB instance. Also, this interrupt must be enabled in the NVIC or it will not work.</p>
<div class="fragment"><div class="line"><span class="comment">/* Implement ISR for EZI2C */</span></div><div class="line"><span class="keywordtype">void</span> EZI2C_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__scb__ezi2c__slave__functions.html#ga5e811e428ecb264dddb284066d6ff956">Cy_SCB_EZI2C_Interrupt</a>(SCB3, &amp;ezI2cContext);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Assign EZI2C interrupt number and priority */</span></div><div class="line"><span class="preprocessor">#define EZI2C_INTR_NUM        scb_3_interrupt_IRQn</span></div><div class="line"><span class="preprocessor">#define EZI2C_INTR_PRIORITY   (7UL)</span></div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure (code specific for CM4) */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> ezI2cIntrConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = EZI2C_INTR_NUM,</div><div class="line">    .intrPriority = EZI2C_INTR_PRIORITY,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div><div class="line">(void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;ezI2cIntrConfig, &amp;EZI2C_Isr);</div><div class="line">NVIC_EnableIRQ(EZI2C_INTR_NUM);</div></div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_enable"></a>
Enable EZI2C slave</h2>
<p>Finally, enable the EZI2C slave operation by calling <a class="el" href="group__group__scb__ezi2c__general__functions.html#gae5c13ff7a89e0a75fbe83bd5dfc4fc95">Cy_SCB_EZI2C_Enable</a>. Now the I2C device responds to the assigned address. </p><div class="fragment"><div class="line"><span class="comment">/* Enable EZI2C to operate */</span></div><div class="line"><a class="code" href="group__group__scb__ezi2c__general__functions.html#gae5c13ff7a89e0a75fbe83bd5dfc4fc95">Cy_SCB_EZI2C_Enable</a>(SCB3);</div><div class="line"></div><div class="line"><span class="comment">/* Enable global interrupts */</span></div><div class="line">__enable_irq();</div></div><!-- fragment --><h1><a class="anchor" id="group_scb_ezi2c_use_cases"></a>
Common Use Cases</h1>
<p>The EZI2C slave operation might not require calling any EZI2C slave function because the I2C master is able to access the slave buffer. The application can directly access it as well. Note that this is an application-level task to ensure the buffer content integrity.</p>
<h2><a class="anchor" id="group_scb_ezi2c_master_wr"></a>
Master Write operation</h2>
<p>This operation starts with sending a base address that is one or two bytes, depending on the sub-address size configuration. This base address is retained and will be used for later read operations. Following the base address, there is a sequence of bytes written into the buffer starting from the base address location. The buffer index is incremented for each written byte, but this does not affect the base address that is retained. The length of a write operation is limited by the maximum buffer read/write region size.<br />
When a master attempts to write outside the read/write region or past the end of the buffer, the last byte is NACKed.</p>
<div class="image">
<img src="scb_ezi2c_write.png" alt="scb_ezi2c_write.png"/>
</div>
<h2><a class="anchor" id="group_scb_ezi2c_master_rd"></a>
Master Read operation</h2>
<p>This operation always starts from the base address set by the most recent write operation. The buffer index is incremented for each read byte. Two sequential read operations start from the same base address no matter how many bytes are read. The length of a read operation is not limited by the maximum size of the data buffer. The EZI2C slave returns 0xFF bytes if the read operation passes the end of the buffer.<br />
Typically, a read operation requires the base address to be updated before starting the read. In this case, the write and read operations must be combined together.</p>
<div class="image">
<img src="scb_ezi2c_read.png" alt="scb_ezi2c_read.png"/>
</div>
<p>The I2C master may use the ReStart or Stop/Start conditions to combine the operations. The write operation sets only the base address and the following read operation will start from the new base address. In cases where the base address remains the same, there is no need for a write operation. </p><div class="image">
<img src="scb_ezi2c_set_ba_read.png" alt="scb_ezi2c_set_ba_read.png"/>
</div>
<h1><a class="anchor" id="group_scb_ezi2c_lp"></a>
Low Power Support</h1>
<p>The EZI2C slave provides the callback functions to handle power mode transition. The callback <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga5875cdcf148b37407ee8360b79580426">Cy_SCB_EZI2C_DeepSleepCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#ga5150c28fe4d2626720c1fbf74b3111ca">Cy_SysPm_CpuEnterDeepSleep</a>; <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga0c0f0f4191ec10d04b0b3a8363e7caf4">Cy_SCB_EZI2C_HibernateCallback</a> must be called during execution of <a class="el" href="group__group__syspm__functions__power.html#gae97647a28c370674ba57d451d21d1c51">Cy_SysPm_SystemEnterHibernate</a>. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration.</p>
<p>The EZI2C configured to support two addresses can wakeup the device on address match to NACK not supported address. This happens because the hardware address-match-logic uses address bit masking to support to two addresses. The address mask defines which bits in the address are treated as non-significant while performing an address match. One non-significant bit results in two matching addresses; two bits will match 4 and so on. If the two addresses differ by more than a single bit, then the extra addresses that will pass the hardware match and wakeup the device from Deep Sleep mode. Then firmware address matching will to generate a NAK. Due to this reason, it is preferable to select a secondary address that is different from the primary by one bit. The address mask in this case makes one bit non-significant. For example:</p><ul>
<li>Primary address = 0x24 and secondary address = 0x34, only one bit differs. Only the two addresses are treated as matching by the hardware.</li>
<li>Primary address = 0x24 and secondary address = 0x30, two bits differ. Four addresses are treated as matching by the hardware: 0x24, 0x34, 0x20 and 0x30. Firmware is required to ACK only the primary and secondary addresses 0x24 and 0x30 and NAK all others 0x20 and 0x34.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Only applicable for <b>rev-08 of the CY8CKIT-062-BLE</b>. For proper operation, when the EZI2C slave is configured to be a wakeup source from Deep Sleep mode, the <a class="el" href="group__group__scb__ezi2c__low__power__functions.html#ga5875cdcf148b37407ee8360b79580426">Cy_SCB_EZI2C_DeepSleepCallback</a> must be copied and modified. Refer to the function description to get the details. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__ezi2c__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
