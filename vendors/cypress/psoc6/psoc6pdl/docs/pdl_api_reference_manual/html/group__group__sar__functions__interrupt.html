<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: Interrupt Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__sar__functions__interrupt.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interrupt Functions<div class="ingroups"><a class="el" href="group__group__sar.html">SAR          (SAR ADC Subsystem)</a> &raquo; <a class="el" href="group__group__sar__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>This set of functions are related to SAR interrupts. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaddf21063ab5d851b7a658af1c3c07f65"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#gaddf21063ab5d851b7a658af1c3c07f65">Cy_SAR_GetInterruptStatus</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:gaddf21063ab5d851b7a658af1c3c07f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interrupt register status.  <a href="#gaddf21063ab5d851b7a658af1c3c07f65">More...</a><br /></td></tr>
<tr class="separator:gaddf21063ab5d851b7a658af1c3c07f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749c0d8406080c3a2fc0d6f6d86fc06e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga749c0d8406080c3a2fc0d6f6d86fc06e">Cy_SAR_ClearInterrupt</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga749c0d8406080c3a2fc0d6f6d86fc06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the interrupt.  <a href="#ga749c0d8406080c3a2fc0d6f6d86fc06e">More...</a><br /></td></tr>
<tr class="separator:ga749c0d8406080c3a2fc0d6f6d86fc06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3e72e2eead227fedd3d93ccc2daed7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga5b3e72e2eead227fedd3d93ccc2daed7">Cy_SAR_SetInterrupt</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga5b3e72e2eead227fedd3d93ccc2daed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger an interrupt with software.  <a href="#ga5b3e72e2eead227fedd3d93ccc2daed7">More...</a><br /></td></tr>
<tr class="separator:ga5b3e72e2eead227fedd3d93ccc2daed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e58407ba299f3cdd3170133bdffb0ba"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga0e58407ba299f3cdd3170133bdffb0ba">Cy_SAR_SetInterruptMask</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga0e58407ba299f3cdd3170133bdffb0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable which interrupts can trigger the CPU interrupt controller.  <a href="#ga0e58407ba299f3cdd3170133bdffb0ba">More...</a><br /></td></tr>
<tr class="separator:ga0e58407ba299f3cdd3170133bdffb0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05867acc84f4c041538fe2b01e00680c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga05867acc84f4c041538fe2b01e00680c">Cy_SAR_GetInterruptMask</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:ga05867acc84f4c041538fe2b01e00680c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return which interrupts can trigger the CPU interrupt controller as configured by <a class="el" href="group__group__sar__functions__interrupt.html#ga0e58407ba299f3cdd3170133bdffb0ba">Cy_SAR_SetInterruptMask</a>.  <a href="#ga05867acc84f4c041538fe2b01e00680c">More...</a><br /></td></tr>
<tr class="separator:ga05867acc84f4c041538fe2b01e00680c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga246d0cb5397de5f5dbb8e2ba5fb2ba33"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga246d0cb5397de5f5dbb8e2ba5fb2ba33">Cy_SAR_GetInterruptStatusMasked</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:ga246d0cb5397de5f5dbb8e2ba5fb2ba33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise AND between the interrupt request and mask registers.  <a href="#ga246d0cb5397de5f5dbb8e2ba5fb2ba33">More...</a><br /></td></tr>
<tr class="separator:ga246d0cb5397de5f5dbb8e2ba5fb2ba33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5792cd1453bb36969f7ccc165f781bc2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga5792cd1453bb36969f7ccc165f781bc2">Cy_SAR_GetRangeInterruptStatus</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:ga5792cd1453bb36969f7ccc165f781bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the range interrupt register status.  <a href="#ga5792cd1453bb36969f7ccc165f781bc2">More...</a><br /></td></tr>
<tr class="separator:ga5792cd1453bb36969f7ccc165f781bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201c48306ba342bd15618ee7d06a8dd7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga201c48306ba342bd15618ee7d06a8dd7">Cy_SAR_ClearRangeInterrupt</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t chanMask)</td></tr>
<tr class="memdesc:ga201c48306ba342bd15618ee7d06a8dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the range interrupt for the specified channel mask.  <a href="#ga201c48306ba342bd15618ee7d06a8dd7">More...</a><br /></td></tr>
<tr class="separator:ga201c48306ba342bd15618ee7d06a8dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a61f7b5ec97af86cac36623e9cfbc52"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga1a61f7b5ec97af86cac36623e9cfbc52">Cy_SAR_SetRangeInterrupt</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t chanMask)</td></tr>
<tr class="memdesc:ga1a61f7b5ec97af86cac36623e9cfbc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a range interrupt with software for the specific channel mask.  <a href="#ga1a61f7b5ec97af86cac36623e9cfbc52">More...</a><br /></td></tr>
<tr class="separator:ga1a61f7b5ec97af86cac36623e9cfbc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeedb0cc3ed13ed99b43c4deea155ae0a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#gaeedb0cc3ed13ed99b43c4deea155ae0a">Cy_SAR_SetRangeInterruptMask</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t chanMask)</td></tr>
<tr class="memdesc:gaeedb0cc3ed13ed99b43c4deea155ae0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable which channels can trigger a range interrupt.  <a href="#gaeedb0cc3ed13ed99b43c4deea155ae0a">More...</a><br /></td></tr>
<tr class="separator:gaeedb0cc3ed13ed99b43c4deea155ae0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e793fbf9d16432a806c4dffe05ccf26"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga4e793fbf9d16432a806c4dffe05ccf26">Cy_SAR_GetRangeInterruptMask</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:ga4e793fbf9d16432a806c4dffe05ccf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return which interrupts can trigger a range interrupt as configured by <a class="el" href="group__group__sar__functions__interrupt.html#gaeedb0cc3ed13ed99b43c4deea155ae0a">Cy_SAR_SetRangeInterruptMask</a>.  <a href="#ga4e793fbf9d16432a806c4dffe05ccf26">More...</a><br /></td></tr>
<tr class="separator:ga4e793fbf9d16432a806c4dffe05ccf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c2caa3c75b6c88794d7969a6de5c25"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga78c2caa3c75b6c88794d7969a6de5c25">Cy_SAR_GetRangeInterruptStatusMasked</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:ga78c2caa3c75b6c88794d7969a6de5c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise AND between the range interrupt request and mask registers.  <a href="#ga78c2caa3c75b6c88794d7969a6de5c25">More...</a><br /></td></tr>
<tr class="separator:ga78c2caa3c75b6c88794d7969a6de5c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc17a598903d803a3987008189a91ef3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#gabc17a598903d803a3987008189a91ef3">Cy_SAR_GetSatInterruptStatus</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:gabc17a598903d803a3987008189a91ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the saturate interrupt register status.  <a href="#gabc17a598903d803a3987008189a91ef3">More...</a><br /></td></tr>
<tr class="separator:gabc17a598903d803a3987008189a91ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16eb332fdbd99fff917814efafa4a47b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga16eb332fdbd99fff917814efafa4a47b">Cy_SAR_ClearSatInterrupt</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t chanMask)</td></tr>
<tr class="memdesc:ga16eb332fdbd99fff917814efafa4a47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the saturate interrupt for the specified channel mask.  <a href="#ga16eb332fdbd99fff917814efafa4a47b">More...</a><br /></td></tr>
<tr class="separator:ga16eb332fdbd99fff917814efafa4a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61bd47b40bde7befe53dbb9accde66b8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga61bd47b40bde7befe53dbb9accde66b8">Cy_SAR_SetSatInterrupt</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t chanMask)</td></tr>
<tr class="memdesc:ga61bd47b40bde7befe53dbb9accde66b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a saturate interrupt with software for the specific channel mask.  <a href="#ga61bd47b40bde7befe53dbb9accde66b8">More...</a><br /></td></tr>
<tr class="separator:ga61bd47b40bde7befe53dbb9accde66b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3805ab0afd092b89e1e4a773748b525"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#gae3805ab0afd092b89e1e4a773748b525">Cy_SAR_SetSatInterruptMask</a> (<a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base, uint32_t chanMask)</td></tr>
<tr class="memdesc:gae3805ab0afd092b89e1e4a773748b525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable which channels can trigger a saturate interrupt.  <a href="#gae3805ab0afd092b89e1e4a773748b525">More...</a><br /></td></tr>
<tr class="separator:gae3805ab0afd092b89e1e4a773748b525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead58c8afb23f3a7b3bbdba152653af2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#gaead58c8afb23f3a7b3bbdba152653af2">Cy_SAR_GetSatInterruptMask</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:gaead58c8afb23f3a7b3bbdba152653af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return which interrupts can trigger a saturate interrupt as configured by <a class="el" href="group__group__sar__functions__interrupt.html#gae3805ab0afd092b89e1e4a773748b525">Cy_SAR_SetSatInterruptMask</a>.  <a href="#gaead58c8afb23f3a7b3bbdba152653af2">More...</a><br /></td></tr>
<tr class="separator:gaead58c8afb23f3a7b3bbdba152653af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164f131dbc64b5ad4e59ec740de5e292"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga164f131dbc64b5ad4e59ec740de5e292">Cy_SAR_GetSatInterruptStatusMasked</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:ga164f131dbc64b5ad4e59ec740de5e292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise AND between the saturate interrupt request and mask registers.  <a href="#ga164f131dbc64b5ad4e59ec740de5e292">More...</a><br /></td></tr>
<tr class="separator:ga164f131dbc64b5ad4e59ec740de5e292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga030844e4a8cd612cb11195b0400c800d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__sar__functions__interrupt.html#ga030844e4a8cd612cb11195b0400c800d">Cy_SAR_GetInterruptCause</a> (const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *base)</td></tr>
<tr class="memdesc:ga030844e4a8cd612cb11195b0400c800d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cause of the interrupt.  <a href="#ga030844e4a8cd612cb11195b0400c800d">More...</a><br /></td></tr>
<tr class="separator:ga030844e4a8cd612cb11195b0400c800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaddf21063ab5d851b7a658af1c3c07f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddf21063ab5d851b7a658af1c3c07f65">&#9670;&nbsp;</a></span>Cy_SAR_GetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the interrupt register status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt status</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* ISR function to handle all SAR interrupts. </span></div><div class="line"><span class="comment"> * This same routine gets called when any of the enabled SAR interrupt sources</span></div><div class="line"><span class="comment"> * are enabled (EOS, overflow, FW collision, saturation detection, or range detection). */</span></div><div class="line"><span class="keywordtype">void</span> SAR_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status = 0u;</div><div class="line"></div><div class="line">    <span class="comment">/* Read interrupt status register. */</span></div><div class="line">    intr_status = <a class="code" href="group__group__sar__functions__interrupt.html#gaddf21063ab5d851b7a658af1c3c07f65">Cy_SAR_GetInterruptStatus</a>(SAR);</div><div class="line"></div><div class="line">    <span class="comment">/* Check what triggered the interrupt. */</span></div><div class="line">    <span class="keywordflow">if</span> ((intr_status &amp; (uint32_t) CY_SAR_INTR_EOS_MASK) == (uint32_t) CY_SAR_INTR_EOS_MASK)</div><div class="line">    {</div><div class="line">        <span class="comment">/* An end of scan occured, retrieve the ADC result and do something with it here. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Check for the saturation detection status, if enabled. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Check for the range detection status, if enabled. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Clear the handled interrupt. */</span></div><div class="line">    <a class="code" href="group__group__sar__functions__interrupt.html#ga749c0d8406080c3a2fc0d6f6d86fc06e">Cy_SAR_ClearInterrupt</a>(SAR, intr_status);</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
<a id="ga749c0d8406080c3a2fc0d6f6d86fc06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga749c0d8406080c3a2fc0d6f6d86fc06e">&#9670;&nbsp;</a></span>Cy_SAR_ClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the interrupt. </p>
<p>The interrupt must be cleared with this function so that the hardware can set subsequent interrupts and those interrupts can be forwarded to the interrupt controller, if enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">intrMask</td><td>The mask of interrupts to clear. Typically this will be the value returned from <a class="el" href="group__group__sar__functions__interrupt.html#gaddf21063ab5d851b7a658af1c3c07f65">Cy_SAR_GetInterruptStatus</a>. Alternately, select one or more values from <a class="el" href="group__group__sar__intr__mask__t__register__enums.html#gaed86236056495517571b7949afec3eb9">cy_en_sar_intr_mask_t</a> and "OR" them together.<ul>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a7a9f203ad00dedc91c67f162104520cd">CY_SAR_INTR_EOS_MASK</a></li>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a41af76a14e783b1b2d9331fa33e7d1a6">CY_SAR_INTR_OVERFLOW_MASK</a></li>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9afa668ef33ed6e5b1429ff15d7377f0a2">CY_SAR_INTR_FW_COLLISION_MASK</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga5b3e72e2eead227fedd3d93ccc2daed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b3e72e2eead227fedd3d93ccc2daed7">&#9670;&nbsp;</a></span>Cy_SAR_SetInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_SetInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger an interrupt with software. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">intrMask</td><td>The mask of interrupts to set. Select one or more values from <a class="el" href="group__group__sar__intr__mask__t__register__enums.html#gaed86236056495517571b7949afec3eb9">cy_en_sar_intr_mask_t</a> and "OR" them together.<ul>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a7a9f203ad00dedc91c67f162104520cd">CY_SAR_INTR_EOS_MASK</a></li>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a41af76a14e783b1b2d9331fa33e7d1a6">CY_SAR_INTR_OVERFLOW_MASK</a></li>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9afa668ef33ed6e5b1429ff15d7377f0a2">CY_SAR_INTR_FW_COLLISION_MASK</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga0e58407ba299f3cdd3170133bdffb0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e58407ba299f3cdd3170133bdffb0ba">&#9670;&nbsp;</a></span>Cy_SAR_SetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_SetInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable which interrupts can trigger the CPU interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">intrMask</td><td>The mask of interrupts. Select one or more values from <a class="el" href="group__group__sar__intr__mask__t__register__enums.html#gaed86236056495517571b7949afec3eb9">cy_en_sar_intr_mask_t</a> and "OR" them together.<ul>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a48b18476114beb21c27ab79d79c25bfb">CY_SAR_INTR_MASK_NONE</a> : Disable EOS, overflow, and firmware collision interrupts.</li>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a7a9f203ad00dedc91c67f162104520cd">CY_SAR_INTR_EOS_MASK</a></li>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a41af76a14e783b1b2d9331fa33e7d1a6">CY_SAR_INTR_OVERFLOW_MASK</a></li>
<li><a class="el" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9afa668ef33ed6e5b1429ff15d7377f0a2">CY_SAR_INTR_FW_COLLISION_MASK</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Enable the EOS, overflow, and firmware collision interrupt sources.</span></div><div class="line"><span class="comment">     * Make sure to assign an ISR to handle the SAR interrupts. */</span></div><div class="line"></div><div class="line">    <a class="code" href="group__group__sar__functions__interrupt.html#ga0e58407ba299f3cdd3170133bdffb0ba">Cy_SAR_SetInterruptMask</a>(SAR, (uint32_t) (CY_SAR_INTR_EOS_MASK | <a class="code" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9a41af76a14e783b1b2d9331fa33e7d1a6">CY_SAR_INTR_OVERFLOW_MASK</a> | <a class="code" href="group__group__sar__intr__mask__t__register__enums.html#ggaed86236056495517571b7949afec3eb9afa668ef33ed6e5b1429ff15d7377f0a2">CY_SAR_INTR_FW_COLLISION_MASK</a>));</div><div class="line">    </div></div><!-- fragment -->
</div>
</div>
<a id="ga05867acc84f4c041538fe2b01e00680c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05867acc84f4c041538fe2b01e00680c">&#9670;&nbsp;</a></span>Cy_SAR_GetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return which interrupts can trigger the CPU interrupt controller as configured by <a class="el" href="group__group__sar__functions__interrupt.html#ga0e58407ba299f3cdd3170133bdffb0ba">Cy_SAR_SetInterruptMask</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt mask. Compare this value with masks in <a class="el" href="group__group__sar__intr__mask__t__register__enums.html#gaed86236056495517571b7949afec3eb9">cy_en_sar_intr_mask_t</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Check whether a specific interrupt source is enabled. */</span></div><div class="line">    </div><div class="line">    uint32_t intrMask;</div><div class="line">    intrMask = <a class="code" href="group__group__sar__functions__interrupt.html#ga05867acc84f4c041538fe2b01e00680c">Cy_SAR_GetInterruptMask</a>(SAR);</div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> ((uint32_t) CY_SAR_INTR_EOS_MASK == (intrMask &amp; (uint32_t) CY_SAR_INTR_EOS_MASK))</div><div class="line">    {</div><div class="line">        <span class="comment">/* EOS interrupt was enabled. */</span></div><div class="line">    }</div></div><!-- fragment -->
</div>
</div>
<a id="ga246d0cb5397de5f5dbb8e2ba5fb2ba33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga246d0cb5397de5f5dbb8e2ba5fb2ba33">&#9670;&nbsp;</a></span>Cy_SAR_GetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise AND between the interrupt request and mask registers. </p>
<p>See <a class="el" href="group__group__sar__functions__interrupt.html#gaddf21063ab5d851b7a658af1c3c07f65">Cy_SAR_GetInterruptStatus</a> and <a class="el" href="group__group__sar__functions__interrupt.html#ga05867acc84f4c041538fe2b01e00680c">Cy_SAR_GetInterruptMask</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitwise AND of the interrupt request and mask registers </dd></dl>

</div>
</div>
<a id="ga5792cd1453bb36969f7ccc165f781bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5792cd1453bb36969f7ccc165f781bc2">&#9670;&nbsp;</a></span>Cy_SAR_GetRangeInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetRangeInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the range interrupt register status. </p>
<p>If the status bit is low for a channel, the channel may not be enabled (<a class="el" href="group__group__sar__functions__config.html#ga4808c2e7e72e2648c0efbf3eb025366f">Cy_SAR_SetChanMask</a>), range detection is not enabled for the channel (<a class="el" href="group__group__sar__functions__interrupt.html#gaeedb0cc3ed13ed99b43c4deea155ae0a">Cy_SAR_SetRangeInterruptMask</a>), or range detection was not triggered for the channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The range interrupt status for all channels. Bit 0 is for channel 0, etc.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Range detection has been enabled for at least one channel.</span></div><div class="line"><span class="comment">     * Check the range interrupt status in the ISR when an interrupt occurs. */</span></div><div class="line">    </div><div class="line">    uint32_t intr_status = 0u;</div><div class="line">    </div><div class="line">    <span class="comment">/* Read the range detection interrupt status register. */</span></div><div class="line">    intr_status = <a class="code" href="group__group__sar__functions__interrupt.html#ga5792cd1453bb36969f7ccc165f781bc2">Cy_SAR_GetRangeInterruptStatus</a>(SAR);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (intr_status &gt; 0u)</div><div class="line">    {</div><div class="line">        <span class="comment">/* One or more channels triggered the range detection interrupt, do something here. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Clear the handled range interrupt. */</span></div><div class="line">    <a class="code" href="group__group__sar__functions__interrupt.html#ga201c48306ba342bd15618ee7d06a8dd7">Cy_SAR_ClearRangeInterrupt</a>(SAR, intr_status);</div><div class="line"></div><div class="line">    <span class="comment">/* Perform a dummy read of the range interrupt status register for buffered writes. */</span></div><div class="line">    (void)<a class="code" href="group__group__sar__functions__interrupt.html#ga5792cd1453bb36969f7ccc165f781bc2">Cy_SAR_GetRangeInterruptStatus</a>(SAR);</div></div><!-- fragment -->
</div>
</div>
<a id="ga201c48306ba342bd15618ee7d06a8dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga201c48306ba342bd15618ee7d06a8dd7">&#9670;&nbsp;</a></span>Cy_SAR_ClearRangeInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_ClearRangeInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chanMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the range interrupt for the specified channel mask. </p>
<p>The interrupt must be cleared with this function so that the hardware can set subset interrupts and those interrupts can be forwarded to the interrupt controller, if enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">chanMask</td><td>The channel mask. Bit 0 is for channel 0, etc. Typically, this is the value returned from <a class="el" href="group__group__sar__functions__interrupt.html#ga5792cd1453bb36969f7ccc165f781bc2">Cy_SAR_GetRangeInterruptStatus</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1a61f7b5ec97af86cac36623e9cfbc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a61f7b5ec97af86cac36623e9cfbc52">&#9670;&nbsp;</a></span>Cy_SAR_SetRangeInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_SetRangeInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chanMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a range interrupt with software for the specific channel mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">chanMask</td><td>The channel mask. Bit 0 is for channel 0, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaeedb0cc3ed13ed99b43c4deea155ae0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeedb0cc3ed13ed99b43c4deea155ae0a">&#9670;&nbsp;</a></span>Cy_SAR_SetRangeInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_SetRangeInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chanMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable which channels can trigger a range interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">chanMask</td><td>The channel mask. Bit 0 is for channel 0, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Enable the range detection interrupt for channel 0 only.</span></div><div class="line"><span class="comment">     * Make sure to assign an ISR to handle the SAR interrupts. */</span></div><div class="line">    uint32_t chanMask = 1UL;</div><div class="line">    <a class="code" href="group__group__sar__functions__interrupt.html#gaeedb0cc3ed13ed99b43c4deea155ae0a">Cy_SAR_SetRangeInterruptMask</a>(SAR, chanMask);</div><div class="line">    </div></div><!-- fragment -->
</div>
</div>
<a id="ga4e793fbf9d16432a806c4dffe05ccf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e793fbf9d16432a806c4dffe05ccf26">&#9670;&nbsp;</a></span>Cy_SAR_GetRangeInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetRangeInterruptMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return which interrupts can trigger a range interrupt as configured by <a class="el" href="group__group__sar__functions__interrupt.html#gaeedb0cc3ed13ed99b43c4deea155ae0a">Cy_SAR_SetRangeInterruptMask</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The range interrupt mask </dd></dl>

</div>
</div>
<a id="ga78c2caa3c75b6c88794d7969a6de5c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c2caa3c75b6c88794d7969a6de5c25">&#9670;&nbsp;</a></span>Cy_SAR_GetRangeInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetRangeInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise AND between the range interrupt request and mask registers. </p>
<p>See <a class="el" href="group__group__sar__functions__interrupt.html#ga5792cd1453bb36969f7ccc165f781bc2">Cy_SAR_GetRangeInterruptStatus</a> and <a class="el" href="group__group__sar__functions__interrupt.html#ga4e793fbf9d16432a806c4dffe05ccf26">Cy_SAR_GetRangeInterruptMask</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitwise AND between of range interrupt request and mask </dd></dl>

</div>
</div>
<a id="gabc17a598903d803a3987008189a91ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc17a598903d803a3987008189a91ef3">&#9670;&nbsp;</a></span>Cy_SAR_GetSatInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetSatInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the saturate interrupt register status. </p>
<p>If the status bit is low for a channel, the channel may not be enabled (<a class="el" href="group__group__sar__functions__config.html#ga4808c2e7e72e2648c0efbf3eb025366f">Cy_SAR_SetChanMask</a>), saturation detection is not enabled for the channel (<a class="el" href="group__group__sar__functions__interrupt.html#gae3805ab0afd092b89e1e4a773748b525">Cy_SAR_SetSatInterruptMask</a>), or saturation detection was not triggered for the channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The saturate interrupt status for all channels. Bit 0 is for channel 0, etc.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Saturation detection has been enabled for at least one channel.</span></div><div class="line"><span class="comment">     * Check the saturation interrupt status in the ISR when an interrupt occurs. */</span></div><div class="line">    </div><div class="line">    uint32_t intr_status = 0u;</div><div class="line">    </div><div class="line">    <span class="comment">/* Read the saturation detection interrupt status register. */</span></div><div class="line">    intr_status = <a class="code" href="group__group__sar__functions__interrupt.html#gabc17a598903d803a3987008189a91ef3">Cy_SAR_GetSatInterruptStatus</a>(SAR);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (intr_status &gt; 0u)</div><div class="line">    {</div><div class="line">        <span class="comment">/* One or more channel saturated (the sampled value is equal to the</span></div><div class="line"><span class="comment">         * minimum or maximum, do something here. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Clear the handled saturation interrupt. */</span></div><div class="line">    <a class="code" href="group__group__sar__functions__interrupt.html#ga16eb332fdbd99fff917814efafa4a47b">Cy_SAR_ClearSatInterrupt</a>(SAR, intr_status);</div><div class="line"></div><div class="line">    <span class="comment">/* Perform a dummy read of the saturation interrupt status register for buffered writes. */</span></div><div class="line">    (void)<a class="code" href="group__group__sar__functions__interrupt.html#gabc17a598903d803a3987008189a91ef3">Cy_SAR_GetSatInterruptStatus</a>(SAR);</div></div><!-- fragment -->
</div>
</div>
<a id="ga16eb332fdbd99fff917814efafa4a47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16eb332fdbd99fff917814efafa4a47b">&#9670;&nbsp;</a></span>Cy_SAR_ClearSatInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_ClearSatInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chanMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the saturate interrupt for the specified channel mask. </p>
<p>The interrupt must be cleared with this function so that the hardware can set subsequent interrupts and those interrupts can be forwarded to the interrupt controller, if enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">chanMask</td><td>The channel mask. Bit 0 is for channel 0, etc. Typically, this is the value returned from <a class="el" href="group__group__sar__functions__interrupt.html#gabc17a598903d803a3987008189a91ef3">Cy_SAR_GetSatInterruptStatus</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga61bd47b40bde7befe53dbb9accde66b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61bd47b40bde7befe53dbb9accde66b8">&#9670;&nbsp;</a></span>Cy_SAR_SetSatInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_SetSatInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chanMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a saturate interrupt with software for the specific channel mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">chanMask</td><td>The channel mask. Bit 0 is for channel 0, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae3805ab0afd092b89e1e4a773748b525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3805ab0afd092b89e1e4a773748b525">&#9670;&nbsp;</a></span>Cy_SAR_SetSatInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_SAR_SetSatInterruptMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chanMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable which channels can trigger a saturate interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
    <tr><td class="paramname">chanMask</td><td>The channel mask. Bit 0 is for channel 0, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Enable the saturation detection interrupt for all 16 channels.</span></div><div class="line"><span class="comment">     * Only enabled channels, see Cy_SAR_SetChanMask(), are scanned. </span></div><div class="line"><span class="comment">     * Make sure to assign an ISR to handle the SAR interrupts. */</span></div><div class="line">    </div><div class="line">    uint32_t chanMask = 0xFFFFUL;</div><div class="line">    <a class="code" href="group__group__sar__functions__interrupt.html#gae3805ab0afd092b89e1e4a773748b525">Cy_SAR_SetSatInterruptMask</a>(SAR, chanMask);</div></div><!-- fragment -->
</div>
</div>
<a id="gaead58c8afb23f3a7b3bbdba152653af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead58c8afb23f3a7b3bbdba152653af2">&#9670;&nbsp;</a></span>Cy_SAR_GetSatInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetSatInterruptMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return which interrupts can trigger a saturate interrupt as configured by <a class="el" href="group__group__sar__functions__interrupt.html#gae3805ab0afd092b89e1e4a773748b525">Cy_SAR_SetSatInterruptMask</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The saturate interrupt mask. Bit 0 is for channel 0, etc. </dd></dl>

</div>
</div>
<a id="ga164f131dbc64b5ad4e59ec740de5e292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164f131dbc64b5ad4e59ec740de5e292">&#9670;&nbsp;</a></span>Cy_SAR_GetSatInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetSatInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitwise AND between the saturate interrupt request and mask registers. </p>
<p>See <a class="el" href="group__group__sar__functions__interrupt.html#gabc17a598903d803a3987008189a91ef3">Cy_SAR_GetSatInterruptStatus</a> and <a class="el" href="group__group__sar__functions__interrupt.html#gaead58c8afb23f3a7b3bbdba152653af2">Cy_SAR_GetSatInterruptMask</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitwise AND of the saturate interrupt request and mask </dd></dl>

</div>
</div>
<a id="ga030844e4a8cd612cb11195b0400c800d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga030844e4a8cd612cb11195b0400c800d">&#9670;&nbsp;</a></span>Cy_SAR_GetInterruptCause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_SAR_GetInterruptCause </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_r___type.html">SAR_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the cause of the interrupt. </p>
<p>The interrupt routine can be called due to one of the following events:</p><ul>
<li>End of scan (EOS)</li>
<li>Overflow</li>
<li>Firmware collision</li>
<li>Saturation detected on one or more channels</li>
<li>Range detected on one or more channels</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to structure describing registers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of what caused the interrupt. Compare this value with one of these masks:<ul>
<li>SAR_INTR_CAUSE_EOS_MASKED_MIR_Msk : EOS caused the interrupt</li>
<li>SAR_INTR_CAUSE_OVERFLOW_MASKED_MIR_Msk : Overflow caused the interrupt</li>
<li>SAR_INTR_CAUSE_FW_COLLISION_MASKED_MIR_Msk : Firmware collision cause the interrupt</li>
<li>SAR_INTR_CAUSE_SATURATE_MASKED_RED_Msk : Saturation detection on one or more channels caused the interrupt</li>
<li>SAR_INTR_CAUSE_RANGE_MASKED_RED_Msk : Range detection on one or more channels caused the interrupt </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
