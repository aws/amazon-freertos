<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: WDT          (Watchdog Timer)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__wdt.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">WDT (Watchdog Timer)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The Watchdog timer (WDT) has a 16-bit free-running up-counter. </p>
<p>The functions and other declarations used in this driver are in cy_wdt.h. You can include cy_pdl.h (ModusToolbox only) to get access to all functions and declarations in the PDL.</p>
<p>The WDT can issue counter match interrupts, and a device reset if its interrupts are not handled. Use the Watchdog timer for two main purposes:</p>
<p>The <b> First use case </b> is recovering from a CPU or firmware failure. A timeout period is set up in the Watchdog timer, and if a timeout occurs, the device is reset (WRES). <br />
 The <b>Second use case</b> is to generate periodic interrupts. It is strongly recommended not to use the WDT for periodic interrupt generation. However, if absolutely required, see information below.</p>
<p>A "reset cause" register exists, and the firmware should check this register at a start-up. An appropriate action can be taken if a WRES reset is detected.</p>
<p>The user's firmware periodically resets the timeout period (clears or "feeds" the watchdog) before a timeout occurs. If the firmware fails to do so, that is considered to be a CPU crash or a firmware failure, and the reason for a device reset. The WDT can generate an interrupt instead of a device reset. The Interrupt Service Routine (ISR) can handle the interrupt either as a periodic interrupt, or as an early indication of a firmware failure and respond accordingly. However, it is not recommended to use the WDT for periodic interrupt generation. The Multi-counter Watchdog Timers (MCWDT) can be used to generate periodic interrupts if such are presented in the device.</p>
<p><b> Functional Description </b></p>
<p>The WDT generates an interrupt when the count value in the counter equals the configured match value.</p>
<p>Note that the counter is not reset on a match. In such case the WDT reset period is: WDT_Reset_Period = ILO_Period * (2*2^(16-IgnoreBits) + MatchValue); When the counter reaches a match value, it generates an interrupt and then keeps counting up until it overflows and rolls back to zero and reaches the match value again, at which point another interrupt is generated.</p>
<p>To use a WDT to generate a periodic interrupt, the match value should be incremented in the ISR. As a result, the next WDT interrupt is generated when the counter reaches a new match value.</p>
<p>You can also reduce the entire WDT counter period by specifying the number of most significant bits that are ignored in the WDT counter. For example, if the <a class="el" href="group__group__wdt__functions.html#gafad1413ff11cfb3e3e2b5d9854dc793e" title="Configures the number of the most significant bits of the Watchdog timer that are not checked against...">Cy_WDT_SetIgnoreBits()</a> function is called with parameter 3, the WDT counter becomes a 13-bit free-running up-counter.</p>
<p><b> Power Modes </b></p>
<p>WDT can operate in all possible low power modes. Operation during Hibernate mode is possible because the logic and high-voltage internal low oscillator (ILO) are supplied by the external high-voltage supply (Vddd). The WDT can be configured to wake the device from Hibernate mode.</p>
<p>In CPU Active mode, an interrupt request from the WDT is sent to the CPU. In CPU Sleep, CPU Deep Sleep mode, the CPU subsystem is powered down, so the interrupt request from the WDT is sent directly to the WakeUp Interrupt Controller (WIC) which will then wake up the CPU. The CPU then acknowledges the interrupt request and executes the ISR.</p>
<p><b> Clock Source </b></p>
<p>The WDT is clocked by the ILO. The WDT must be disabled before disabling the ILO. According to the device datasheet, the ILO accuracy is +/-30% over voltage and temperature. This means that the timeout period may vary by 30% from the configured value. Appropriate margins should be added while configuring WDT intervals to make sure that unwanted device resets do not occur on some devices.</p>
<p>Refer to the device datasheet for more information on the oscillator accuracy.</p>
<p><b> Register Locking </b></p>
<p>You can prevent accidental corruption of the WDT configuration by calling the <a class="el" href="group__group__wdt__functions.html#gaec9bd8d1439389a46cdd2dcadc8e987d" title="Locks out configuration changes to the Watchdog Timer register. ">Cy_WDT_Lock()</a> function. When the WDT is locked, any writing to the WDT_*, CLK_ILO_CONFIG, CLK_SELECT.LFCLK_SEL, and CLK_TRIM_ILO_CTL registers is ignored. Call the <a class="el" href="group__group__wdt__functions.html#ga51094ce9149f69553b6348eccbd89667" title="Unlocks the Watchdog Timer configuration register. ">Cy_WDT_Unlock()</a> function to allow registers modification, mentioned above.</p>
<p>Note that the WDT lock state is not retained during system Deep Sleep. After the wakeup from system Deep Sleep the WDT is locked.</p>
<p><b> Clearing WDT </b></p>
<p>The ILO clock is asynchronous to the SysClk. Therefore it generally takes three ILO cycles for WDT register changes to come into effect. It is important to remember that a WDT should be cleared at least four cycles (3 + 1 for sure) before a timeout occurs, especially when small match values / low-toggle bit numbers are used.</p>
<dl class="section warning"><dt>Warning</dt><dd>It may happen that a WDT reset can be generated faster than a device start-up. To prevent this, calculate the start-up time and WDT reset time. The WDT reset time should be always greater than device start-up time.</dd></dl>
<p><b> Reset Detection </b></p>
<p>Use the <a class="el" href="group__group__syslib__functions.html#gac8aa61d2f8052886c676f4f592d1693d" title="The function returns the cause for the latest reset(s) that occurred in the system. ">Cy_SysLib_GetResetReason()</a> function to detect whether the WDT has triggered a device reset.</p>
<p><b> Interrupt Configuration </b></p>
<p>If the WDT is configured to generate an interrupt, pending interrupts must be cleared within the ISR (otherwise, the interrupt will be generated continuously). A pending interrupt to the WDT block must be cleared by calling the <a class="el" href="group__group__wdt__functions.html#ga727d9ae6fdba36809bf631985a3eb987" title="Clears the WDT match flag which is set every time the WDT counter reaches a WDT match value...">Cy_WDT_ClearInterrupt()</a> function. The call to the function will clear the unhandled WDT interrupt counter.</p>
<p>Use the WDT ISR as a timer to trigger certain actions and to change a next WDT match value.</p>
<p>Ensure that the interrupts from the WDT are passed to the CPU to avoid unregistered interrupts. Unregistered WDT interrupts result in a continuous device reset. To avoid this, call <a class="el" href="group__group__wdt__functions.html#ga38c69c98675d6024a7d73acb41b24399" title="After unmasking interrupts from the WDT, they are passed to CPU. ">Cy_WDT_UnmaskInterrupt()</a>. After that, call the WDT API functions for interrupt handling/clearing.</p>
<h1><a class="anchor" id="group_wdt_configuration"></a>
Configuration Considerations</h1>
<p>To start the WDT, make sure that ILO is enabled. After the ILO is enabled, ensure that the WDT is unlocked and disabled by calling the <a class="el" href="group__group__wdt__functions.html#ga51094ce9149f69553b6348eccbd89667" title="Unlocks the Watchdog Timer configuration register. ">Cy_WDT_Unlock()</a> and <a class="el" href="group__group__wdt__functions.html#ga709f597d56e7f7fb6717d5ff671491fa" title="Disables the Watchdog timer. ">Cy_WDT_Disable()</a> functions. Set the WDT match value by calling <a class="el" href="group__group__wdt__functions.html#ga1e707a8236e6dcd90eede7e726a2648f" title="Configures the WDT counter match comparison value. ">Cy_WDT_SetMatch()</a> with the required match value. If needed, set the ignore bits for reducing the WDT counter period by calling <a class="el" href="group__group__wdt__functions.html#gafad1413ff11cfb3e3e2b5d9854dc793e" title="Configures the number of the most significant bits of the Watchdog timer that are not checked against...">Cy_WDT_SetIgnoreBits()</a> function. After the WDT configuration is set, call <a class="el" href="group__group__wdt__functions.html#ga82aec7e454d05d03dfd1d6fd5e573d5e" title="Enables the Watchdog timer. ">Cy_WDT_Enable()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Enable a WDT if the power supply can produce sudden brownout events that may compromise the CPU functionality. This ensures that the system can recover after a brownout.</dd></dl>
<p>When the WDT is used to protect against system crashes, the WDT interrupt should be cleared by a portion of the code that is not directly associated with the WDT interrupt. Otherwise, it is possible that the main firmware loop has crashed or is in an endless loop, but the WDT interrupt vector continues to operate and service the WDT. The user should:</p><ul>
<li>Feed the watchdog by clearing the interrupt bit regularly in the main body of the firmware code.</li>
<li>Guarantee that the interrupt is cleared at least once every WDT period.</li>
<li>Use the WDT ISR only as a timer to trigger certain actions and to change the next match value.</li>
</ul>
<h1><a class="anchor" id="group_wdt_section_more_information"></a>
More Information</h1>
<p>For more information on the WDT peripheral, refer to the technical reference manual (TRM).</p>
<h1><a class="anchor" id="group_wdt_MISRA"></a>
MISRA-C Compliance</h1>
<p>The WDT driver does not have any specific deviations.</p>
<h1><a class="anchor" id="group_wdt_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.20 </td><td>Added a new API function <a class="el" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled()</a>  </td><td>Enhancement based on usability feedback.  </td></tr>
<tr>
<td>1.10.1 </td><td>Added info that the WDT lock state is not retained during system Deep Sleep power mode.  </td><td>Documentation updates.  </td></tr>
<tr>
<td rowspan="4">1.10 </td><td>Flattened the organization of the driver source code into the single source directory and the single include directory.  </td><td>Driver library directory-structure simplification.  </td></tr>
<tr>
<td>Removed critical section usage in the following functions:<ul>
<li><a class="el" href="group__group__wdt__functions.html#gaac6f64babfb1855f9ba8aecccc19ecb4">Cy_WDT_Init()</a></li>
<li><a class="el" href="group__group__wdt__functions.html#gaec9bd8d1439389a46cdd2dcadc8e987d">Cy_WDT_Lock()</a></li>
<li><a class="el" href="group__group__wdt__functions.html#ga51094ce9149f69553b6348eccbd89667">Cy_WDT_Unlock()</a>  </li>
</ul>
</td><td>Driver functions simplification  </td></tr>
<tr>
<td>Updated the <a class="el" href="group__group__wdt__functions.html#gaac6f64babfb1855f9ba8aecccc19ecb4">Cy_WDT_Init()</a>, <a class="el" href="group__group__wdt__functions.html#ga82aec7e454d05d03dfd1d6fd5e573d5e">Cy_WDT_Enable()</a> to clear WDT interrupt. </td><td>Corner case reliability improvements  </td></tr>
<tr>
<td>Added register access layer. Use register access macros instead of direct register access using dereferenced pointers. </td><td>Makes register access device-independent, so that the PDL does not need to be recompiled for each supported part number.  </td></tr>
<tr>
<td>1.0.2 </td><td>Minor documentation updates </td><td>Corrected info about a reset generation  </td></tr>
<tr>
<td>1.0.1 </td><td>General documentation updates </td><td>Added info about periodic interrupt generation use case  </td></tr>
<tr>
<td>1.0 </td><td>Initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__wdt__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__wdt__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
