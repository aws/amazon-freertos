<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC 6 Peripheral Driver Library: CSD          (CapSense Sigma Delta)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC 6 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__csd.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">CSD (CapSense Sigma Delta)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The CSD HW block enables multiple sensing capabilities on PSoC devices, including self-cap and mutual-cap capacitive touch sensing solutions, a 10-bit ADC, IDAC, and Comparator. </p>
<p>The CapSense solution includes:</p><ul>
<li>The CapSense Configurator tool, which is a configuration wizard to create and configure CapSense widgets. It can be launched in ModusToolbox from the CSD personality as well as in standalone mode. It contains separate documentation on how to create and configure widgets, parameters, and algorithm descriptions.</li>
<li>An API to control the design from the application program. This documentation describes the API with code snippets about how to use them.</li>
<li>The CapSense Tuner tool for real-time tuning, testing, and debugging, for easy and smooth design of human interfaces on customer products. The Tuner tool communicates with a device through a HW bridge and communication drivers (EzI2C, UART, etc.) and allows monitoring of widget statuses, sensor signals, detected touch positions, gestures, etc. The application program does not need to interact with the CSD driver and/or other drivers such as GPIO or SysClk directly. All of that is configured and managed by middleware.</li>
</ul>
<div class="image">
<img src="capsense_solution.png" alt="capsense_solution.png" width="800px"/>
<div class="caption">
CapSense Solution</div></div>
 <p>This section describes only the CSD driver. Refer to the corresponding sections for documentation of middleware supported by the CSD HW block.</p>
<p>The CSD driver is a low-level peripheral driver that provides an interface to a complex mixed signal of the CSD HW block.</p>
<p>The CSD driver alone does not provide system-level functions. Instead, it is used by upper-level middleware to configure the CSD HW block required by an application.</p>
<p>The CSD HW block can support only one function at a time. To allow seamless time-multiplex implementation of functionality and to avoid conflicting access to hardware from the upper level, the CSD driver also implements a lock semaphore mechanism.</p>
<p>The CSD driver supports re-entrance. If a device contains several CSD HW blocks, the same CSD driver is used to configure any HW block. For that, each function of the CSD driver contains a base address to define the CSD HW block to which the CSD driver communicates.</p>
<p>For dual-core devices, the CSD driver functions can be called either by the CM0+ or CM4 cores. In case both cores need access to the CSD Driver, you should properly manage the memory access.</p>
<p>There is no restriction on the CSD Driver usage in RTOS.</p>
<h1><a class="anchor" id="group_csd_config_usage"></a>
Usage</h1>
<p>The CSD driver is simple wrapper driver specifically designed to be used by higher level middleware. Hence, is highly not recommended to use CSD driver directly in the application program. To incorporate CSD HW block functionality in the application program, an associated middleware should be used.</p>
<p>The CSD Driver can be used to implement a custom sensing solution. In such a case, the application program must acquire and lock the CSD HW block prior to accessing it.</p>
<p>Setting up and using the CSD driver can be summed up in these four stages:</p><ul>
<li>Define configuration in the config structure.</li>
<li>Allocate context structure variable for the driver.</li>
<li>Capture the CSD HW block.</li>
<li>Execute the action required to perform any kind of conversion.</li>
</ul>
<p>The following code snippet demonstrates how to capture the CSD HW block for custom implementation:</p>
<div class="fragment"><div class="line">    </div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">    * Scenario: Need to perform a conversion. It is supposed that Pins, Clock, </span></div><div class="line"><span class="comment">    * Interrupt, pre-charge and scanning configs are already prepared.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    </div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    <a class="code" href="group__group__csd__enums.html#ga281a1b4a5cddb0bee365a7835985ccba">cy_en_csd_key_t</a> key;</div><div class="line">    <a class="code" href="group__group__csd__enums.html#ga6cde526987c66fff895f48902589f979">cy_en_csd_status_t</a> status;</div><div class="line">    </div><div class="line">    <span class="comment">/* Allocate CSD configuration structure and initialize it with user&#39;s configuration */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__csd__config__t.html">cy_stc_csd_config_t</a> customConfig = PRECHARGE_CONFIG;</div><div class="line"></div><div class="line">    <span class="comment">/* Check if the CSD block if free */</span></div><div class="line">    key = <a class="code" href="group__group__csd__functions.html#gafc4c25c2faefdfb3f3fdcf070b645c13">Cy_CSD_GetLockStatus</a>(CSD0, &amp;csdContext);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__csd__enums.html#gga281a1b4a5cddb0bee365a7835985ccbaa6ecb94eb2fc43363fdeb79fa9dd965b2">CY_CSD_NONE_KEY</a> == key)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Capture the CSD block and initialize it with user&#39;s configuration */</span></div><div class="line">        status = <a class="code" href="group__group__csd__functions.html#ga22ab53f2e99efe2990b5c99c06dc0be7">Cy_CSD_Init</a>(CSD0, &amp;customConfig, <a class="code" href="group__group__csd__enums.html#gga281a1b4a5cddb0bee365a7835985ccbaaa7ed46ced5551442fae3aaf0ea142686">CY_CSD_USER_DEFINED_KEY</a>, &amp;csdContext);</div><div class="line">        <span class="comment">/* Check if the CSD block was captured successfully */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__csd__enums.html#gga6cde526987c66fff895f48902589f979a0c2b57b4095e1c232b5c41eab3298098">CY_CSD_SUCCESS</a> == status)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Block is captured successfully. User&#39;s application code can be placed and executed here. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    </div></div><!-- fragment --><p> The entire solution, either CapSense or CSDADC, in addition to the CSD HW block, incorporates the following instances:</p>
<ul>
<li><a class="el" href="group__group__csd.html#group_csd_config_clocks">Clocks</a></li>
<li><a class="el" href="group__group__csd.html#group_csd_config_refgen">Reference Voltage Input</a></li>
<li><a class="el" href="group__group__csd.html#group_csd_config_interrupts">Interrupts</a></li>
<li><a class="el" href="group__group__csd.html#group_csd_config_pin">GPIO Pins</a></li>
</ul>
<p>The CSD driver does not configure those blocks and they should be managed by an upper level. When using CapSense or CSDADC, those blocks are managed by middleware.</p>
<h2><a class="anchor" id="group_csd_config_clocks"></a>
Clocks</h2>
<p>The CSD HW block requires a peripheral clock (clk_peri) input. It can be assigned using two methods:</p><ul>
<li>Using the Device Configurator (Peripheral-Clocks tab ).</li>
<li>Using the SysClk (System Clock) driver. Refer to <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver section for more details. If middleware is used, the clock is managed by middleware.</li>
</ul>
<h2><a class="anchor" id="group_csd_config_pin"></a>
GPIO Pins</h2>
<p>Any analog-capable GPIO pin that can be connected to an analog multiplexed bus (AMUXBUS) can be connected to the CSD HW block as an input.</p>
<p>GPIO input can be assigned to the CSD HW block using the following methods:</p><ul>
<li>Using the Device Configurator (Pins tab).</li>
<li>Using the GPIO (General Purpose Input Output) driver. Refer to <a class="el" href="group__group__gpio.html">GPIO (General Purpose Input Output)</a> driver section.</li>
</ul>
<p>If middleware is used, pin configuration is managed by middleware. When using the CSD driver for custom implementation, the application program must manage pin connections.</p>
<p>Each AMUXBUS can be split into multiple segments. Ensure the CSD HW block and a GPIO belong to the same bus segment or join the segments to establish connection of the GPIO to the CSD HW block.</p>
<p>For more information about pin configuration, refer to the <a class="el" href="group__group__gpio.html">GPIO (General Purpose Input Output)</a> driver.</p>
<h2><a class="anchor" id="group_csd_config_refgen"></a>
Reference Voltage Input</h2>
<p>The CSD HW block requires a reference voltage input to generate programmable reference voltage within the CSD HW block. There are two on-chip reference sources:</p><ul>
<li>VREF</li>
<li>AREF</li>
</ul>
<p>For more information about specification and startup of reference voltage sources, refer to the <a class="el" href="group__group__sysanalog.html">SysAnalog (System Analog Reference Block)</a> driver prior to making the selection.</p>
<h2><a class="anchor" id="group_csd_config_interrupts"></a>
Interrupts</h2>
<p>The CSD HW block has one interrupt that can be assigned to either the Cortex M4 or Cortex M0+ core. The CSD HW block can generate interrupts on the following events:</p>
<ul>
<li>End of sample: when scanning of a single sensor is complete.</li>
<li>End of initialization: when initialization of an analog circuit is complete.</li>
<li>End of measurement: when conversion of an CSDADC channel is complete.</li>
</ul>
<p>Additionally, the CSD interrupt can wake the device from the Sleep power mode. The CSD HW block is powered down in the Deep Sleep or Hibernate power modes. So, it cannot be used as a wake-up source in these power modes.</p>
<p>If a CapSense or ADC middleware is used, the interrupt service routine is managed by middleware. When using the CSD driver for custom implementation or other middleware, the application program must manage the interrupt service routine.</p>
<p>Implement an interrupt routine and assign it to the CSD interrupt. Use the pre-defined enumeration as the interrupt source of the CSD HW block. The CSD interrupt to the NVIC is raised any time the intersection (logic AND) of the interrupt flags and the corresponding interrupt masks are non-zero. The peripheral interrupt status register should be read in the ISR to detect which condition generated the interrupt. The appropriate interrupt registers should be cleared so that subsequent interrupts can be handled.</p>
<p>The following code snippet demonstrates how to implement a routine to handle the interrupt. The routine is called when a CSD interrupt is triggered.</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keywordtype">void</span> snippet_Cy_CSD_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        uint32_t intrStatus;</div><div class="line"></div><div class="line">        <span class="comment">/* Read interrupt status register */</span></div><div class="line">        intrStatus = <a class="code" href="group__group__csd__functions.html#ga34f48f5162adea39ed451877893a1552">Cy_CSD_ReadReg</a>(CSD0, <a class="code" href="group__group__csd__reg__const.html#ga6acd77ce405ea93b0d14b08a9f52e117">CY_CSD_REG_OFFSET_INTR</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Check an event that triggered the interrupt */</span></div><div class="line">        <span class="keywordflow">if</span> ((intrStatus &amp; CSD_INTR_SET_SAMPLE_Msk) == CSD_INTR_SET_SAMPLE_Msk)</div><div class="line">        {</div><div class="line">            <span class="comment">/* End of scan occurred, get the result and do something with it here */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clear pending interrupt */</span></div><div class="line">        <a class="code" href="group__group__csd__functions.html#ga3689a475c33996ff4cb5e8c24d1194c1">Cy_CSD_WriteReg</a>(CSD0, <a class="code" href="group__group__csd__reg__const.html#ga6acd77ce405ea93b0d14b08a9f52e117">CY_CSD_REG_OFFSET_INTR</a>, intrStatus);</div><div class="line">        (void)<a class="code" href="group__group__csd__functions.html#ga34f48f5162adea39ed451877893a1552">Cy_CSD_ReadReg</a>(CSD0, <a class="code" href="group__group__csd__reg__const.html#ga6acd77ce405ea93b0d14b08a9f52e117">CY_CSD_REG_OFFSET_INTR</a>);</div><div class="line">        </div><div class="line">    }</div><div class="line">    </div></div><!-- fragment --><p> The following code snippet demonstrates how to configure and enable the CSD interrupt:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> CSD0_ISR_cfg =</div><div class="line">    {</div><div class="line"><span class="preprocessor">        #if (CY_CPU_CORTEX_M0P)</span></div><div class="line"><span class="preprocessor">            #if (CY_IP_M4CPUSS_VERSION == 1)</span></div><div class="line">                .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a> = NvicMux8_IRQn,       <span class="comment">/* CM0+ interrupt is NVIC #8 */</span></div><div class="line"><span class="preprocessor">            #else</span></div><div class="line">                .intrSrc = NvicMux7_IRQn,       <span class="comment">/* CM0+ interrupt is NVIC #7 */</span></div><div class="line"><span class="preprocessor">            #endif</span></div><div class="line">            .cm0pSrc = csd_interrupt_IRQn,  <span class="comment">/* Source of NVIC #8 is the CSD interrupt */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configure the interrupt with vector at snippet_Cy_CSD_IntHandler() */</span></div><div class="line">    (void)<a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;CSD0_ISR_cfg, snippet_Cy_CSD_IntHandler);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the interrupt */</span></div><div class="line">    NVIC_EnableIRQ(CSD0_ISR_cfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the CSD SAMPLE interrupt mask */</span></div><div class="line">    <a class="code" href="group__group__csd__functions.html#ga3689a475c33996ff4cb5e8c24d1194c1">Cy_CSD_WriteReg</a>(CSD0, <a class="code" href="group__group__csd__reg__const.html#ga4d672ab537cfdd238ed7cb340dca26e3">CY_CSD_REG_OFFSET_INTR_MASK</a>, CSD_INTR_MASK_SAMPLE_Msk);</div><div class="line">    </div></div><!-- fragment --><p> For more information, refer to the <a class="el" href="group__group__sysint.html">SysInt (System Interrupt)</a> driver.</p>
<p>Alternatively, instead of handling the interrupts, the <a class="el" href="group__group__csd__functions.html#gab3e991dec9a467c332da3f904bdf5acc">Cy_CSD_GetConversionStatus()</a> function allows for firmware polling of the CSD block status.</p>
<h1><a class="anchor" id="group_csd_config_power_modes"></a>
Power Modes</h1>
<p>The CSD HW block can operate in Active and Sleep CPU power modes. It is also possible to switch between Low power and Ultra Low power system modes. In Deep Sleep and in Hibernate power modes, the CSD HW block is powered off. When the device wakes up from Deep Sleep, the CSD HW block resumes operation without the need for re-initialization. In the case of wake up from Hibernate power mode, the CSD HW block does not retain configuration and it requires re-initialization.</p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>The CSD driver does not provide a callback function to facilitate the low-power mode transitions. The responsibility belongs to an upper level that uses the CSD HW block to ensure the CSD HW block is not busy prior to a power mode transition.</li>
<li>A power mode transition is not recommended while the CSD HW block is busy. The CSD HW block status must be checked using the Cy_CSD_GetStatus() function prior to a power mode transition. Instead, use the same power mode for active operation of the CSD HW block. This restriction is not applicable to Sleep mode and the device can seamlessly enter and exit Sleep mode while the CSD HW block is busy.</li>
</ol>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><ol type="1">
<li>Do not enter Deep Sleep power mode if the CSD HW block conversion is in progress. Unexpected behavior may occur.</li>
<li>Analog start up time for the CSD HW block is 25 us. Initiate any kind of conversion only after 25 us from Deep Sleep / Hibernate exit.</li>
</ol>
</dd></dl>
<p>Refer to the <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about low-power mode transitions.</p>
<h1><a class="anchor" id="group_csd_more_information"></a>
More Information</h1>
<p>For more information, refer to the following documents:</p>
<ul>
<li><a href="http://www.cypress.com/trm218176"><b>Technical Reference Manual (TRM)</b></a></li>
<li><a href="https://github.com/cypresssemiconductorco/capsense"><b>Cypress CapSense Middleware Library</b></a></li>
<li><a href="https://cypresssemiconductorco.github.io/capsense/capsense_api_reference_manual/html/index.html"><b>Cypress CapSense Middleware API Reference Guide</b></a></li>
<li><a href="https://github.com/cypresssemiconductorco/csdadc"><b>Cypress CSDADC Middleware Library</b></a></li>
<li><a href="https://cypresssemiconductorco.github.io/csdadc/csdadc_api_reference_manual/html/index.html"><b>Cypress CSDADC Middleware API Reference Guide</b></a></li>
<li><a href="https://github.com/cypresssemiconductorco/csdidac"><b>Cypress CSDIDAC Middleware Library</b></a></li>
<li><a href="https://cypresssemiconductorco.github.io/csdidac/csdidac_api_reference_manual/html/index.html"><b>Cypress CSDIDAC Middleware API Reference Guide</b></a></li>
<li><a class="el" href="page_getting_started.html">Getting Started with the PDL</a></li>
<li><a href="http://www.cypress.com/ds218787"><b>PSoC 63 with BLE Datasheet Programmable System-on-Chip</b></a></li>
<li><a href="http://www.cypress.com/an85951"><b>AN85951 PSoC 4 and PSoC 6 MCU CapSense Design Guide for more detail</b></a></li>
<li><a href="http://www.cypress.com/an210781"><b>AN210781 Getting Started with PSoC 6 MCU with Bluetooth Low Energy (BLE) Connectivity</b></a></li>
</ul>
<h1><a class="anchor" id="group_csd_MISRA"></a>
MISRA-C Compliance</h1>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th>Description of Deviation(s)  </th></tr>
<tr>
<td>14.2 </td><td>R </td><td>All non-null statements shall either: a) have at least one side-effect however executed, or b) cause control flow to change. </td><td>The unused function parameters are cast to void. This statement has no side effect and is used to suppress a compiler warning.  </td></tr>
<tr>
<td>20.6 </td><td>R </td><td>The macro offsetof, in library &lt;stddef.h&gt;, shall not be used. </td><td>The only CSD HW block register offsets are defined using this macro to implement functions Read/WriteReg.  </td></tr>
</table>
<h1><a class="anchor" id="group_csd_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td rowspan="2">1.10 </td><td>The CSD driver sources are enclosed with the conditional compilation to ensure a successful compilation for non-CapSense-capable devices  </td><td>Compilation for non-CapSense-capable devices </td></tr>
<tr>
<td>Changed the <a class="el" href="group__group__csd__functions.html#gab3e991dec9a467c332da3f904bdf5acc" title="Verifies whether the specified CSD HW block is busy (performing scan or conversion). ">Cy_CSD_GetConversionStatus()</a> function implementation </td><td>Fixed defect   </td></tr>
<tr>
<td>1.0.1 </td><td>Documentation updates </td><td>Improve user's experience  </td></tr>
<tr>
<td>1.0 </td><td>The initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__csd__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csd__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__csd__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csd__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__csd__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csd__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__csd__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csd__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC 6 Peripheral Driver Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
